<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>spec_modinv64.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> VST.floyd.proofauto.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> jets_secp256k1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Coq.Logic.Eqdep_dec.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> progressC.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> extraMath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> modinv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require</span> divstep.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk0">#[export] <span class="kn">Instance</span> <span class="nf">CompSpecs</span> : compspecs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">compspecs</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">make_compspecs prog.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Opaque</span> Z.shiftr Z.pow.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">t_secp256k1_modinv64_signed62</span> := Tstruct _secp256k1_modinv64_signed62 noattr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">t_secp256k1_modinv64_modinfo</span> := Tstruct _secp256k1_modinv64_modinfo noattr.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Signed62</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">max_signed</span> <span class="nv">n</span> : Z := <span class="mi">2</span>^(n*<span class="mi">62</span>)-<span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">min_signed</span> <span class="nv">n</span> : Z := -<span class="mi">2</span>^(n*<span class="mi">62</span>).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">signed</span> (<span class="nv">l</span> : list int64) : Z :=
<span class="kr">match</span> l <span class="kr">with</span>
| [] =&gt; <span class="mi">0</span>
| (a :: l&#39;) =&gt; Int64.signed a + <span class="mi">2</span>^<span class="mi">62</span> * signed l&#39;
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk1"><span class="kn">Lemma</span> <span class="nf">app_signed</span> <span class="nv">l1</span> <span class="nv">l2</span> : signed (l1 ++ l2) = signed l1 + <span class="mi">2</span>^(Zlength l1 * <span class="mi">62</span>) * signed l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed (l1 ++ l2) = signed l1
                      + <span class="mi">2</span> ^ (Zlength l1 * <span class="mi">62</span>)
                          * signed l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk2"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed (l1 ++ l2) = signed l1
                      + <span class="mi">2</span> ^ (Zlength l1 * <span class="mi">62</span>)
                          * signed l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk3"><span class="nb">revert</span> l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l2</span> : list int64,
signed (l1 ++ l2) = signed l1
                      + <span class="mi">2</span> ^ (Zlength l1 * <span class="mi">62</span>)
                          * signed l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk4"><span class="nb">induction</span> l1; <span class="nb">intros</span> l2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed ([] ++ l2) = signed []
                      + <span class="mi">2</span> ^ (Zlength [] * <span class="mi">62</span>)
                          * signed l2</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list int64,
signed (l1 ++ l2) = signed l1
                      + <span class="mi">2</span> ^ (Zlength l1 * <span class="mi">62</span>)
                        * signed l2</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk5"><hr></label><div class="goal-conclusion">signed ((a :: l1) ++ l2) = signed (a :: l1)
                             + <span class="mi">2</span>
                                 ^ (Zlength (a :: l1)
                                      * <span class="mi">62</span>)
                                 * signed l2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk6">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed ([] ++ l2) = signed []
                      + <span class="mi">2</span> ^ (Zlength [] * <span class="mi">62</span>)
                          * signed l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk7"><span class="nb">rewrite</span> Z.pow_0_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed ([] ++ l2) = signed [] + <span class="mi">1</span> * signed l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk8"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed l2 = <span class="mi">0</span> + <span class="mi">1</span> * signed l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk9">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list int64,
signed (l1 ++ l2) = signed l1
                      + <span class="mi">2</span> ^ (Zlength l1 * <span class="mi">62</span>)
                        * signed l2</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed ((a :: l1) ++ l2) = signed (a :: l1)
                             + <span class="mi">2</span>
                                 ^ (Zlength (a :: l1)
                                      * <span class="mi">62</span>)
                                 * signed l2</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka"><span class="nb">rewrite</span> Zlength_cons.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list int64,
signed (l1 ++ l2) = signed l1
                      + <span class="mi">2</span> ^ (Zlength l1 * <span class="mi">62</span>)
                        * signed l2</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed ((a :: l1) ++ l2) = signed (a :: l1)
                             + <span class="mi">2</span>
                                 ^ (Z.succ
                                      (Zlength l1)
                                      * <span class="mi">62</span>)
                                 * signed l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list int64,
signed (l1 ++ l2) = signed l1
                      + <span class="mi">2</span> ^ (Zlength l1 * <span class="mi">62</span>)
                        * signed l2</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.signed a + <span class="mi">2</span> ^ <span class="mi">62</span> * signed (l1 ++ l2) = Int64.signed
                                                a
                                                + 
                                                <span class="mi">2</span> ^ <span class="mi">62</span>
                                                 * 
                                                 signed
                                                 l1
                                                + 
                                                <span class="mi">2</span>
                                                 ^ 
                                                 (Z.succ
                                                 (Zlength
                                                 l1)
                                                 * <span class="mi">62</span>)
                                                 * 
                                                 signed
                                                 l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkc"><span class="nb">assert</span> (Hlen := Zlength_nonneg l1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l1</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">l2</span> : list int64,
signed (l1 ++ l2) = signed l1
                      + <span class="mi">2</span> ^ (Zlength l1 * <span class="mi">62</span>)
                        * signed l2</span></span></span><br><span><var>l2</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Zlength l1</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.signed a + <span class="mi">2</span> ^ <span class="mi">62</span> * signed (l1 ++ l2) = Int64.signed
                                                a
                                                + 
                                                <span class="mi">2</span> ^ <span class="mi">62</span>
                                                 * 
                                                 signed
                                                 l1
                                                + 
                                                <span class="mi">2</span>
                                                 ^ 
                                                 (Z.succ
                                                 (Zlength
                                                 l1)
                                                 * <span class="mi">62</span>)
                                                 * 
                                                 signed
                                                 l2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> IHl1, Z.mul_succ_l, Z.pow_add_r; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">reprn</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : Z) : list int64 :=
<span class="kr">match</span> n <span class="kr">with</span>
| <span class="mi">0</span>%nat =&gt; []
| <span class="mi">1</span>%nat =&gt; [Int64.repr a]
| (S n0) =&gt; Int64.repr (a mod (<span class="mi">2</span> ^ <span class="mi">62</span>)) :: (reprn n0 (Z.shiftr a <span class="mi">62</span>))
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkd"><span class="kn">Lemma</span> <span class="nf">reprn_length</span> <span class="nv">n</span> : <span class="kr">forall</span> <span class="nv">a</span>, length (reprn n a) = n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Z, Datatypes.length (reprn n a) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Z, Datatypes.length (reprn n a) = n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf"><span class="nb">induction</span> n;<span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z, Datatypes.length (reprn n a) = n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Z, Datatypes.length (reprn (S n) a) = S n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk10"><span class="nb">destruct</span> n;<span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z, Datatypes.length (reprn (S n) a) = S n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Z,
Datatypes.length (reprn (S (S n)) a) = S (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span> a; <span class="nb">simpl</span> <span class="kr">in</span> *; <span class="nb">rewrite</span> IHn; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk11"><span class="kn">Lemma</span> <span class="nf">reprn_Zlength</span> <span class="nv">n</span> : <span class="kr">forall</span> <span class="nv">a</span>, Zlength (reprn n a) = Z.of_nat n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Z, Zlength (reprn n a) = Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk12"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Z, Zlength (reprn n a) = Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk13"><span class="nb">intros</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zlength (reprn n a) = Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> Zlength_correct, Signed62.reprn_length; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk14"><span class="kn">Lemma</span> <span class="nf">reprn_succ</span> <span class="nv">n</span> <span class="nv">a</span> : reprn (S n) a = 
  reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++ [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reprn (S n) a = reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
                [Int64.repr
                   (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk15"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reprn (S n) a = reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
                [Int64.repr
                   (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk16"><span class="nb">revert</span> a; <span class="nb">induction</span> n; <span class="nb">intros</span> a;[<span class="bp">reflexivity</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
reprn (S n) a = reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))]</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">reprn (S (S n)) a = reprn (S n)
                      (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n))) ++
                    [Int64.repr
                       (Z.shiftr a
                          (<span class="mi">62</span> * Z.of_nat (S n)))]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk17"><span class="nb">pattern</span> (S n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
reprn (S n) a = reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))]</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
 reprn (S n) a = reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
                 [Int64.repr
                    (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))])
  (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk18"><span class="nb">simpl</span> (reprn (S _) a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
reprn (S n) a = reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))]</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">fun</span> <span class="nv">n</span> : nat =&gt;
 <span class="kr">match</span> n <span class="kr">with</span>
 | <span class="mi">0</span>%nat =&gt; [Int64.repr a]
 | S _ =&gt;
     Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
     :: reprn n (Z.shiftr a <span class="mi">62</span>)
 <span class="kr">end</span> = reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
       [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))])
  (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk19"><span class="nb">cbn</span> beta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
reprn (S n) a = reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))]</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> S n <span class="kr">with</span>
| <span class="mi">0</span>%nat =&gt; [Int64.repr a]
| S _ =&gt;
    Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
    :: reprn (S n) (Z.shiftr a <span class="mi">62</span>)
<span class="kr">end</span> = reprn (S n) (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n))) ++
      [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n)))]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk1a"><span class="nb">rewrite</span> IHn, Z.shiftr_shiftr, Nat2Z.inj_succ, Z.mul_succ_r, Z.add_comm <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
reprn (S n) a = reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))]</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
:: reprn n (Z.shiftr a <span class="mi">62</span> mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
   [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n + <span class="mi">62</span>))] = 
reprn (S n) (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">62</span>)) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n + <span class="mi">62</span>))]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk1b"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
reprn (S n) a = reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))]</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
:: reprn n (Z.shiftr a <span class="mi">62</span> mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
   [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n + <span class="mi">62</span>))] = 
<span class="kr">match</span> n <span class="kr">with</span>
| <span class="mi">0</span>%nat =&gt;
    [Int64.repr (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">62</span>))]
| S _ =&gt;
    Int64.repr
      ((a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">62</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>)
    :: reprn n
         (Z.shiftr (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">62</span>))
            <span class="mi">62</span>)
<span class="kr">end</span> ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n + <span class="mi">62</span>))]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk1c"><span class="nb">destruct</span> n;[<span class="bp">reflexivity</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
reprn (S (S n)) a = reprn (S n) (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n))) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n)))]</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
:: reprn (S n)
     (Z.shiftr a <span class="mi">62</span> mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n))) ++
   [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span>))] = 
(Int64.repr
   ((a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>)
 :: reprn (S n)
      (Z.shiftr (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span>))
         <span class="mi">62</span>)) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span>))]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk1d"><span class="nb">rewrite</span> Z.pow_add_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
reprn (S (S n)) a = reprn (S n) (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n))) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n)))]</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
:: reprn (S n)
     (Z.shiftr a <span class="mi">62</span> mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n))) ++
   [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span>))] = 
(Int64.repr
   ((a mod (<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span>))
    mod <span class="mi">2</span> ^ <span class="mi">62</span>)
 :: reprn (S n)
      (Z.shiftr
         (a mod (<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span>))
         <span class="mi">62</span>)) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span>))]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk1e"><span class="nb">rewrite</span> &lt;- Zmod_div_mod, !(Z.shiftr_div_pow2 _ <span class="mi">62</span>) <span class="bp">by</span> (<span class="kp">try</span> <span class="bp">lia</span>; <span class="nb">auto with</span> *).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
reprn (S (S n)) a = reprn (S n) (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n))) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n)))]</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
:: reprn (S n)
     ((a / <span class="mi">2</span> ^ <span class="mi">62</span>) mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n))) ++
   [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span>))] = 
(Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
 :: reprn (S n)
      (a mod (<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span>)
         / <span class="mi">2</span> ^ <span class="mi">62</span>)) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span>))]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk1f"><span class="nb">rewrite</span> (Z.mul_comm _ (<span class="mi">2</span>^<span class="mi">62</span>)), Zaux.Zdiv_mod_mult <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
reprn (S (S n)) a = reprn (S n) (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n))) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n)))]</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
:: reprn (S n)
     ((a / <span class="mi">2</span> ^ <span class="mi">62</span>) mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n))) ++
   [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span>))] = 
(Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
 :: reprn (S n)
      ((a / <span class="mi">2</span> ^ <span class="mi">62</span>) mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)))) ++
[Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span>))]</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk20"><span class="kn">Lemma</span> <span class="nf">reprn_last</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">n</span> <span class="nv">d</span>, (<span class="mi">1</span> &lt;= n)%nat -&gt;
  <span class="nb">last</span> (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">n</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">1</span> &lt;= n)%nat -&gt;
<span class="nb">last</span> (reprn n a) d = Int64.repr
                       (Z.shiftr a
                          (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk21"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">n</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">1</span> &lt;= n)%nat -&gt;
<span class="nb">last</span> (reprn n a) d = Int64.repr
                       (Z.shiftr a
                          (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk22"><span class="nb">intros</span> a n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">d</span> : int64,
(<span class="mi">1</span> &lt;= n)%nat -&gt;
<span class="nb">last</span> (reprn n a) d = Int64.repr
                       (Z.shiftr a
                          (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk23"><span class="nb">revert</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">d</span> : int64),
(<span class="mi">1</span> &lt;= n)%nat -&gt;
<span class="nb">last</span> (reprn n a) d = Int64.repr
                       (Z.shiftr a
                          (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk24"><span class="nb">induction</span> n;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">d</span> : int64),
(<span class="mi">1</span> &lt;= n)%nat -&gt;
<span class="nb">last</span> (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">d</span> : int64),
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
<span class="nb">last</span> (reprn (S n) a) d = Int64.repr
                           (Z.shiftr a
                              (<span class="mi">62</span>
                                 * (Z.of_nat (S n) - <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk25"><span class="nb">intros</span> a d Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">d</span> : int64),
(<span class="mi">1</span> &lt;= n)%nat -&gt;
<span class="nb">last</span> (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>)))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> (reprn (S n) a) d = Int64.repr
                           (Z.shiftr a
                              (<span class="mi">62</span>
                                 * (Z.of_nat (S n) - <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk26"><span class="nb">rewrite</span> Nat2Z.inj_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">d</span> : int64),
(<span class="mi">1</span> &lt;= n)%nat -&gt;
<span class="nb">last</span> (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>)))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> (reprn (S n) a) d = Int64.repr
                           (Z.shiftr a
                              (<span class="mi">62</span>
                                 * (Z.succ
                                      (Z.of_nat n)
                                      - <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk27"><span class="nb">unfold</span> Z.succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">d</span> : int64),
(<span class="mi">1</span> &lt;= n)%nat -&gt;
<span class="nb">last</span> (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>)))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> (reprn (S n) a) d = Int64.repr
                           (Z.shiftr a
                              (<span class="mi">62</span>
                                 * (Z.of_nat n + <span class="mi">1</span> - <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk28"><span class="nb">replace</span> (Z.of_nat n + <span class="mi">1</span> - <span class="mi">1</span>) <span class="kr">with</span> (Z.of_nat n) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">d</span> : int64),
(<span class="mi">1</span> &lt;= n)%nat -&gt;
<span class="nb">last</span> (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>)))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> (reprn (S n) a) d = Int64.repr
                           (Z.shiftr a
                              (<span class="mi">62</span> * Z.of_nat n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk29"><span class="nb">rewrite</span> reprn_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">d</span> : int64),
(<span class="mi">1</span> &lt;= n)%nat -&gt;
<span class="nb">last</span> (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>)))</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span>
  (reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
   [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))]) d = 
Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> last_last.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk2a"><span class="kn">Lemma</span> <span class="nf">reprn_nth</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">n</span> <span class="nv">i</span> <span class="nv">d</span>, (<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
  nth i (reprn n a) d = Int64.repr ((Z.shiftr a (<span class="mi">62</span> * (Z.of_nat i))) mod (<span class="mi">2</span>^<span class="mi">62</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">n</span> <span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr
                        (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i)
                         mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk2b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">n</span> <span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr
                        (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i)
                         mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk2c"><span class="nb">intros</span> a n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr
                        (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i)
                         mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk2d"><span class="nb">revert</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr
                        (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i)
                         mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk2e"><span class="nb">induction</span> n;[<span class="nb">intros</span>; <span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn (S n) a) d = Int64.repr
                            (Z.shiftr a
                               (<span class="mi">62</span> * Z.of_nat i)
                             mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk2f"><span class="nb">intros</span> a i d Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth i (reprn (S n) a) d = Int64.repr
                            (Z.shiftr a
                               (<span class="mi">62</span> * Z.of_nat i)
                             mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk30"><span class="nb">rewrite</span> reprn_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth i
  (reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)) ++
   [Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat n))]) d = 
Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk31"><span class="nb">rewrite</span> app_nth1 <span class="bp">by</span> (<span class="nb">rewrite</span> reprn_length; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth i (reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))) d = 
Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk32"><span class="nb">destruct</span> (Nat.lt_ge_cases i (n - <span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(i &lt; n - <span class="mi">1</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth i (reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))) d = 
Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(n - <span class="mi">1</span> &lt;= i)%nat</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk33"><hr></label><div class="goal-conclusion">nth i (reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))) d = 
Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk34">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(i &lt; n - <span class="mi">1</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth i (reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))) d = 
Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk35"><span class="nb">rewrite</span> IHn, !Z.shiftr_div_pow2, &lt;- (Nat.sub_add i n), Nat2Z.inj_add,
          Z.mul_add_distr_l, Z.pow_add_r, Z.mul_comm, Zaux.Zdiv_mod_mult <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(i &lt; n - <span class="mi">1</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr
  (((a / <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i))
    mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (n - i))) mod <span class="mi">2</span> ^ <span class="mi">62</span>) = 
Int64.repr ((a / <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk36"><span class="nb">rewrite</span> !Z.pow_mul_r, &lt;- Zmod_div_mod; <span class="kp">try</span> <span class="bp">reflexivity</span>; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(i &lt; n - <span class="mi">1</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ <span class="mi">62</span> | (<span class="mi">2</span> ^ <span class="mi">62</span>) ^ Z.of_nat (n - i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk37"><span class="nb">apply</span> Zpow_facts.Zpower_divide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(i &lt; n - <span class="mi">1</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt; Z.of_nat (n - i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk38">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(n - <span class="mi">1</span> &lt;= i)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth i (reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))) d = 
Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk39"><span class="nb">set</span> (l := (reprn n _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(n - <span class="mi">1</span> &lt;= i)%nat</span></span></span><br><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))</span></span><span class="hyp-type"><b>: </b><span>list int64</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth i l d = Int64.repr
              (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk3a"><span class="nb">replace</span> i <span class="kr">with</span> (n - <span class="mi">1</span>)%nat <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(n - <span class="mi">1</span> &lt;= i)%nat</span></span></span><br><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))</span></span><span class="hyp-type"><b>: </b><span>list int64</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (n - <span class="mi">1</span>) l d = Int64.repr
                    (Z.shiftr a
                       (<span class="mi">62</span> * Z.of_nat (n - <span class="mi">1</span>))
                     mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk3b"><span class="nb">replace</span> n <span class="kr">with</span> (length l) <span class="nb">at</span> <span class="mi">1</span> <span class="bp">by</span> <span class="nb">apply</span> reprn_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(n - <span class="mi">1</span> &lt;= i)%nat</span></span></span><br><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))</span></span><span class="hyp-type"><b>: </b><span>list int64</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Datatypes.length l - <span class="mi">1</span>) l d = Int64.repr
                                     (Z.shiftr a
                                        (<span class="mi">62</span>
                                           * Z.of_nat
                                               (n - <span class="mi">1</span>))
                                      mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk3c"><span class="nb">unfold</span> l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(n - <span class="mi">1</span> &lt;= i)%nat</span></span></span><br><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))</span></span><span class="hyp-type"><b>: </b><span>list int64</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth
  (Datatypes.length
     (reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n)))
     - <span class="mi">1</span>) (reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))) d = 
Int64.repr
  (Z.shiftr a (<span class="mi">62</span> * Z.of_nat (n - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk3d"><span class="nb">rewrite</span> nth_last, reprn_last <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(n - <span class="mi">1</span> &lt;= i)%nat</span></span></span><br><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))</span></span><span class="hyp-type"><b>: </b><span>list int64</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr
  (Z.shiftr (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))
     (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>))) = Int64.repr
                                  (Z.shiftr a
                                     (<span class="mi">62</span>
                                        * Z.of_nat
                                            (n - <span class="mi">1</span>))
                                   mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk3e"><span class="nb">replace</span> (<span class="mi">62</span> * Z.of_nat n) <span class="kr">with</span> (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>) + <span class="mi">62</span>) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(n - <span class="mi">1</span> &lt;= i)%nat</span></span></span><br><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))</span></span><span class="hyp-type"><b>: </b><span>list int64</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr
  (Z.shiftr (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>) + <span class="mi">62</span>))
     (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>))) = Int64.repr
                                  (Z.shiftr a
                                     (<span class="mi">62</span>
                                        * Z.of_nat
                                            (n - <span class="mi">1</span>))
                                   mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk3f"><span class="nb">rewrite</span> Z.pow_add_r, !Z.shiftr_div_pow2, Zaux.Zdiv_mod_mult <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(n - <span class="mi">1</span> &lt;= i)%nat</span></span></span><br><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))</span></span><span class="hyp-type"><b>: </b><span>list int64</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr
  ((a / <span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n - <span class="mi">1</span>))) mod <span class="mi">2</span> ^ <span class="mi">62</span>) = 
Int64.repr
  ((a / <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (n - <span class="mi">1</span>))) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk40"><span class="kp">repeat</span> <span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat) (<span class="nv">d</span> : int64),
(<span class="mi">0</span> &lt;= i &lt; n - <span class="mi">1</span>)%nat -&gt;
nth i (reprn n a) d = Int64.repr (Z.shiftr a (<span class="mi">62</span> * Z.of_nat i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; S n - <span class="mi">1</span>)%nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(n - <span class="mi">1</span> &lt;= i)%nat</span></span></span><br><span><var>l</var><span><span class="hyp-body"><b>:= </b><span>reprn n (a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n))</span></span><span class="hyp-type"><b>: </b><span>list int64</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.of_nat n - <span class="mi">1</span> = Z.of_nat (n - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk41"><span class="kn">Lemma</span> <span class="nf">reprn_Znth</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">n</span> <span class="nv">i</span>, <span class="mi">0</span> &lt;= i &lt; Z.of_nat n - <span class="mi">1</span> -&gt;
  Znth i (reprn n a) = Int64.repr ((Z.shiftr a (<span class="mi">62</span> * i)) mod (<span class="mi">2</span>^<span class="mi">62</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Z),
<span class="mi">0</span> &lt;= i &lt; Z.of_nat n - <span class="mi">1</span> -&gt;
Znth i (reprn n a) = Int64.repr
                       (Z.shiftr a (<span class="mi">62</span> * i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk42"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">n</span> : nat) (<span class="nv">i</span> : Z),
<span class="mi">0</span> &lt;= i &lt; Z.of_nat n - <span class="mi">1</span> -&gt;
Znth i (reprn n a) = Int64.repr
                       (Z.shiftr a (<span class="mi">62</span> * i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk43"><span class="nb">intros</span> a n i Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Z.of_nat n - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth i (reprn n a) = Int64.repr
                       (Z.shiftr a (<span class="mi">62</span> * i) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk44"><span class="nb">rewrite</span> &lt;- nth_Znth <span class="bp">by</span> (<span class="nb">rewrite</span> reprn_Zlength; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Z.of_nat n - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i) (reprn n a) Inhabitant_int64 = Int64.repr
                                                 (Z.shiftr
                                                 a
                                                 (<span class="mi">62</span>
                                                 * i)
                                                 mod 
                                                 <span class="mi">2</span>
                                                 ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk45"><span class="nb">rewrite</span> reprn_nth, Z2Nat.id <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Z.of_nat n - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * i) mod <span class="mi">2</span> ^ <span class="mi">62</span>) = Int64.repr
                                                (Z.shiftr
                                                 a
                                                 (<span class="mi">62</span>
                                                 * i)
                                                 mod 
                                                 <span class="mi">2</span>
                                                 ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk46"><span class="kn">Lemma</span> <span class="nf">signed_firstn_reprn</span> <span class="nv">a</span> <span class="nv">i</span> <span class="nv">n</span> : (i &lt; n)%nat -&gt; signed (firstn i (reprn n a)) = a mod (<span class="mi">2</span>^(<span class="mi">62</span>*Z.of_nat i)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i &lt; n)%nat -&gt;
signed (firstn i (reprn n a)) = a
                                mod <span class="mi">2</span>
                                      ^ (<span class="mi">62</span>
                                           * Z.of_nat
                                               i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk47"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(i &lt; n)%nat -&gt;
signed (firstn i (reprn n a)) = a
                                mod <span class="mi">2</span>
                                      ^ (<span class="mi">62</span>
                                           * Z.of_nat
                                               i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk48"><span class="nb">revert</span> a i.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; n)%nat -&gt;
signed (firstn i (reprn n a)) = a
                                mod <span class="mi">2</span>
                                      ^ (<span class="mi">62</span>
                                           * Z.of_nat
                                               i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk49"><span class="nb">induction</span> n;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; n)%nat -&gt; signed (firstn i (reprn n a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; S n)%nat -&gt;
signed (firstn i (reprn (S n) a)) = a
                                    mod <span class="mi">2</span>
                                          ^ (<span class="mi">62</span>
                                               * Z.of_nat
                                                 i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk4a"><span class="nb">intros</span> a [|i];[<span class="nb">simpl</span>; <span class="nb">rewrite</span> Z.pow_0_r, Zmod_1_r; <span class="bp">reflexivity</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; n)%nat -&gt; signed (firstn i (reprn n a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(S i &lt; S n)%nat -&gt;
signed (firstn (S i) (reprn (S n) a)) = a
                                        mod <span class="mi">2</span>
                                              ^ (<span class="mi">62</span>
                                                 * Z.of_nat
                                                 (S i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk4b"><span class="nb">intros</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; n)%nat -&gt; signed (firstn i (reprn n a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(S i &lt; S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed (firstn (S i) (reprn (S n) a)) = a
                                        mod <span class="mi">2</span>
                                              ^ (<span class="mi">62</span>
                                                 * Z.of_nat
                                                 (S i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk4c"><span class="nb">apply</span> Nat.succ_lt_mono <span class="kr">in</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; n)%nat -&gt; signed (firstn i (reprn n a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(i &lt; n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed (firstn (S i) (reprn (S n) a)) = a
                                        mod <span class="mi">2</span>
                                              ^ (<span class="mi">62</span>
                                                 * Z.of_nat
                                                 (S i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk4d"><span class="nb">destruct</span> n;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; S n)%nat -&gt;
signed (firstn i (reprn (S n) a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(i &lt; S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed (firstn (S i) (reprn (S (S n)) a)) = a
                                            mod <span class="mi">2</span>
                                                 ^ 
                                                 (<span class="mi">62</span>
                                                 * Z.of_nat
                                                 (S i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk4e"><span class="nb">rewrite</span> Nat2Z.inj_succ, Z.mul_succ_r, Z.pow_add_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; S n)%nat -&gt;
signed (firstn i (reprn (S n) a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(i &lt; S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">signed (firstn (S i) (reprn (S (S n)) a)) = a
                                            mod (<span class="mi">2</span>
                                                 ^ (<span class="mi">62</span>
                                                 * Z.of_nat
                                                 i)
                                                 * <span class="mi">2</span>
                                                 ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk4f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; S n)%nat -&gt;
signed (firstn i (reprn (S n) a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(i &lt; S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.signed (Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  + <span class="mi">2</span> ^ <span class="mi">62</span>
      * signed
          (firstn i
             <span class="kr">match</span> n <span class="kr">with</span>
             | <span class="mi">0</span>%nat =&gt; [Int64.repr (Z.shiftr a <span class="mi">62</span>)]
             | S _ =&gt;
                 Int64.repr (Z.shiftr a <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>)
                 :: reprn n
                      (Z.shiftr (Z.shiftr a <span class="mi">62</span>) <span class="mi">62</span>)
             <span class="kr">end</span>) = a
                    mod (<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)
                           * <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk50"><span class="nb">change</span> (signed _) <span class="kr">with</span> (signed (firstn i (reprn (S n) (Z.shiftr a <span class="mi">62</span>)))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; S n)%nat -&gt;
signed (firstn i (reprn (S n) a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(i &lt; S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.signed (Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  + <span class="mi">2</span> ^ <span class="mi">62</span>
      * signed
          (firstn i (reprn (S n) (Z.shiftr a <span class="mi">62</span>))) = 
a mod (<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i) * <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk51"><span class="nb">rewrite</span> IHn <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; S n)%nat -&gt;
signed (firstn i (reprn (S n) a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(i &lt; S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.signed (Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  + <span class="mi">2</span> ^ <span class="mi">62</span> * (Z.shiftr a <span class="mi">62</span> mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)) = 
a mod (<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i) * <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk52"><span class="nb">rewrite</span> Int64.signed_repr <span class="bp">by</span> solve_bounds.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; S n)%nat -&gt;
signed (firstn i (reprn (S n) a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(i &lt; S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a mod <span class="mi">2</span> ^ <span class="mi">62</span>
  + <span class="mi">2</span> ^ <span class="mi">62</span> * (Z.shiftr a <span class="mi">62</span> mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)) = 
a mod (<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i) * <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk53"><span class="nb">rewrite</span> Z.shiftr_div_pow2 <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; S n)%nat -&gt;
signed (firstn i (reprn (S n) a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(i &lt; S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a mod <span class="mi">2</span> ^ <span class="mi">62</span>
  + <span class="mi">2</span> ^ <span class="mi">62</span> * ((a / <span class="mi">2</span> ^ <span class="mi">62</span>) mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)) = 
a mod (<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i) * <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk54"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; S n)%nat -&gt;
signed (firstn i (reprn (S n) a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(i &lt; S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a mod (<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i) * <span class="mi">2</span> ^ <span class="mi">62</span>) = a mod <span class="mi">2</span> ^ <span class="mi">62</span>
                                           + <span class="mi">2</span> ^ <span class="mi">62</span>
                                               * ((a
                                                 / <span class="mi">2</span>
                                                 ^ <span class="mi">62</span>)
                                                 mod 
                                                 <span class="mi">2</span>
                                                 ^ (<span class="mi">62</span>
                                                 * Z.of_nat
                                                 i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk55"><span class="nb">rewrite</span> Zmod_recombine <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">a</span> : Z) (<span class="nv">i</span> : nat),
(i &lt; S n)%nat -&gt;
signed (firstn i (reprn (S n) a)) = a mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(i &lt; S n)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a / <span class="mi">2</span> ^ <span class="mi">62</span>) mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i) * <span class="mi">2</span> ^ <span class="mi">62</span>
  + a mod <span class="mi">2</span> ^ <span class="mi">62</span> = a mod <span class="mi">2</span> ^ <span class="mi">62</span>
                     + <span class="mi">2</span> ^ <span class="mi">62</span>
                         * ((a / <span class="mi">2</span> ^ <span class="mi">62</span>)
                            mod <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat i))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk56"><span class="kn">Lemma</span> <span class="nf">signed_reprn</span> <span class="nv">a</span> <span class="nv">n</span> : (<span class="mi">1</span> &lt;= n)%nat -&gt; -<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
 signed (reprn n a) = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> &lt;= n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn n a) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> &lt;= n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn n a) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk58"><span class="nb">revert</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn n a) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk59"><span class="nb">induction</span> n;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn n a) = a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn (S n) a) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk5a"><span class="nb">intros</span> a _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn n a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn (S n) a) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk5b"><span class="nb">rewrite</span> Nat2Z.inj_succ, Z.mul_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn n a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">62</span> + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat n + <span class="mi">62</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn (S n) a) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk5c"><span class="nb">destruct</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= <span class="mi">0</span>)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn <span class="mi">0</span> a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">62</span> + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">62</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn <span class="mi">1</span> a) = a</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk5d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn (S n) a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk5d"><hr></label><div class="goal-conclusion">-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span> + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn (S (S n)) a) = a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk5e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= <span class="mi">0</span>)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn <span class="mi">0</span> a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">62</span> + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">62</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn <span class="mi">1</span> a) = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk5f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= <span class="mi">0</span>)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn <span class="mi">0</span> a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> ^ <span class="mi">63</span> &lt;= a &lt;= <span class="mi">2</span> ^ <span class="mi">63</span> - <span class="mi">1</span> -&gt;
Int64.signed (Int64.repr a) + <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">0</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk60"><span class="nb">intros</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= <span class="mi">0</span>)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat <span class="mi">0</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn <span class="mi">0</span> a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ <span class="mi">63</span> &lt;= a &lt;= <span class="mi">2</span> ^ <span class="mi">63</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.signed (Int64.repr a) + <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">0</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> Int64.signed_repr;[<span class="bp">lia</span>|<span class="bp">assumption</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk61">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn (S n) a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span> + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn (S (S n)) a) = a</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk62"><span class="nb">change</span> (reprn _ a) <span class="kr">with</span> (Int64.repr (a mod (<span class="mi">2</span> ^ <span class="mi">62</span>)) :: (reprn (S n) (Z.shiftr a <span class="mi">62</span>))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn (S n) a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span> + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed
  (Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>)
   :: reprn (S n) (Z.shiftr a <span class="mi">62</span>)) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk63"><span class="nb">cbn</span> [signed].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) &lt;= a &lt;= <span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
signed (reprn (S n) a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span> + <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n) + <span class="mi">62</span> + <span class="mi">1</span>) - <span class="mi">1</span> -&gt;
Int64.signed (Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  + <span class="mi">2</span> ^ <span class="mi">62</span> * signed (reprn (S n) (Z.shiftr a <span class="mi">62</span>)) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk64"><span class="nb">rewrite</span> !Z.pow_add_r <span class="kr">in</span> * <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span> -&gt; signed (reprn (S n) a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span> -&gt;
Int64.signed (Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  + <span class="mi">2</span> ^ <span class="mi">62</span> * signed (reprn (S n) (Z.shiftr a <span class="mi">62</span>)) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk65"><span class="nb">intros</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span> -&gt; signed (reprn (S n) a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;=
a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.signed (Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  + <span class="mi">2</span> ^ <span class="mi">62</span> * signed (reprn (S n) (Z.shiftr a <span class="mi">62</span>)) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk66"><span class="nb">rewrite</span> IHn <span class="bp">by</span> solve_bounds.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span> -&gt; signed (reprn (S n) a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;=
a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.signed (Int64.repr (a mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  + <span class="mi">2</span> ^ <span class="mi">62</span> * Z.shiftr a <span class="mi">62</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk67"><span class="nb">rewrite</span> Int64.signed_repr <span class="bp">by</span> solve_bounds.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span> -&gt; signed (reprn (S n) a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;=
a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a mod <span class="mi">2</span> ^ <span class="mi">62</span> + <span class="mi">2</span> ^ <span class="mi">62</span> * Z.shiftr a <span class="mi">62</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk68"><span class="nb">rewrite</span> Z.shiftr_div_pow2, Z.add_comm <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span> -&gt; signed (reprn (S n) a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;=
a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ <span class="mi">62</span> * (a / <span class="mi">2</span> ^ <span class="mi">62</span>) + a mod <span class="mi">2</span> ^ <span class="mi">62</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk69"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">1</span> &lt;= S n)%nat -&gt;
-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span> -&gt; signed (reprn (S n) a) = a</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-(<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span>) &lt;=
a &lt;=
<span class="mi">2</span> ^ (<span class="mi">62</span> * Z.of_nat (S n)) * <span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ <span class="mi">1</span> - <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a = <span class="mi">2</span> ^ <span class="mi">62</span> * (a / <span class="mi">2</span> ^ <span class="mi">62</span>) + a mod <span class="mi">2</span> ^ <span class="mi">62</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Z_div_mod_eq_full.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk6a"><span class="kn">Lemma</span> <span class="nf">reprn_shrink</span> <span class="nv">a</span> <span class="nv">n1</span> <span class="nv">n2</span> : (min_signed (Z.of_nat n1) &lt;= a &lt;= max_signed (Z.of_nat n1)) -&gt; (<span class="mi">1</span> &lt;= n1 &lt; n2)%nat -&gt; 
     (firstn n1
        (upd_Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a)
           (Int64.or (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
              (Int64.repr (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>))))) =
     (reprn n1 a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1) -&gt;
(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat -&gt;
firstn n1
  (upd_Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a)
     (Int64.or (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
        (Int64.repr
           (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>)))) = 
reprn n1 a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk6b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1) -&gt;
(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat -&gt;
firstn n1
  (upd_Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a)
     (Int64.or (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
        (Int64.repr
           (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>)))) = 
reprn n1 a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk6c"><span class="nb">intros</span> Ha Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">firstn n1
  (upd_Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a)
     (Int64.or (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
        (Int64.repr
           (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>)))) = 
reprn n1 a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk6d"><span class="nb">apply</span> (nth_eq_ext _ default);
  <span class="nb">rewrite</span> firstn_length, &lt;-ZtoNat_Zlength, Zlength_upd_Znth, ZtoNat_Zlength, !reprn_length;
[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : nat,
(<span class="mi">0</span> &lt;= i &lt; Init.Nat.min n1 n2)%nat -&gt;
nth i
  (firstn n1
     (upd_Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a)
        (Int64.or
           (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
           (Int64.repr
              (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>)))))
  default = nth i (reprn n1 a) default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk6e"><span class="nb">replace</span> (Init.Nat.min n1 n2) <span class="kr">with</span> n1 <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : nat,
(<span class="mi">0</span> &lt;= i &lt; n1)%nat -&gt;
nth i
  (firstn n1
     (upd_Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a)
        (Int64.or
           (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
           (Int64.repr
              (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>)))))
  default = nth i (reprn n1 a) default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk6f"><span class="nb">intros</span> i Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth i
  (firstn n1
     (upd_Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a)
        (Int64.or
           (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
           (Int64.repr
              (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>)))))
  default = nth i (reprn n1 a) default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk70"><span class="nb">rewrite</span> nth_firstn <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= i &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth i
  (upd_Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a)
     (Int64.or (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
        (Int64.repr
           (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>))))
  default = nth i (reprn n1 a) default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk71"><span class="nb">destruct</span> (Nat.eq_dec i (n1 - <span class="mi">1</span>)) <span class="kr">as</span> [-&gt;|Hneq];<span class="nb">rewrite</span> nth_Znth&#39;;
[|<span class="nb">rewrite</span> reprn_nth, Znth_upd_Znth_diff, reprn_Znth <span class="bp">by</span> <span class="bp">lia</span>; <span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth (Z.of_nat (n1 - <span class="mi">1</span>))
  (upd_Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a)
     (Int64.or (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
        (Int64.repr
           (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>)))) = 
nth (n1 - <span class="mi">1</span>) (reprn n1 a) default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk72"><span class="nb">replace</span> (Z.of_nat (n1 - <span class="mi">1</span>)) <span class="kr">with</span> (Z.of_nat n1 - <span class="mi">1</span>) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth (Z.of_nat n1 - <span class="mi">1</span>)
  (upd_Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a)
     (Int64.or (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
        (Int64.repr
           (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>)))) = 
nth (n1 - <span class="mi">1</span>) (reprn n1 a) default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk73"><span class="nb">rewrite</span> upd_Znth_same <span class="bp">by</span> (<span class="nb">rewrite</span> reprn_Zlength; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.or (Znth (Z.of_nat n1 - <span class="mi">1</span>) (reprn n2 a))
  (Int64.repr
     (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>)) = 
nth (n1 - <span class="mi">1</span>) (reprn n1 a) default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk74"><span class="nb">rewrite</span> reprn_Znth <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.or
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr
     (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>)) = 
nth (n1 - <span class="mi">1</span>) (reprn n1 a) default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk75"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (n1 - <span class="mi">1</span>) (reprn n1 a) default = Int64.or
                                      (Int64.repr
                                         (Z.shiftr a
                                            (<span class="mi">62</span>
                                               * (Z.of_nat
                                                 n1
                                                 - <span class="mi">1</span>))
                                          mod <span class="mi">2</span> ^ <span class="mi">62</span>))
                                      (Int64.repr
                                         (Z.shiftl
                                            (<span class="kr">if</span>
                                              <span class="mi">0</span> &lt;=? a
                                             <span class="kr">then</span> <span class="mi">0</span>
                                             <span class="kr">else</span> -<span class="mi">1</span>)
                                            <span class="mi">62</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk76"><span class="nb">replace</span> n1 <span class="kr">with</span> (length (reprn n1 a)) <span class="nb">at</span> <span class="mi">1</span> <span class="bp">by</span> (<span class="nb">rewrite</span> reprn_length;<span class="bp">reflexivity</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Datatypes.length (reprn n1 a) - <span class="mi">1</span>) (reprn n1 a)
  default = Int64.or
              (Int64.repr
                 (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))
                  mod <span class="mi">2</span> ^ <span class="mi">62</span>))
              (Int64.repr
                 (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>)
                    <span class="mi">62</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk77"><span class="nb">rewrite</span> nth_last.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="nb">last</span> (reprn n1 a) default = Int64.or
                              (Int64.repr
                                 (Z.shiftr a
                                    (<span class="mi">62</span>
                                       * (Z.of_nat n1
                                            - <span class="mi">1</span>))
                                  mod <span class="mi">2</span> ^ <span class="mi">62</span>))
                              (Int64.repr
                                 (Z.shiftl
                                    (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a
                                     <span class="kr">then</span> <span class="mi">0</span>
                                     <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk78"><span class="nb">rewrite</span> reprn_last <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>min_signed (Z.of_nat n1) &lt;= a &lt;=
max_signed (Z.of_nat n1)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) = 
Int64.or
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr
     (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk79"><span class="nb">unfold</span> min_signed, max_signed <span class="kr">in</span> Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) = 
Int64.or
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr
     (Z.shiftl (<span class="kr">if</span> <span class="mi">0</span> &lt;=? a <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> -<span class="mi">1</span>) <span class="mi">62</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk7a"><span class="nb">elim</span> Z.leb_spec;<span class="nb">intros</span> Ha0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) = 
Int64.or
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr (Z.shiftl <span class="mi">0</span> <span class="mi">62</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk7b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk7b"><hr></label><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) = 
Int64.or
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr (Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk7c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) = 
Int64.or
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr (Z.shiftl <span class="mi">0</span> <span class="mi">62</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk7d"><span class="nb">rewrite</span> Int64.or_zero.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) = 
Int64.repr
  (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk7e"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr
  (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>) = 
Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk7f"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span> = Z.shiftr
                                                 a
                                                 (<span class="mi">62</span>
                                                 * (Z.of_nat
                                                 n1
                                                 - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk80"><span class="nb">apply</span> Z.mod_small.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) &lt; <span class="mi">2</span> ^ <span class="mi">62</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk81"><span class="nb">apply</span> shiftr_bounds.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) * <span class="mi">0</span> &lt;= a &lt;
<span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) * <span class="mi">2</span> ^ <span class="mi">62</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk82"><span class="nb">rewrite</span> &lt;-Z.pow_add_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) * <span class="mi">0</span> &lt;= a &lt;
<span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>) + <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk83"><span class="nb">replace</span> (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>) + <span class="mi">62</span>) <span class="kr">with</span> (Z.of_nat n1 * <span class="mi">62</span>) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) * <span class="mi">0</span> &lt;= a &lt;
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk84">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) = 
Int64.or
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr (Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk85"><span class="nb">rewrite</span> &lt;- Int64.add_is_or.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) = 
Int64.add
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr (Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk86" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk86"><hr></label><div class="goal-conclusion">Int64.<span class="kn">and</span>
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr (Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>)) = Int64.zero</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk87"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.<span class="kn">and</span>
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr (Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>)) = Int64.zero</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk88"><span class="nb">apply</span> Int64.same_bits_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Z,
<span class="mi">0</span> &lt;= i &lt; Int64.zwordsize -&gt;
Int64.testbit
  (Int64.<span class="kn">and</span>
     (Int64.repr
        (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))
         mod <span class="mi">2</span> ^ <span class="mi">62</span>)) (Int64.repr (Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>)))
  i = Int64.testbit Int64.zero i</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk89"><span class="nb">intros</span> j Hj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hj</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= j &lt; Int64.zwordsize</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.testbit
  (Int64.<span class="kn">and</span>
     (Int64.repr
        (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))
         mod <span class="mi">2</span> ^ <span class="mi">62</span>)) (Int64.repr (Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>)))
  j = Int64.testbit Int64.zero j</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk8a"><span class="nb">rewrite</span> Int64.bits_zero, and64_repr, Int64.testbit_repr <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hj</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= j &lt; Int64.zwordsize</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.testbit
  (Z.land
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>)
     (Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>)) j = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk8b"><span class="nb">rewrite</span> &lt;- Z.land_ones, !Z.land_spec, Z.testbit_ones_nonneg, Z.shiftl_spec <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hj</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= j &lt; Int64.zwordsize</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Z.testbit (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) j &amp;&amp;
 (j &lt;? <span class="mi">62</span>) &amp;&amp; Z.testbit (-<span class="mi">1</span>) (j - <span class="mi">62</span>))%bool = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk8c"><span class="nb">elim</span> Z.ltb_spec;[|<span class="nb">rewrite</span> andb_false_r;<span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br><span><var>j</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hj</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= j &lt; Int64.zwordsize</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">j &lt; <span class="mi">62</span> -&gt;
(Z.testbit (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) j &amp;&amp;
 true &amp;&amp; Z.testbit (-<span class="mi">1</span>) (j - <span class="mi">62</span>))%bool = false</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intro</span>; <span class="nb">rewrite</span> (Z.testbit_neg_r _ (j - <span class="mi">62</span>)), !andb_false_r <span class="bp">by</span> <span class="bp">lia</span>; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk8d">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) = 
Int64.add
  (Int64.repr
     (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>))
  (Int64.repr (Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk8e"><span class="nb">rewrite</span> add64_repr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Int64.repr (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) = 
Int64.repr
  (Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ <span class="mi">62</span>
     + Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk8f"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) = Z.shiftr a
                                        (<span class="mi">62</span>
                                           * (Z.of_nat
                                                n1
                                                - <span class="mi">1</span>))
                                      mod <span class="mi">2</span> ^ <span class="mi">62</span>
                                        + Z.shiftl
                                            (-<span class="mi">1</span>) <span class="mi">62</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk90"><span class="nb">change</span> (Z.shiftl (-<span class="mi">1</span>) <span class="mi">62</span>) <span class="kr">with</span> (-<span class="mi">2</span>^<span class="mi">62</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) = Z.shiftr a
                                        (<span class="mi">62</span>
                                           * (Z.of_nat
                                                n1
                                                - <span class="mi">1</span>))
                                      mod <span class="mi">2</span> ^ <span class="mi">62</span>
                                        + -<span class="mi">2</span> ^ <span class="mi">62</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk91"><span class="nb">rewrite</span> &lt;- (Z_mod_plus_full _ <span class="mi">1</span>), Z.mod_small;[<span class="bp">ring</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) + <span class="mi">1</span> * <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk92"><span class="nb">rewrite</span> strict_bounds.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) + <span class="mi">1</span> * <span class="mi">2</span> ^ <span class="mi">62</span> &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span> - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk93"><span class="nb">apply</span> unadd_bounds_small.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> - <span class="mi">1</span> * <span class="mi">2</span> ^ <span class="mi">62</span> &lt;=
Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span> - <span class="mi">1</span> - <span class="mi">1</span> * <span class="mi">2</span> ^ <span class="mi">62</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk94"><span class="nb">setoid_rewrite</span> &lt;- strict_bounds&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> - <span class="mi">1</span> * <span class="mi">2</span> ^ <span class="mi">62</span> &lt;=
Z.shiftr a (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) &lt;
<span class="mi">2</span> ^ <span class="mi">62</span> - <span class="mi">1</span> - <span class="mi">1</span> * <span class="mi">2</span> ^ <span class="mi">62</span> + <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk95"><span class="nb">apply</span> shiftr_bounds.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) * (<span class="mi">0</span> - <span class="mi">1</span> * <span class="mi">2</span> ^ <span class="mi">62</span>) &lt;= a &lt;
<span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))
  * (<span class="mi">2</span> ^ <span class="mi">62</span> - <span class="mi">1</span> - <span class="mi">1</span> * <span class="mi">2</span> ^ <span class="mi">62</span> + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk96"><span class="nb">rewrite</span> Z.mul_0_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) * (<span class="mi">0</span> - <span class="mi">1</span> * <span class="mi">2</span> ^ <span class="mi">62</span>) &lt;= a &lt;
<span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk97"><span class="nb">cut</span> (-(<span class="mi">2</span>^<span class="mi">62</span> * <span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) &lt;= a &lt; <span class="mi">0</span>);[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-(<span class="mi">2</span> ^ <span class="mi">62</span> * <span class="mi">2</span> ^ (<span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>))) &lt;= a &lt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk98" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk98"><span class="nb">rewrite</span> &lt;-Z.pow_add_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) &lt;= a &lt;=
<span class="mi">2</span> ^ (Z.of_nat n1 * <span class="mi">62</span>) - <span class="mi">1</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">1</span> &lt;= n1 &lt; n2)%nat</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;= n1 - <span class="mi">1</span> &lt; n1)%nat</span></span></span><br><span><var>Ha0</var><span class="hyp-type"><b>: </b><span>a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> ^ (<span class="mi">62</span> + <span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) &lt;= a &lt; <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">replace</span> (<span class="mi">62</span> + <span class="mi">62</span> * (Z.of_nat n1 - <span class="mi">1</span>)) <span class="kr">with</span> (Z.of_nat n1 * <span class="mi">62</span>); <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pad</span> (<span class="nv">l</span> : list int64) : list val := map Vlong l ++ <span class="kp">repeat</span> Vundef (<span class="mi">5</span> - length l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk99"><span class="kn">Lemma</span> <span class="nf">pad_nth</span> <span class="nv">i</span> (<span class="nv">l</span> : list int64) : <span class="mi">0</span> &lt;= i &lt; Zlength l -&gt; Znth i (pad l) = Vlong (Znth i l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= i &lt; Zlength l -&gt;
Znth i (pad l) = Vlong (Znth i l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk9a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= i &lt; Zlength l -&gt;
Znth i (pad l) = Vlong (Znth i l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk9b"><span class="nb">intros</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth i (pad l) = Vlong (Znth i l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk9c"><span class="nb">rewrite</span> &lt;- !nth_Znth; <span class="kp">try</span> <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i) (pad l) Inhabitant_val = Vlong
                                            (nth
                                               (Z.to_nat
                                                 i) l
                                               Inhabitant_int64)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk9d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk9d"><hr></label><div class="goal-conclusion"><span class="mi">0</span> &lt;= i &lt; Zlength (pad l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk9e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i) (pad l) Inhabitant_val = Vlong
                                            (nth
                                               (Z.to_nat
                                                 i) l
                                               Inhabitant_int64)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk9f"><span class="nb">assert</span> (Z.to_nat i &lt; length l)%nat <span class="bp">by</span> (<span class="nb">rewrite</span> &lt;- ZtoNat_Zlength, &lt;- Z2Nat.inj_lt; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Z.to_nat i &lt; Datatypes.length l)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i) (pad l) Inhabitant_val = Vlong
                                            (nth
                                               (Z.to_nat
                                                 i) l
                                               Inhabitant_int64)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka0"><span class="nb">unfold</span> pad.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Z.to_nat i &lt; Datatypes.length l)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i)
  (map Vlong l ++
   <span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l))
  Inhabitant_val = Vlong
                     (nth (Z.to_nat i) l
                        Inhabitant_int64)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka1"><span class="nb">rewrite</span> app_nth1 <span class="bp">by</span> (<span class="nb">rewrite</span> map_length; <span class="bp">assumption</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Z.to_nat i &lt; Datatypes.length l)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i) (map Vlong l) Inhabitant_val = Vlong
                                                 (nth
                                                 (Z.to_nat
                                                 i) l
                                                 Inhabitant_int64)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka2"><span class="nb">erewrite</span> nth_indep <span class="bp">by</span> (<span class="nb">rewrite</span> map_length; <span class="bp">assumption</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(Z.to_nat i &lt; Datatypes.length l)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i) (map Vlong l) <span class="nl">?d&#39;</span> = Vlong
                                       (nth
                                          (Z.to_nat i)
                                          l
                                          Inhabitant_int64)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> map_nth.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka3">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= i &lt; Zlength (pad l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka4" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka4"><span class="nb">unfold</span> pad.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= i &lt;
Zlength
  (map Vlong l ++
   <span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka5"><span class="nb">rewrite</span> Zlength_app, Zlength_map.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= i &lt;
Zlength l
  + Zlength (<span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka6"><span class="nb">assert</span> (Hlen := Zlength_nonneg (<span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br><span><var>Hlen</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span>
  &lt;= Zlength
       (<span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= i &lt;
Zlength l
  + Zlength (<span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka7"><span class="kn">Lemma</span> <span class="nf">pad_nth_undef</span> <span class="nv">i</span> (<span class="nv">l</span> : list int64) : Zlength l &lt;= i -&gt; Znth i (pad l) = Vundef.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zlength l &lt;= i -&gt; Znth i (pad l) = Vundef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zlength l &lt;= i -&gt; Znth i (pad l) = Vundef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chka9"><span class="nb">intros</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Zlength l &lt;= i</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth i (pad l) = Vundef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkaa"><span class="nb">pose</span> (Hl := Zlength_nonneg l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Zlength l &lt;= i</span></span></span><br><span><var>Hl</var><span><span class="hyp-body"><b>:= </b><span>Zlength_nonneg l</span></span><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Zlength l</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth i (pad l) = Vundef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkab"><span class="nb">rewrite</span> &lt;- (Z2Nat.id i), &lt;- nth_Znth&#39; <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>Zlength l &lt;= i</span></span></span><br><span><var>Hl</var><span><span class="hyp-body"><b>:= </b><span>Zlength_nonneg l</span></span><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Zlength l</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i) (pad l) default = Vundef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkac"><span class="nb">rewrite</span> Z2Nat.inj_le, ZtoNat_Zlength <span class="kr">in</span> Hi <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(Datatypes.length l &lt;= Z.to_nat i)%nat</span></span></span><br><span><var>Hl</var><span><span class="hyp-body"><b>:= </b><span>Zlength_nonneg l</span></span><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Zlength l</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i) (pad l) default = Vundef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkad"><span class="nb">unfold</span> pad.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(Datatypes.length l &lt;= Z.to_nat i)%nat</span></span></span><br><span><var>Hl</var><span><span class="hyp-body"><b>:= </b><span>Zlength_nonneg l</span></span><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Zlength l</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i)
  (map Vlong l ++
   <span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l)) default = Vundef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkae"><span class="nb">rewrite</span> app_nth2 <span class="bp">by</span> (<span class="nb">rewrite</span> map_length; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span>(Datatypes.length l &lt;= Z.to_nat i)%nat</span></span></span><br><span><var>Hl</var><span><span class="hyp-body"><b>:= </b><span>Zlength_nonneg l</span></span><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= Zlength l</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth (Z.to_nat i - Datatypes.length (map Vlong l))
  (<span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l)) default = Vundef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> nth_repeat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkaf"><span class="kn">Lemma</span> <span class="nf">pad_length</span> <span class="nv">l</span> : (length l &lt;= <span class="mi">5</span>)%nat -&gt; length (pad l) = <span class="mi">5</span>%nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Datatypes.length l &lt;= <span class="mi">5</span>)%nat -&gt;
Datatypes.length (pad l) = <span class="mi">5</span>%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Datatypes.length l &lt;= <span class="mi">5</span>)%nat -&gt;
Datatypes.length (pad l) = <span class="mi">5</span>%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb1"><span class="nb">intros</span> Hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Datatypes.length l &lt;= <span class="mi">5</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Datatypes.length (pad l) = <span class="mi">5</span>%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb2"><span class="nb">unfold</span> pad.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Datatypes.length l &lt;= <span class="mi">5</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Datatypes.length
  (map Vlong l ++
   <span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l)) = <span class="mi">5</span>%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb3"><span class="nb">rewrite</span> app_length, map_length, repeat_length.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Datatypes.length l &lt;= <span class="mi">5</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Datatypes.length l + (<span class="mi">5</span> - Datatypes.length l))%nat = <span class="mi">5</span>%nat</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb4"><span class="kn">Lemma</span> <span class="nf">pad_Zlength</span> <span class="nv">l</span> : Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb6"><span class="nb">intros</span> Hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zlength (pad l) = <span class="mi">5</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> Zlength_correct, pad_length <span class="kr">in</span> *; <span class="kp">try</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb7"><span class="kn">Lemma</span> <span class="nf">pad0</span> : pad nil = <span class="kp">repeat</span> Vundef <span class="mi">5</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">pad [] = <span class="kp">repeat</span> Vundef <span class="mi">5</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb8"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">pad [] = <span class="kp">repeat</span> Vundef <span class="mi">5</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkb9"><span class="kn">Lemma</span> <span class="nf">pad5</span> <span class="nv">l</span> : length l = <span class="mi">5</span>%nat -&gt; pad l = map Vlong l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Datatypes.length l = <span class="mi">5</span>%nat -&gt; pad l = map Vlong l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkba"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Datatypes.length l = <span class="mi">5</span>%nat -&gt; pad l = map Vlong l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkbb"><span class="nb">unfold</span> pad.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Datatypes.length l = <span class="mi">5</span>%nat -&gt;
map Vlong l ++ <span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l) = 
map Vlong l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkbc"><span class="nb">intros</span> -&gt;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map Vlong l ++ <span class="kp">repeat</span> Vundef (<span class="mi">5</span> - <span class="mi">5</span>) = map Vlong l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkbd"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map Vlong l ++ [] = map Vlong l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkbe"><span class="nb">rewrite</span> app_nil_end.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">map Vlong l ++ [] = map Vlong l ++ []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkbf"><span class="kn">Lemma</span> <span class="nf">pad_upd_Znth</span> <span class="nv">a</span> <span class="nv">i</span> <span class="nv">l</span> : <span class="mi">0</span> &lt;= i &lt; Zlength l -&gt; upd_Znth i (pad l) (Vlong a) = pad (upd_Znth i l a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= i &lt; Zlength l -&gt;
upd_Znth i (pad l) (Vlong a) = pad (upd_Znth i l a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkc0"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= i &lt; Zlength l -&gt;
upd_Znth i (pad l) (Vlong a) = pad (upd_Znth i l a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkc1"><span class="nb">intros</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upd_Znth i (pad l) (Vlong a) = pad (upd_Znth i l a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkc2"><span class="nb">unfold</span> pad.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upd_Znth i
  (map Vlong l ++
   <span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l)) (Vlong a) = 
map Vlong (upd_Znth i l a) ++
<span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length (upd_Znth i l a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkc3"><span class="nb">rewrite</span> upd_Znth_app1 <span class="bp">by</span> (<span class="nb">rewrite</span> Zlength_map; <span class="bp">assumption</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upd_Znth i (map Vlong l) (Vlong a) ++
<span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l) = map Vlong
                                           (upd_Znth i
                                              l a) ++
                                         <span class="kp">repeat</span> Vundef
                                           (<span class="mi">5</span>
                                              - Datatypes.length
                                                 (upd_Znth
                                                 i l a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkc4"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upd_Znth i (map Vlong l) (Vlong a) = map Vlong
                                       (upd_Znth i l a)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chkc5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chkc5"><hr></label><div class="goal-conclusion"><span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l) = <span class="kp">repeat</span> Vundef
                                           (<span class="mi">5</span>
                                              - Datatypes.length
                                                 (upd_Znth
                                                 i l a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkc6">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upd_Znth i (map Vlong l) (Vlong a) = map Vlong
                                       (upd_Znth i l a)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> upd_Znth_map.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkc7">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l) = <span class="kp">repeat</span> Vundef
                                           (<span class="mi">5</span>
                                              - Datatypes.length
                                                 (upd_Znth
                                                 i l a))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkc8"><span class="nb">rewrite</span> &lt;- (ZtoNat_Zlength (upd_Znth _ _ _)), Zlength_upd_Znth, ZtoNat_Zlength.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kp">repeat</span> Vundef (<span class="mi">5</span> - Datatypes.length l) = <span class="kp">repeat</span> Vundef
                                           (<span class="mi">5</span>
                                              - Datatypes.length
                                                 l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkc9"><span class="kn">Lemma</span> <span class="nf">pad_upd_Znth_end</span> <span class="nv">a</span> <span class="nv">l</span> : (length l &lt;= <span class="mi">4</span>)%nat -&gt; upd_Znth (Zlength l) (pad l) (Vlong a) = pad (l++[a]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Datatypes.length l &lt;= <span class="mi">4</span>)%nat -&gt;
upd_Znth (Zlength l) (pad l) (Vlong a) = pad
                                           (l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkca"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(Datatypes.length l &lt;= <span class="mi">4</span>)%nat -&gt;
upd_Znth (Zlength l) (pad l) (Vlong a) = pad
                                           (l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkcb"><span class="nb">intros</span> Hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Datatypes.length l &lt;= <span class="mi">4</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upd_Znth (Zlength l) (pad l) (Vlong a) = pad
                                           (l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkcc"><span class="nb">rewrite</span> &lt;- ZtoNat_Zlength <span class="kr">in</span> Hl.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upd_Znth (Zlength l) (pad l) (Vlong a) = pad
                                           (l ++ [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* assert (Hl&#39; : Zlength l &lt;= 4) by lia. *)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkcd"><span class="nb">apply</span> (nth_ext _ _ default default).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Datatypes.length
  (upd_Znth (Zlength l) (pad l) (Vlong a)) = Datatypes.length
                                               (pad
                                                 (l ++
                                                 [a]))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chkce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chkce"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat -&gt;
nth n (upd_Znth (Zlength l) (pad l) (Vlong a)) default = 
nth n (pad (l ++ [a])) default</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkcf">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Datatypes.length
  (upd_Znth (Zlength l) (pad l) (Vlong a)) = Datatypes.length
                                               (pad
                                                 (l ++
                                                 [a]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkd0"><span class="nb">apply</span> Nat2Z.inj.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.of_nat
  (Datatypes.length
     (upd_Znth (Zlength l) (pad l) (Vlong a))) = Z.of_nat
                                                 (Datatypes.length
                                                 (pad
                                                 (l ++
                                                 [a])))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkd1"><span class="nb">rewrite</span> &lt;- !Zlength_correct, Zlength_upd_Znth, !pad_Zlength; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zlength (l ++ [a]) &lt;= <span class="mi">5</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> Zlength_app, Zlength_cons; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">  
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkd2">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat -&gt;
nth n (upd_Znth (Zlength l) (pad l) (Vlong a)) default = 
nth n (pad (l ++ [a])) default</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkd3"><span class="nb">intros</span> n Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">nth n (upd_Znth (Zlength l) (pad l) (Vlong a)) default = 
nth n (pad (l ++ [a])) default</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkd4"><span class="nb">rewrite</span> !nth_Znth&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth (Z.of_nat n)
  (upd_Znth (Zlength l) (pad l) (Vlong a)) = Znth
                                               (Z.of_nat
                                                 n)
                                               (pad
                                                 (l ++
                                                 [a]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkd5"><span class="nb">pose</span> (Hpad := pad_Zlength l).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth (Z.of_nat n)
  (upd_Znth (Zlength l) (pad l) (Vlong a)) = Znth
                                               (Z.of_nat
                                                 n)
                                               (pad
                                                 (l ++
                                                 [a]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkd6"><span class="nb">destruct</span> (Z.lt_total (Z.of_nat n) (Zlength l)) <span class="kr">as</span> [Hnl|[Hnl|Hnl]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth (Z.of_nat n)
  (upd_Znth (Zlength l) (pad l) (Vlong a)) = Znth
                                               (Z.of_nat
                                                 n)
                                               (pad
                                                 (l ++
                                                 [a]))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chkd7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Z.of_nat n = Zlength l</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chkd7"><hr></label><div class="goal-conclusion">Znth (Z.of_nat n)
  (upd_Znth (Zlength l) (pad l) (Vlong a)) = 
Znth (Z.of_nat n) (pad (l ++ [a]))</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chkd8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Zlength l &lt; Z.of_nat n</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chkd8"><hr></label><div class="goal-conclusion">Znth (Z.of_nat n)
  (upd_Znth (Zlength l) (pad l) (Vlong a)) = 
Znth (Z.of_nat n) (pad (l ++ [a]))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkd9">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth (Z.of_nat n)
  (upd_Znth (Zlength l) (pad l) (Vlong a)) = Znth
                                               (Z.of_nat
                                                 n)
                                               (pad
                                                 (l ++
                                                 [a]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkda"><span class="nb">rewrite</span> Znth_upd_Znth_diff, pad_nth <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vlong (Znth (Z.of_nat n) l) = Znth (Z.of_nat n)
                                (pad (l ++ [a]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkdb"><span class="nb">rewrite</span> pad_nth <span class="bp">by</span> (<span class="nb">rewrite</span> Zlength_app, Zlength_cons; <span class="nb">simpl</span>; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vlong (Znth (Z.of_nat n) l) = Vlong
                                (Znth (Z.of_nat n)
                                   (l ++ [a]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkdc"><span class="nb">rewrite</span> Znth_app1 <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt; Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vlong (Znth (Z.of_nat n) l) = Vlong
                                (Znth (Z.of_nat n) l)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkdd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Z.of_nat n = Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth (Z.of_nat n)
  (upd_Znth (Zlength l) (pad l) (Vlong a)) = Znth
                                               (Z.of_nat
                                                 n)
                                               (pad
                                                 (l ++
                                                 [a]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkde" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkde"><span class="nb">rewrite</span> Znth_upd_Znth_same <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Z.of_nat n = Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vlong a = Znth (Z.of_nat n) (pad (l ++ [a]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkdf"><span class="nb">unfold</span> pad.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Z.of_nat n = Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vlong a = Znth (Z.of_nat n)
            (map Vlong (l ++ [a]) ++
             <span class="kp">repeat</span> Vundef
               (<span class="mi">5</span> - Datatypes.length (l ++ [a])))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke0" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke0"><span class="nb">rewrite</span> map_app, Znth_app1, Znth_app2, Zlength_map, Hnl, Z.sub_diag <span class="bp">by</span>
      (<span class="nb">rewrite</span> <span class="nl">?Zlength_app</span>, !Zlength_map, <span class="nl">?Zlength_cons</span>; <span class="nb">simpl</span>; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Z.of_nat n = Zlength l</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vlong a = Znth <span class="mi">0</span> (map Vlong [a])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke1">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Zlength l &lt; Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Znth (Z.of_nat n)
  (upd_Znth (Zlength l) (pad l) (Vlong a)) = Znth
                                               (Z.of_nat
                                                 n)
                                               (pad
                                                 (l ++
                                                 [a]))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke2" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke2"><span class="nb">rewrite</span> Znth_upd_Znth_diff, pad_nth_undef <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Zlength l &lt; Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vundef = Znth (Z.of_nat n) (pad (l ++ [a]))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke3"><span class="nb">rewrite</span> pad_nth_undef <span class="bp">by</span> (<span class="nb">rewrite</span> Zlength_app, Zlength_cons; <span class="nb">simpl</span>; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>int64</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list int64</span></span></span><br><span><var>Hl</var><span class="hyp-type"><b>: </b><span>(Z.to_nat (Zlength l) &lt;= <span class="mi">4</span>)%nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>(n
   &lt; Datatypes.length
       (upd_Znth (Zlength l) (pad l) (Vlong a)))%nat</span></span></span><br><span><var>Hpad</var><span><span class="hyp-body"><b>:= </b><span>pad_Zlength l</span></span><span class="hyp-type"><b>: </b><span>Zlength l &lt;= <span class="mi">5</span> -&gt; Zlength (pad l) = <span class="mi">5</span></span></span></span></span><br><span><var>Hnl</var><span class="hyp-type"><b>: </b><span>Zlength l &lt; Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Vundef = Vundef</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Signed62</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">make_modinfo</span> (<span class="nv">m</span> : Z) : (list val * val)%type :=
  (map Vlong (Signed62.reprn <span class="mi">5</span> m), Vlong (Int64.repr (modInv m (<span class="mi">2</span>^<span class="mi">62</span>)))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">debruijn64_array</span> (<span class="nv">sh</span>: share) (<span class="nv">gv</span>: globals) : mpred :=
  <span class="kn">Eval</span> <span class="nb">cbn</span> <span class="kr">in</span>
  <span class="kr">let</span>
    <span class="nv">is_all_init_int8</span> := <span class="kr">fix</span> is_all_init_int8 (l : list init_data) :=
      <span class="kr">match</span> l <span class="kr">with</span>
      | [] =&gt; <span class="kt">True</span>
      | Init_int8 _ :: l&#39; =&gt; is_all_init_int8 l&#39;
      | _ =&gt; <span class="kt">False</span>
      <span class="kr">end</span>
  <span class="kr">in</span> <span class="kr">let</span>
    <span class="nv">uninit_int8s</span> := <span class="kr">fix</span> uninit_int8s (l: list init_data) :
        is_all_init_int8 l -&gt; list int :=
      <span class="kr">match</span> l <span class="kr">with</span>
      | [] =&gt; <span class="kr">fun</span> <span class="nv">_</span> =&gt; []
      | x :: l&#39; =&gt;
        <span class="kr">match</span> x <span class="kr">with</span>
        | Init_int8 i =&gt; <span class="kr">fun</span> <span class="nv">pf</span> =&gt; i :: uninit_int8s l&#39; pf
        | _ =&gt; False_rec (list int)
        <span class="kr">end</span>
      <span class="kr">end</span>
  <span class="kr">in</span> data_at sh (gvar_info v_debruijn)
    (map Vint (uninit_int8s (gvar_init v_debruijn) I)) (gv _debruijn).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke4"><span class="kn">Lemma</span> <span class="nf">data_at_tulong_tlong</span> {<span class="nv">cs</span>: compspecs}: <span class="kr">forall</span> <span class="nv">sh</span> <span class="nv">v</span> <span class="nv">p</span>, data_at sh tulong v p = data_at sh tlong v p.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">sh</span> : Share.t) (<span class="nv">v</span> : reptype tulong) (<span class="nv">p</span> : val),
data_at sh tulong v p = data_at sh tlong v p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke5" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">sh</span> : Share.t) (<span class="nv">v</span> : reptype tulong) (<span class="nv">p</span> : val),
data_at sh tulong v p = data_at sh tlong v p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke6"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">data_at sh tulong v p = data_at sh tlong v p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke7"><span class="nb">unfold</span> data_at, field_at.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">!! field_compatible tulong [] p &amp;&amp;
at_offset
  (data_at_rec sh (nested_field_type tulong []) v)
  (nested_field_offset tulong []) p = !! field_compatible
                                           tlong [] p &amp;&amp;
                                      at_offset
                                        (data_at_rec
                                           sh
                                           (nested_field_type
                                              tlong [])
                                           v)
                                        (nested_field_offset
                                           tlong []) p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke8"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">!! field_compatible tulong [] p = !! field_compatible
                                       tlong [] p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chke9"><span class="nb">unfold</span> field_compatible.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">!! (isptr p /\
    complete_legal_cosu_type tulong = true /\
    size_compatible tulong p /\
    align_compatible tulong p /\
    legal_nested_field tulong []) = !! (isptr p /\
                                        complete_legal_cosu_type
                                          tlong = true /\
                                        size_compatible
                                          tlong p /\
                                        align_compatible
                                          tlong p /\
                                        legal_nested_field
                                          tlong [])</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkea"><span class="nb">apply</span> ND_prop_ext.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">isptr p /\
complete_legal_cosu_type tulong = true /\
size_compatible tulong p /\
align_compatible tulong p /\
legal_nested_field tulong [] &lt;-&gt;
isptr p /\
complete_legal_cosu_type tlong = true /\
size_compatible tlong p /\
align_compatible tlong p /\
legal_nested_field tlong []</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkeb"><span class="nb">assert</span> (align_compatible tulong p &lt;-&gt; align_compatible tlong p); [| <span class="bp">tauto</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>p</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible tulong p &lt;-&gt; align_compatible tlong p</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkec"><span class="nb">destruct</span> p; <span class="nb">simpl</span>; <span class="kp">try</span> <span class="bp">tauto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>block</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ptrofs</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec cenv_cs tulong
  (Ptrofs.unsigned i) &lt;-&gt;
align_compatible_rec cenv_cs tlong (Ptrofs.unsigned i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chked"><span class="nb">split</span>; <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>block</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ptrofs</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>align_compatible_rec cenv_cs tulong
  (Ptrofs.unsigned i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec cenv_cs tlong (Ptrofs.unsigned i)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chkee" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>block</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ptrofs</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>align_compatible_rec cenv_cs tlong
  (Ptrofs.unsigned i)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chkee"><hr></label><div class="goal-conclusion">align_compatible_rec cenv_cs tulong
  (Ptrofs.unsigned i)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkef">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>block</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ptrofs</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>align_compatible_rec cenv_cs tulong
  (Ptrofs.unsigned i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec cenv_cs tlong (Ptrofs.unsigned i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf0"><span class="nb">eapply</span> align_compatible_rec_by_value_inv <span class="kr">in</span> H; [| <span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>block</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ptrofs</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(align_chunk Mint64 | Ptrofs.unsigned i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec cenv_cs tlong (Ptrofs.unsigned i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf1"><span class="nb">eapply</span> align_compatible_rec_by_value; [<span class="bp">reflexivity</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>block</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ptrofs</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(align_chunk Mint64 | Ptrofs.unsigned i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(align_chunk Mint64 | Ptrofs.unsigned i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf2">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>block</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ptrofs</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>align_compatible_rec cenv_cs tlong
  (Ptrofs.unsigned i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec cenv_cs tulong
  (Ptrofs.unsigned i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf3" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf3"><span class="nb">eapply</span> align_compatible_rec_by_value_inv <span class="kr">in</span> H; [| <span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>block</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ptrofs</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(align_chunk Mint64 | Ptrofs.unsigned i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec cenv_cs tulong
  (Ptrofs.unsigned i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf4"><span class="nb">eapply</span> align_compatible_rec_by_value; [<span class="bp">reflexivity</span> |].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>cs</var><span class="hyp-type"><b>: </b><span>compspecs</span></span></span><br><span><var>sh</var><span class="hyp-type"><b>: </b><span>Share.t</span></span></span><br><span><var>v</var><span class="hyp-type"><b>: </b><span>reptype tulong</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>block</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>ptrofs</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(align_chunk Mint64 | Ptrofs.unsigned i)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(align_chunk Mint64 | Ptrofs.unsigned i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf5"><span class="kn">Lemma</span> <span class="nf">SECP256K1_SIGNED62_ONE_global</span> <span class="nv">gv</span> : headptr (gv _SECP256K1_SIGNED62_ONE) -&gt;
   globvar2pred gv (_SECP256K1_SIGNED62_ONE, v_SECP256K1_SIGNED62_ONE) |--
   data_at Ers t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> <span class="mi">1</span>)) (gv _SECP256K1_SIGNED62_ONE).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">headptr (gv _SECP256K1_SIGNED62_ONE) -&gt;
globvar2pred gv
  (_SECP256K1_SIGNED62_ONE, v_SECP256K1_SIGNED62_ONE)
|-- data_at Ers t_secp256k1_modinv64_signed62
      (map Vlong (Signed62.reprn <span class="mi">5</span> <span class="mi">1</span>))
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf6"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">headptr (gv _SECP256K1_SIGNED62_ONE) -&gt;
globvar2pred gv
  (_SECP256K1_SIGNED62_ONE, v_SECP256K1_SIGNED62_ONE)
|-- data_at Ers t_secp256k1_modinv64_signed62
      (map Vlong (Signed62.reprn <span class="mi">5</span> <span class="mi">1</span>))
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf7"><span class="nb">intros</span> Hheadptr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">globvar2pred gv
  (_SECP256K1_SIGNED62_ONE, v_SECP256K1_SIGNED62_ONE)
|-- data_at Ers t_secp256k1_modinv64_signed62
      (map Vlong (Signed62.reprn <span class="mi">5</span> <span class="mi">1</span>))
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf8"><span class="nb">unfold</span> globvar2pred.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span>
  gvar_volatile
    (snd
       (_SECP256K1_SIGNED62_ONE,
        v_SECP256K1_SIGNED62_ONE))
 <span class="kr">then</span> TT
 <span class="kr">else</span>
  init_data_list2pred gv
    (gvar_init
       (snd
          (_SECP256K1_SIGNED62_ONE,
           v_SECP256K1_SIGNED62_ONE)))
    (readonly2share
       (gvar_readonly
          (snd
             (_SECP256K1_SIGNED62_ONE,
              v_SECP256K1_SIGNED62_ONE))))
    (gv
       (fst
          (_SECP256K1_SIGNED62_ONE,
           v_SECP256K1_SIGNED62_ONE))))
|-- data_at Ers t_secp256k1_modinv64_signed62
      (map Vlong (Signed62.reprn <span class="mi">5</span> <span class="mi">1</span>))
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkf9"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * (mapsto_zeros <span class="mi">32</span> Ers
       (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
       * emp)
|-- data_at Ers t_secp256k1_modinv64_signed62
      [Vlong (Int64.repr (<span class="mi">1</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong
         (Int64.repr
            (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong
         (Int64.repr
            (Z.shiftr (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span>) <span class="mi">62</span>
             mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong
         (Int64.repr
            (Z.shiftr
               (Z.shiftr 
                  (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span>) <span class="mi">62</span>) <span class="mi">62</span>))]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkfa" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkfa"><span class="nb">rewrite</span> sepcon_emp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers t_secp256k1_modinv64_signed62
      [Vlong (Int64.repr (<span class="mi">1</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong
         (Int64.repr
            (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong
         (Int64.repr
            (Z.shiftr (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span>) <span class="mi">62</span>
             mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong
         (Int64.repr
            (Z.shiftr
               (Z.shiftr 
                  (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span>) <span class="mi">62</span>) <span class="mi">62</span>))]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkfb"><span class="nb">change</span> (Z.shiftr <span class="mi">1</span> _) <span class="kr">with</span> <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers t_secp256k1_modinv64_signed62
      [Vlong (Int64.repr (<span class="mi">1</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (<span class="mi">0</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr <span class="mi">0</span> <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong
         (Int64.repr
            (Z.shiftr (Z.shiftr <span class="mi">0</span> <span class="mi">62</span>) <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong
         (Int64.repr
            (Z.shiftr (Z.shiftr (Z.shiftr <span class="mi">0</span> <span class="mi">62</span>) <span class="mi">62</span>) <span class="mi">62</span>))]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkfc"><span class="kp">repeat</span> <span class="nb">change</span> (Z.shiftr <span class="mi">0</span> _) <span class="kr">with</span> <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers t_secp256k1_modinv64_signed62
      [Vlong (Int64.repr (<span class="mi">1</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (<span class="mi">0</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (<span class="mi">0</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (<span class="mi">0</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkfd"><span class="nb">change</span> (<span class="mi">1</span> mod _) <span class="kr">with</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers t_secp256k1_modinv64_signed62
      [Vlong (Int64.repr <span class="mi">1</span>);
       Vlong (Int64.repr (<span class="mi">0</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (<span class="mi">0</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (<span class="mi">0</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkfe"><span class="nb">change</span> (<span class="mi">0</span> mod _) <span class="kr">with</span> <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers t_secp256k1_modinv64_signed62
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chkff"><span class="nb">unfold</span> t_secp256k1_modinv64_signed62.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers
      (Tstruct _secp256k1_modinv64_signed62 noattr)
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk100"><span class="nb">assert</span> (Hptr : isptr (gv _SECP256K1_SIGNED62_ONE)) <span class="bp">by</span> (<span class="nb">apply</span> headptr_isptr; <span class="bp">assumption</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers
      (Tstruct _secp256k1_modinv64_signed62 noattr)
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk101"><span class="nb">unfold</span> data_at.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- field_at Ers
      (Tstruct _secp256k1_modinv64_signed62 noattr) []
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk102"><span class="nb">erewrite</span> field_at_Tstruct;
[|<span class="bp">reflexivity</span>|<span class="nb">apply</span> JMeq_refl].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- nested_sfieldlist_at Ers
      (Tstruct _secp256k1_modinv64_signed62 noattr) []
      (co_members
         (get_co _secp256k1_modinv64_signed62))
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk103"><span class="nb">simpl</span> (co_members (get_co _secp256k1_modinv64_signed62)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- nested_sfieldlist_at Ers
      (Tstruct _secp256k1_modinv64_signed62 noattr) []
      [Member_plain _v (tarray tlong <span class="mi">5</span>)]
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk104"><span class="nb">cbn</span> -[mapsto].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- withspacer Ers <span class="mi">40</span>
      (<span class="mi">0</span>
         + <span class="kr">match</span>
             Maps.PTree.get
               _secp256k1_modinv64_signed62
               (Maps.PTree.Nodes
                  (Maps.PTree.Node101
                     (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001 ...)
                      (Maps.PTree.Node100 ...))))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101 ... ...)
                      (Maps.PTree.Node001 ...)))))))
                     (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001 ...)))))))))
           <span class="kr">with</span>
           | Some co =&gt; co_sizeof co
           | None =&gt; <span class="mi">0</span>
           <span class="kr">end</span>)
      (field_at Ers
         (Tstruct _secp256k1_modinv64_signed62 noattr)
         (DOT _v)
         [Vlong (Int64.repr <span class="mi">1</span>); 
          Vlong (Int64.repr <span class="mi">0</span>); 
          Vlong (Int64.repr <span class="mi">0</span>); 
          Vlong (Int64.repr <span class="mi">0</span>); 
          Vlong (Int64.repr <span class="mi">0</span>)])
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk105"><span class="nb">change</span> (<span class="mi">0</span> + _) <span class="kr">with</span> <span class="mi">40</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- withspacer Ers <span class="mi">40</span> <span class="mi">40</span>
      (field_at Ers
         (Tstruct _secp256k1_modinv64_signed62 noattr)
         (DOT _v)
         [Vlong (Int64.repr <span class="mi">1</span>); 
          Vlong (Int64.repr <span class="mi">0</span>); 
          Vlong (Int64.repr <span class="mi">0</span>); 
          Vlong (Int64.repr <span class="mi">0</span>); 
          Vlong (Int64.repr <span class="mi">0</span>)])
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk106"><span class="nb">unfold</span> withspacer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- (<span class="kr">if</span> Z.eq_dec (<span class="mi">40</span> - <span class="mi">40</span>) <span class="mi">0</span>
     <span class="kr">then</span>
      field_at Ers
        (Tstruct _secp256k1_modinv64_signed62 noattr)
        (DOT _v)
        [Vlong (Int64.repr <span class="mi">1</span>); 
         Vlong (Int64.repr <span class="mi">0</span>); 
         Vlong (Int64.repr <span class="mi">0</span>); 
         Vlong (Int64.repr <span class="mi">0</span>); 
         Vlong (Int64.repr <span class="mi">0</span>)]
        (gv _SECP256K1_SIGNED62_ONE)
     <span class="kr">else</span>
      field_at Ers
        (Tstruct _secp256k1_modinv64_signed62 noattr)
        (DOT _v)
        [Vlong (Int64.repr <span class="mi">1</span>); 
         Vlong (Int64.repr <span class="mi">0</span>); 
         Vlong (Int64.repr <span class="mi">0</span>); 
         Vlong (Int64.repr <span class="mi">0</span>); 
         Vlong (Int64.repr <span class="mi">0</span>)]
        (gv _SECP256K1_SIGNED62_ONE)
        * spacer Ers <span class="mi">40</span> <span class="mi">40</span>
            (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk107" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk107"><span class="nb">destruct</span> (Z.eq_dec _ _);[<span class="nb">clear</span> e|<span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- field_at Ers
      (Tstruct _secp256k1_modinv64_signed62 noattr)
      (DOT _v)
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk108"><span class="nb">rewrite</span> field_at_data_at.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers
      (nested_field_type
         (Tstruct _secp256k1_modinv64_signed62 noattr)
         (DOT _v))
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (field_address
         (Tstruct _secp256k1_modinv64_signed62 noattr)
         (DOT _v) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk109"><span class="nb">assert</span> (Hcompat : field_compatible
          (Tstruct _secp256k1_modinv64_signed62 noattr)
          (DOT _v) (gv _SECP256K1_SIGNED62_ONE)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">field_compatible
  (Tstruct _secp256k1_modinv64_signed62 noattr)
  (DOT _v) (gv _SECP256K1_SIGNED62_ONE)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk10a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk10a"><hr></label><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers
      (nested_field_type
         (Tstruct _secp256k1_modinv64_signed62 noattr)
         (DOT _v))
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (field_address
         (Tstruct _secp256k1_modinv64_signed62 noattr)
         (DOT _v) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk10b"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">field_compatible
  (Tstruct _secp256k1_modinv64_signed62 noattr)
  (DOT _v) (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk10c"><span class="nb">apply</span> headptr_field_compatible.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">headptr (gv _SECP256K1_SIGNED62_ONE)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk10d" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk10d"><hr></label><div class="goal-conclusion">complete_legal_cosu_type
  (Tstruct _secp256k1_modinv64_signed62 noattr) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk10e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk10e"><hr></label><div class="goal-conclusion">legal_nested_field
  (Tstruct _secp256k1_modinv64_signed62 noattr)
  (DOT _v)</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk10f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk10f"><hr></label><div class="goal-conclusion">sizeof (Tstruct _secp256k1_modinv64_signed62 noattr)
  &lt; Ptrofs.modulus</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk110" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk110"><hr></label><div class="goal-conclusion">align_compatible_rec cenv_cs
  (Tstruct _secp256k1_modinv64_signed62 noattr) <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk111">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">headptr (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk112">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">complete_legal_cosu_type
  (Tstruct _secp256k1_modinv64_signed62 noattr) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk113">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legal_nested_field
  (Tstruct _secp256k1_modinv64_signed62 noattr)
  (DOT _v)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk114">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sizeof (Tstruct _secp256k1_modinv64_signed62 noattr)
  &lt; Ptrofs.modulus</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk115">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec cenv_cs
  (Tstruct _secp256k1_modinv64_signed62 noattr) <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk116"><span class="nb">eapply</span> align_compatible_rec_Tstruct.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Maps.PTree.get _secp256k1_modinv64_signed62 cenv_cs = 
Some <span class="nl">?co</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk117" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk117"><hr></label><div class="goal-conclusion">plain_members (co_members <span class="nl">?co</span>) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk118" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk118"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i0</span> : ident) (<span class="nv">t0</span> : type) (<span class="nv">z0</span> : Z),
Ctypes.field_type i0 (co_members <span class="nl">?co</span>) = 
Errors.OK t0 -&gt;
Ctypes.field_offset cenv_cs i0 (co_members <span class="nl">?co</span>) = 
Errors.OK (z0, Full) -&gt;
align_compatible_rec cenv_cs t0 (<span class="mi">0</span> + z0)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk119">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Maps.PTree.get _secp256k1_modinv64_signed62 cenv_cs = 
Some <span class="nl">?co</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk11a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">plain_members
  (co_members
     {|
       co_su := Struct;
       co_members :=
         [Member_plain _v (tarray tlong <span class="mi">5</span>)];
       co_attr := noattr;
       co_sizeof := <span class="mi">40</span>;
       co_alignof := <span class="mi">8</span>;
       co_rank := <span class="mi">1</span>;
       co_sizeof_pos := Zgeb0_ge0 <span class="mi">40</span> eq_refl;
       co_alignof_two_p :=
         prove_alignof_two_p <span class="mi">8</span> eq_refl;
       co_sizeof_alignof := prove_Zdivide <span class="mi">8</span> <span class="mi">40</span> eq_refl
     |}) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk11b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">i0</span> : ident) (<span class="nv">t0</span> : type) (<span class="nv">z0</span> : Z),
Ctypes.field_type i0
  (co_members
     {|
       co_su := Struct;
       co_members :=
         [Member_plain _v (tarray tlong <span class="mi">5</span>)];
       co_attr := noattr;
       co_sizeof := <span class="mi">40</span>;
       co_alignof := <span class="mi">8</span>;
       co_rank := <span class="mi">1</span>;
       co_sizeof_pos := Zgeb0_ge0 <span class="mi">40</span> eq_refl;
       co_alignof_two_p :=
         prove_alignof_two_p <span class="mi">8</span> eq_refl;
       co_sizeof_alignof := prove_Zdivide <span class="mi">8</span> <span class="mi">40</span> eq_refl
     |}) = Errors.OK t0 -&gt;
Ctypes.field_offset cenv_cs i0
  (co_members
     {|
       co_su := Struct;
       co_members :=
         [Member_plain _v (tarray tlong <span class="mi">5</span>)];
       co_attr := noattr;
       co_sizeof := <span class="mi">40</span>;
       co_alignof := <span class="mi">8</span>;
       co_rank := <span class="mi">1</span>;
       co_sizeof_pos := Zgeb0_ge0 <span class="mi">40</span> eq_refl;
       co_alignof_two_p :=
         prove_alignof_two_p <span class="mi">8</span> eq_refl;
       co_sizeof_alignof := prove_Zdivide <span class="mi">8</span> <span class="mi">40</span> eq_refl
     |}) = Errors.OK (z0, Full) -&gt;
align_compatible_rec cenv_cs t0 (<span class="mi">0</span> + z0)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk11c"><span class="nb">simpl</span>; <span class="nb">intros</span> i0 t0 z0 H0 H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>(<span class="kr">if</span> ident_eq i0 _v
 <span class="kr">then</span> Errors.OK (tarray tlong <span class="mi">5</span>)
 <span class="kr">else</span>
  Errors.Error
    [Errors.MSG <span class="s2">&quot;Unknown field &quot;</span>; Errors.CTX i0]) = 
Errors.OK t0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Ctypes.field_offset
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  i0 [Member_plain _v (tarray tlong <span class="mi">5</span>)] = 
Errors.OK (z0, Full)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  t0 (<span class="mi">0</span> + z0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk11d"><span class="nb">destruct</span> (ident_eq _ _) <span class="kr">in</span> H0;[|<span class="bp">discriminate</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>i0 = _v</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Errors.OK (tarray tlong <span class="mi">5</span>) = Errors.OK t0</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Ctypes.field_offset
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  i0 [Member_plain _v (tarray tlong <span class="mi">5</span>)] = 
Errors.OK (z0, Full)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  t0 (<span class="mi">0</span> + z0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk11e"><span class="nb">injection</span> H0; <span class="nb">clear</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>t0</var><span class="hyp-type"><b>: </b><span>type</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>i0 = _v</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Ctypes.field_offset
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  i0 [Member_plain _v (tarray tlong <span class="mi">5</span>)] = 
Errors.OK (z0, Full)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">tarray tlong <span class="mi">5</span> = t0 -&gt;
align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 (...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 (...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 (...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 (...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 (...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001 (...)))))))))))))
  t0 (<span class="mi">0</span> + z0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk11f"><span class="nb">intros</span> &lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>i0</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span></span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>e</var><span class="hyp-type"><b>: </b><span>i0 = _v</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Ctypes.field_offset
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  i0 [Member_plain _v (tarray tlong <span class="mi">5</span>)] = 
Errors.OK (z0, Full)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  (tarray tlong <span class="mi">5</span>) (<span class="mi">0</span> + z0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk120"><span class="nb">subst</span> i0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Ctypes.field_offset
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  _v [Member_plain _v (tarray tlong <span class="mi">5</span>)] = 
Errors.OK (z0, Full)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  (tarray tlong <span class="mi">5</span>) (<span class="mi">0</span> + z0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk121"><span class="nb">injection</span> H1; <span class="nb">clear</span> H1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> = z0 -&gt;
align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 (...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 (...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 (...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 (...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 (...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001 (...)))))))))))))
  (tarray tlong <span class="mi">5</span>) (<span class="mi">0</span> + z0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk122"><span class="nb">intros</span> &lt;-.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  (tarray tlong <span class="mi">5</span>) (<span class="mi">0</span> + <span class="mi">0</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk123"><span class="nb">eapply</span> align_compatible_rec_Tarray.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Z,
<span class="mi">0</span> &lt;= i &lt; <span class="mi">5</span> -&gt;
align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...)))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001 ...))))))))))))
  tlong (<span class="mi">0</span> + <span class="mi">0</span> + Ctypes.sizeof tlong * i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk124" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk124">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Z,
<span class="mi">0</span> &lt;= i &lt; <span class="mi">5</span> -&gt;
align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...)))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001 ...))))))))))))
  tlong (<span class="mi">0</span> + <span class="mi">0</span> + Ctypes.sizeof tlong * i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk125" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk125"><span class="nb">intros</span> i Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; <span class="mi">5</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 ...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 ...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 ...)))))))))))))
  tlong (<span class="mi">0</span> + <span class="mi">0</span> + Ctypes.sizeof tlong * i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk126"><span class="nb">cut</span> (i = <span class="mi">0</span> \/ i = <span class="mi">1</span> \/ i = <span class="mi">2</span> \/ i = <span class="mi">3</span> \/ i = <span class="mi">4</span>);[|<span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; <span class="mi">5</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i = <span class="mi">0</span> \/ i = <span class="mi">1</span> \/ i = <span class="mi">2</span> \/ i = <span class="mi">3</span> \/ i = <span class="mi">4</span> -&gt;
align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 (...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 (...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 (...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 (...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 (...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001 (...)))))))))))))
  tlong (<span class="mi">0</span> + <span class="mi">0</span> + Ctypes.sizeof tlong * i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk127"><span class="nb">clear</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i = <span class="mi">0</span> \/ i = <span class="mi">1</span> \/ i = <span class="mi">2</span> \/ i = <span class="mi">3</span> \/ i = <span class="mi">4</span> -&gt;
align_compatible_rec
  (Maps.PTree.Nodes
     (Maps.PTree.Node101
        (Maps.PTree.Node101
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node100
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 (...)))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001 (...))))))))))
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node001
                    (Maps.PTree.Node001
                      (Maps.PTree.Node101
                      (Maps.PTree.Node101
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100 (...))))
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 (...)))))
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100
                      (Maps.PTree.Node100 (...)))))))))))
        (Maps.PTree.Node001
           (Maps.PTree.Node001
              (Maps.PTree.Node001
                 (Maps.PTree.Node100
                    (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001
                      (Maps.PTree.Node100
                      (Maps.PTree.Node001
                      (Maps.PTree.Node001 (...)))))))))))))
  tlong (<span class="mi">0</span> + <span class="mi">0</span> + Ctypes.sizeof tlong * i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [-&gt;|[-&gt;|[-&gt;|[-&gt;| -&gt;]]]];<span class="nb">econstructor</span>;<span class="kp">try</span> <span class="bp">reflexivity</span>;<span class="nb">apply</span> Zmod_divide;<span class="kp">try</span> <span class="bp">reflexivity</span>;<span class="nb">cbn</span>;<span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk128">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers
      (nested_field_type
         (Tstruct _secp256k1_modinv64_signed62 noattr)
         (DOT _v))
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (field_address
         (Tstruct _secp256k1_modinv64_signed62 noattr)
         (DOT _v) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk129"><span class="nb">rewrite</span> field_address_offset <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers
      (nested_field_type
         (Tstruct _secp256k1_modinv64_signed62 noattr)
         (DOT _v))
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (offset_val
         (nested_field_offset
            (Tstruct _secp256k1_modinv64_signed62
               noattr) 
            (DOT _v)) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk12a"><span class="nb">rewrite</span> isptr_offset_val_zero <span class="bp">by</span> (<span class="nb">apply</span> headptr_isptr; <span class="bp">assumption</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers
      (nested_field_type
         (Tstruct _secp256k1_modinv64_signed62 noattr)
         (DOT _v))
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk12b"><span class="nb">simpl</span> (nested_field_type _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (tarray tlong <span class="mi">5</span>)
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk12c"><span class="nb">unfold</span> tarray.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong <span class="mi">5</span> noattr)
      [Vlong (Int64.repr <span class="mi">1</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk12d"><span class="nb">rewrite</span> (split2_data_at_Tarray _ tlong _ <span class="mi">1</span> _
   [Vlong (Int64.repr <span class="mi">1</span>); Vlong (Int64.repr <span class="mi">0</span>);
       Vlong (Int64.repr <span class="mi">0</span>); Vlong (Int64.repr <span class="mi">0</span>);
       Vlong (Int64.repr <span class="mi">0</span>)]
   [Vlong (Int64.repr <span class="mi">1</span>)] [Vlong (Int64.repr <span class="mi">0</span>);
       Vlong (Int64.repr <span class="mi">0</span>); Vlong (Int64.repr <span class="mi">0</span>);
       Vlong (Int64.repr <span class="mi">0</span>)]); <span class="kp">try</span> <span class="kp">solve</span>[<span class="nb">cbn</span>;<span class="bp">lia</span>]; <span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
  * mapsto_zeros <span class="mi">32</span> Ers
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong <span class="mi">1</span> noattr)
      [Vlong (Int64.repr <span class="mi">1</span>)]
      (gv _SECP256K1_SIGNED62_ONE)
      * data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
          [Vlong (Int64.repr <span class="mi">0</span>); 
           Vlong (Int64.repr <span class="mi">0</span>); 
           Vlong (Int64.repr <span class="mi">0</span>); 
           Vlong (Int64.repr <span class="mi">0</span>)]
          (field_address0 
             (Tarray tlong <span class="mi">5</span> noattr) 
             (SUB <span class="mi">1</span>) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk12e"><span class="nb">apply</span> sepcon_derives.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
|-- data_at Ers (Tarray tlong <span class="mi">1</span> noattr)
      [Vlong (Int64.repr <span class="mi">1</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk12f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk12f"><hr></label><div class="goal-conclusion">mapsto_zeros <span class="mi">32</span> Ers
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (field_address0 (Tarray tlong <span class="mi">5</span> noattr) 
         (SUB <span class="mi">1</span>) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk130">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
|-- data_at Ers (Tarray tlong <span class="mi">1</span> noattr)
      [Vlong (Int64.repr <span class="mi">1</span>)]
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">  </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk131"><span class="nb">eapply</span> derives_trans;[|<span class="nb">apply</span> data_at_singleton_array];[|<span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
|-- data_at Ers tlong (Vlong (Int64.repr <span class="mi">1</span>))
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk132"><span class="nb">rewrite</span> &lt;-data_at_tulong_tlong.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto Ers (Tlong Unsigned noattr)
  (gv _SECP256K1_SIGNED62_ONE) 
  (Vlong (Int64.repr <span class="mi">1</span>))
|-- data_at Ers tulong 
      (Vlong (Int64.repr <span class="mi">1</span>))
      (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">     </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk133"><span class="nb">erewrite</span> mapsto_data_at&#39;; <span class="kp">try</span> <span class="bp">reflexivity</span>; <span class="kp">try</span> <span class="nb">apply</span> JMeq_refl;<span class="kp">try</span> entailer.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">field_compatible (Tlong Unsigned noattr) []
  (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk134"><span class="nb">apply</span> headptr_field_compatible.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">headptr (gv _SECP256K1_SIGNED62_ONE)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk135" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk135"><hr></label><div class="goal-conclusion">complete_legal_cosu_type (Tlong Unsigned noattr) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk136" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk136"><hr></label><div class="goal-conclusion">legal_nested_field (Tlong Unsigned noattr) []</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk137" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk137"><hr></label><div class="goal-conclusion">sizeof (Tlong Unsigned noattr) &lt; Ptrofs.modulus</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk138" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk138"><hr></label><div class="goal-conclusion">align_compatible_rec cenv_cs (Tlong Unsigned noattr) <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk139">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">headptr (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk13a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">complete_legal_cosu_type (Tlong Unsigned noattr) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk13b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legal_nested_field (Tlong Unsigned noattr) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk13c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sizeof (Tlong Unsigned noattr) &lt; Ptrofs.modulus</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk13d">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec cenv_cs (Tlong Unsigned noattr) <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">econstructor</span>;[<span class="bp">reflexivity</span>|<span class="nb">apply</span> Z.divide_0_r].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk13e">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible
  (Tstruct _secp256k1_modinv64_signed62
     noattr) (DOT _v)
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto_zeros <span class="mi">32</span> Ers
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (field_address0 (Tarray tlong <span class="mi">5</span> noattr) 
         (SUB <span class="mi">1</span>) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk13f"><span class="nb">clear</span> Hcompat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto_zeros <span class="mi">32</span> Ers
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (field_address0 (Tarray tlong <span class="mi">5</span> noattr) 
         (SUB <span class="mi">1</span>) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk140"><span class="nb">assert</span> (Hcompat : field_compatible (tarray tlong <span class="mi">5</span>) [] (gv _SECP256K1_SIGNED62_ONE)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk141" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk141"><hr></label><div class="goal-conclusion">mapsto_zeros <span class="mi">32</span> Ers
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (field_address0 (Tarray tlong <span class="mi">5</span> noattr) 
         (SUB <span class="mi">1</span>) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk142"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk143"><span class="nb">apply</span> headptr_field_compatible.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">headptr (gv _SECP256K1_SIGNED62_ONE)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk144" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk144"><hr></label><div class="goal-conclusion">complete_legal_cosu_type (tarray tlong <span class="mi">5</span>) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk145" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk145"><hr></label><div class="goal-conclusion">legal_nested_field (tarray tlong <span class="mi">5</span>) []</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk146" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk146"><hr></label><div class="goal-conclusion">sizeof (tarray tlong <span class="mi">5</span>) &lt; Ptrofs.modulus</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk147" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk147"><hr></label><div class="goal-conclusion">align_compatible_rec cenv_cs (tarray tlong <span class="mi">5</span>) <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk148">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">headptr (gv _SECP256K1_SIGNED62_ONE)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk149">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">complete_legal_cosu_type (tarray tlong <span class="mi">5</span>) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk14a">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">legal_nested_field (tarray tlong <span class="mi">5</span>) []</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">repeat</span> <span class="nb">constructor</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk14b">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sizeof (tarray tlong <span class="mi">5</span>) &lt; Ptrofs.modulus</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk14c">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec cenv_cs (tarray tlong <span class="mi">5</span>) <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk14d"><span class="nb">eapply</span> align_compatible_rec_Tarray.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Z,
<span class="mi">0</span> &lt;= i &lt; <span class="mi">5</span> -&gt;
align_compatible_rec cenv_cs tlong
  (<span class="mi">0</span> + Ctypes.sizeof tlong * i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk14e">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">i</span> : Z,
<span class="mi">0</span> &lt;= i &lt; <span class="mi">5</span> -&gt;
align_compatible_rec cenv_cs tlong
  (<span class="mi">0</span> + Ctypes.sizeof tlong * i)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk14f"><span class="nb">intros</span> i Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; <span class="mi">5</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">align_compatible_rec cenv_cs tlong
  (<span class="mi">0</span> + Ctypes.sizeof tlong * i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk150"><span class="nb">cut</span> (i = <span class="mi">0</span> \/ i = <span class="mi">1</span> \/ i = <span class="mi">2</span> \/ i = <span class="mi">3</span> \/ i = <span class="mi">4</span>);[|<span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hi</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= i &lt; <span class="mi">5</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i = <span class="mi">0</span> \/ i = <span class="mi">1</span> \/ i = <span class="mi">2</span> \/ i = <span class="mi">3</span> \/ i = <span class="mi">4</span> -&gt;
align_compatible_rec cenv_cs tlong
  (<span class="mi">0</span> + Ctypes.sizeof tlong * i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk151"><span class="nb">clear</span> Hi.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>i</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">i = <span class="mi">0</span> \/ i = <span class="mi">1</span> \/ i = <span class="mi">2</span> \/ i = <span class="mi">3</span> \/ i = <span class="mi">4</span> -&gt;
align_compatible_rec cenv_cs tlong
  (<span class="mi">0</span> + Ctypes.sizeof tlong * i)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">        </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">intros</span> [-&gt;|[-&gt;|[-&gt;|[-&gt;| -&gt;]]]];<span class="nb">econstructor</span>;<span class="kp">try</span> <span class="bp">reflexivity</span>;<span class="nb">apply</span> Zmod_divide;<span class="kp">try</span> <span class="bp">reflexivity</span>;<span class="nb">cbn</span>;<span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">       </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk152">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mapsto_zeros <span class="mi">32</span> Ers
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (field_address0 (Tarray tlong <span class="mi">5</span> noattr) 
         (SUB <span class="mi">1</span>) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk153"><span class="nb">eapply</span> derives_trans;[<span class="nb">apply</span> (mapsto_zero_data_at_zero (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr))|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">readable_share Ers</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk154" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk154"><hr></label><div class="goal-conclusion">complete_legal_cosu_type (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk155" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk155"><hr></label><div class="goal-conclusion">fully_nonvolatile
  (rank_type cenv_cs (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr))
  (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr) = true</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk156" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk156"><hr></label><div class="goal-conclusion">field_compatible (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr) []
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))</div></blockquote><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk157" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk157"><hr></label><div class="goal-conclusion">data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
  (zero_val (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr))
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (field_address0 (Tarray tlong <span class="mi">5</span> noattr) 
         (SUB <span class="mi">1</span>) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk158">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">readable_share Ers</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> readable_Ers.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk159">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">complete_legal_cosu_type (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk15a">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fully_nonvolatile
  (rank_type cenv_cs (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr))
  (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr) = true</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk15b">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">field_compatible (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr) []
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> (field_compatible0_nested_field_array (Tarray tlong <span class="mi">5</span> noattr) []); <span class="kp">try</span> <span class="bp">lia</span>; <span class="nb">apply</span> arr_field_compatible0; <span class="kp">try</span> <span class="bp">lia</span>; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk15c">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
  (zero_val (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr))
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (field_address0 (Tarray tlong <span class="mi">5</span> noattr) 
         (SUB <span class="mi">1</span>) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk15d"><span class="nb">rewrite</span> field_address0_offset <span class="bp">by</span>
       (<span class="nb">eapply</span> field_compatible0_cons_Tarray;[<span class="bp">reflexivity</span>|<span class="bp">assumption</span>|<span class="bp">lia</span>]).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
  (zero_val (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr))
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (offset_val
         (nested_field_offset 
            (Tarray tlong <span class="mi">5</span> noattr) 
            (SUB <span class="mi">1</span>)) (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk15e"><span class="nb">change</span> (nested_field_offset (Tarray tlong <span class="mi">5</span> noattr) (SUB <span class="mi">1</span>)) <span class="kr">with</span> <span class="mi">8</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
  (zero_val (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr))
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (Tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>) noattr)
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk15f"><span class="nb">fold</span> (tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">data_at Ers (tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>))
  (zero_val (tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>)))
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>))
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk160"><span class="nb">rewrite</span> zero_val_tarray, zero_val_tlong.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>gv</var><span class="hyp-type"><b>: </b><span><span class="kn">ident</span> -&gt; val</span></span></span><br><span><var>Hheadptr</var><span class="hyp-type"><b>: </b><span>headptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hptr</var><span class="hyp-type"><b>: </b><span>isptr (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br><span><var>Hcompat</var><span class="hyp-type"><b>: </b><span>field_compatible (tarray tlong <span class="mi">5</span>) []
  (gv _SECP256K1_SIGNED62_ONE)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">data_at Ers (tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>))
  (Zrepeat (Vlong Int64.zero) (<span class="mi">5</span> - <span class="mi">1</span>))
  (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))
|-- data_at Ers (tarray tlong (<span class="mi">5</span> - <span class="mi">1</span>))
      [Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>); 
       Vlong (Int64.repr <span class="mi">0</span>)]
      (offset_val <span class="mi">8</span> (gv _SECP256K1_SIGNED62_ONE))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> derives_refl.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">secp256k1_modinv64_signed62_assign_spec</span> : <span class="kn">ident</span> * funspec :=
DECLARE _secp256k1_modinv64_signed62_assign
  WITH x : Z, ptr_dst : val, ptr_src : val, sh_dst : share, sh_src : share
  PRE [ tptr t_secp256k1_modinv64_signed62
      , tptr t_secp256k1_modinv64_signed62
      ]
    PROP( writable_share sh_dst
        ; readable_share sh_src
        )
    PARAMS(ptr_dst; ptr_src)
    SEP( data_at_ sh_dst t_secp256k1_modinv64_signed62 ptr_dst
       ; data_at sh_src t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> x)) ptr_src
       )
  POST [ tvoid ]
    PROP()
    RETURN()
    SEP( data_at sh_dst t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> x)) ptr_dst
       ; data_at sh_src t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> x)) ptr_src
       ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">secp256k1_modinv64_var_spec</span> : <span class="kn">ident</span> * funspec :=
DECLARE _secp256k1_modinv64_var
  WITH x : Z, m : Z, ptrx : val, modinfo : val, shx : share, sh_modinfo : share,
       sh_debruijn : share, sh_SECP256K1_SIGNED62_ONE : share, gv : globals
  PRE [ tptr t_secp256k1_modinv64_signed62
      , tptr t_secp256k1_modinv64_modinfo
      ]
    PROP( Z.Odd m
        ; <span class="mi">0</span> &lt;= x &lt; m
        ; <span class="mi">1</span> &lt; m &lt; <span class="mi">2</span>^<span class="mi">256</span>
        ; x = <span class="mi">0</span> \/ rel_prime x m
        ; writable_share shx
        ; readable_share sh_modinfo
        ; readable_share sh_debruijn
        ; readable_share sh_SECP256K1_SIGNED62_ONE
        )
    PARAMS(ptrx; modinfo)
    GLOBALS(gv)
    SEP(data_at shx t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> x)) ptrx;
        data_at sh_modinfo t_secp256k1_modinv64_modinfo (make_modinfo m) modinfo;
        debruijn64_array sh_debruijn gv;
        data_at sh_SECP256K1_SIGNED62_ONE t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> <span class="mi">1</span>)) (gv _SECP256K1_SIGNED62_ONE))
  POST [ tvoid ]
    PROP()
    RETURN()
    SEP(data_at shx t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> (modInv x m))) ptrx;
        data_at sh_modinfo t_secp256k1_modinv64_modinfo (make_modinfo m) modinfo;
        debruijn64_array sh_debruijn gv;
        data_at sh_SECP256K1_SIGNED62_ONE t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> <span class="mi">1</span>)) (gv _SECP256K1_SIGNED62_ONE)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">secp256k1_modinv64_var_spec_prime</span> : <span class="kn">ident</span> * funspec :=
DECLARE _secp256k1_modinv64_var
  WITH x : Z, m : Z, ptrx : val, modinfo : val, shx : share, sh_modinfo : share,
       sh_debruijn : share, sh_SECP256K1_SIGNED62_ONE : share, gv : globals
  PRE [ tptr t_secp256k1_modinv64_signed62
      , tptr t_secp256k1_modinv64_modinfo
      ]
    PROP( Z.Odd m
        ; <span class="mi">0</span> &lt;= x &lt; m
        ; m &lt; <span class="mi">2</span>^<span class="mi">256</span>
        ; prime m
        ; writable_share shx
        ; readable_share sh_modinfo
        ; readable_share sh_debruijn
        ; readable_share sh_SECP256K1_SIGNED62_ONE
        )
    PARAMS(ptrx; modinfo)
    GLOBALS(gv)
    SEP(data_at shx t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> x)) ptrx;
        data_at sh_modinfo t_secp256k1_modinv64_modinfo (make_modinfo m) modinfo;
        debruijn64_array sh_debruijn gv;
        data_at sh_SECP256K1_SIGNED62_ONE t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> <span class="mi">1</span>)) (gv _SECP256K1_SIGNED62_ONE))
  POST [ tvoid ]
    PROP()
    RETURN()
    SEP(data_at shx t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> (modInv x m))) ptrx;
        data_at sh_modinfo t_secp256k1_modinv64_modinfo (make_modinfo m) modinfo;
        debruijn64_array sh_debruijn gv;
        data_at sh_SECP256K1_SIGNED62_ONE t_secp256k1_modinv64_signed62 (map Vlong (Signed62.reprn <span class="mi">5</span> <span class="mi">1</span>)) (gv _SECP256K1_SIGNED62_ONE)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Use with</span>
<span class="c">   forward_call secp256k1_modinv64_var_spec_prime_sub (x, m, ptrx, modinfo, shx, sh_modinfo, sh_debruijn, sh_SECP256K1_SIGNED62_ONE, gv)</span>
<span class="c">*)</span>
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk161"><span class="kn">Lemma</span> <span class="nf">secp256k1_modinv64_var_spec_prime_sub</span> :
  funspec_sub (snd secp256k1_modinv64_var_spec) (snd secp256k1_modinv64_var_spec_prime).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">funspec_sub (snd secp256k1_modinv64_var_spec)
  (snd secp256k1_modinv64_var_spec_prime)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk162"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">funspec_sub (snd secp256k1_modinv64_var_spec)
  (snd secp256k1_modinv64_var_spec_prime)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk163">do_funspec_sub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>w</var><span class="hyp-type"><b>: </b><span>(Z * Z * val * val * share * share * share * share
   * globals)%type</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">p</span>, gv) := w <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p0</span>, sh_SECP256K1_SIGNED62_ONE) := p <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p1</span>, sh_debruijn) := p0 <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p2</span>, sh_modinfo) := p1 <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p3</span>, shx) := p2 <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p4</span>, modinfo) := p3 <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p5</span>, ptrx) := p4 <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">x</span>, m) := p5 <span class="kr">in</span>
 <span class="kr">fun</span> <span class="nv">x0</span> : argsEnviron =&gt;
 !! (Z.Odd m /\
     <span class="mi">0</span> &lt;= x &lt; m /\
     m &lt; <span class="mi">2</span> ^ <span class="mi">256</span> /\
     prime m /\
     writable_share shx /\
     readable_share sh_modinfo /\
     readable_share sh_debruijn /\
     readable_share sh_SECP256K1_SIGNED62_ONE /\ <span class="kt">True</span>) &amp;&amp;
 (!! (snd x0 = [ptrx; modinfo]) &amp;&amp;
  (!! (gvars_denote gv
         (Clight_seplog.mkEnv (fst x0) [] []) /\ <span class="kt">True</span>) &amp;&amp;
   (data_at shx t_secp256k1_modinv64_signed62
      [Vlong (Int64.repr (x mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr x <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr ... <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr ... <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr (...) <span class="mi">62</span>))] ptrx
      * (data_at sh_modinfo
           t_secp256k1_modinv64_modinfo
           (make_modinfo m) modinfo
           * (debruijn64_array sh_debruijn gv
                * (data_at sh_SECP256K1_SIGNED62_ONE
                     t_secp256k1_modinv64_signed62
                     [...; ...; ...; ...; ...] (...)
                     * emp))))))) (g, args)
|-- EX (x1 : Z * Z * val * val * share * share * share
               * share
               * globals) (F : mpred),
    F
      * (<span class="kr">let</span> (<span class="nv">p</span>, gv) := x1 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p0</span>, sh_SECP256K1_SIGNED62_ONE) := p <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p1</span>, sh_debruijn) := p0 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p2</span>, sh_modinfo) := p1 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p3</span>, shx) := p2 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p4</span>, modinfo) := p3 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p5</span>, ptrx) := p4 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">x</span>, m) := p5 <span class="kr">in</span>
         <span class="kr">fun</span> <span class="nv">x0</span> : argsEnviron =&gt;
         !! (Z.Odd m /\
             <span class="mi">0</span> &lt;= x &lt; m /\
             <span class="mi">1</span> &lt; m &lt; <span class="mi">2</span> ^ <span class="mi">256</span> /\
             (x = <span class="mi">0</span> \/ rel_prime x m) /\
             writable_share shx /\
             readable_share sh_modinfo /\
             readable_share sh_debruijn /\
             readable_share sh_SECP256K1_SIGNED62_ONE /\
             <span class="kt">True</span>) &amp;&amp;
         (!! (snd x0 = [ptrx; modinfo]) &amp;&amp;
          (!! (gvars_denote gv
                 (Clight_seplog.mkEnv (fst x0) [] []) /\
               <span class="kt">True</span>) &amp;&amp;
           (data_at shx t_secp256k1_modinv64_signed62
              [Vlong (Int64.repr ...);
               Vlong (Int64.repr ...);
               Vlong (Int64.repr ...);
               Vlong (Int64.repr ...);
               Vlong (Int64.repr ...)] ptrx
              * (data_at sh_modinfo
                   t_secp256k1_modinv64_modinfo
                   (make_modinfo m) modinfo
                   * (debruijn64_array sh_debruijn gv
                        * (...))))))) (g, args) &amp;&amp;
    !! (<span class="kr">forall</span> <span class="nv">rho&#39;</span> : environ,
        !! (ve_of rho&#39; = Map.empty (block * type)) &amp;&amp;
        (F
           * (<span class="kr">let</span> (<span class="nv">p</span>, gv) := x1 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p0</span>, sh_SECP256K1_SIGNED62_ONE) :=
                p <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p1</span>, sh_debruijn) := p0 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p2</span>, sh_modinfo) := p1 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p3</span>, shx) := p2 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p4</span>, modinfo) := p3 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p5</span>, ptrx) := p4 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">x</span>, m) := p5 <span class="kr">in</span>
              <span class="kr">fun</span> <span class="nv">_</span> : environ =&gt;
              TT &amp;&amp;
              (TT &amp;&amp;
               (data_at shx
                  t_secp256k1_modinv64_signed62
                  [...; ...; ...; ...; ...] ptrx
                  * (... * ...)))) rho&#39;)
        |-- (<span class="kr">let</span> (<span class="nv">p</span>, gv) := w <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p0</span>, sh_SECP256K1_SIGNED62_ONE) :=
               p <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p1</span>, sh_debruijn) := p0 <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p2</span>, sh_modinfo) := p1 <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p3</span>, shx) := p2 <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p4</span>, modinfo) := p3 <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p5</span>, ptrx) := p4 <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">x</span>, m) := p5 <span class="kr">in</span>
             <span class="kr">fun</span> <span class="nv">_</span> : environ =&gt;
             TT &amp;&amp;
             (TT &amp;&amp;
              (data_at shx
                 t_secp256k1_modinv64_signed62
                 [Vlong (Int64.repr ...);
                  Vlong (Int64.repr ...);
                  Vlong (Int64.repr ...);
                  Vlong (Int64.repr ...);
                  Vlong (Int64.repr ...)] ptrx
                 * (data_at sh_modinfo
                      t_secp256k1_modinv64_modinfo
                      (make_modinfo m) modinfo
                      * (debruijn64_array sh_debruijn
                           gv
                           * (...)))))) rho&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk164">Exists w emp.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>w</var><span class="hyp-type"><b>: </b><span>(Z * Z * val * val * share * share * share * share
   * globals)%type</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">p</span>, gv) := w <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p0</span>, sh_SECP256K1_SIGNED62_ONE) := p <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p1</span>, sh_debruijn) := p0 <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p2</span>, sh_modinfo) := p1 <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p3</span>, shx) := p2 <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p4</span>, modinfo) := p3 <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">p5</span>, ptrx) := p4 <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">x</span>, m) := p5 <span class="kr">in</span>
 <span class="kr">fun</span> <span class="nv">x0</span> : argsEnviron =&gt;
 !! (Z.Odd m /\
     <span class="mi">0</span> &lt;= x &lt; m /\
     m &lt; <span class="mi">2</span> ^ <span class="mi">256</span> /\
     prime m /\
     writable_share shx /\
     readable_share sh_modinfo /\
     readable_share sh_debruijn /\
     readable_share sh_SECP256K1_SIGNED62_ONE /\ <span class="kt">True</span>) &amp;&amp;
 (!! (snd x0 = [ptrx; modinfo]) &amp;&amp;
  (!! (gvars_denote gv
         (Clight_seplog.mkEnv (fst x0) [] []) /\ <span class="kt">True</span>) &amp;&amp;
   (data_at shx t_secp256k1_modinv64_signed62
      [Vlong (Int64.repr (x mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr x <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr ... <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr ... <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
       Vlong (Int64.repr (Z.shiftr (...) <span class="mi">62</span>))] ptrx
      * (data_at sh_modinfo
           t_secp256k1_modinv64_modinfo
           (make_modinfo m) modinfo
           * (debruijn64_array sh_debruijn gv
                * (data_at sh_SECP256K1_SIGNED62_ONE
                     t_secp256k1_modinv64_signed62
                     [...; ...; ...; ...; ...] 
                     (...)
                     * emp))))))) (
  g, args)
|-- emp
      * (<span class="kr">let</span> (<span class="nv">p</span>, gv) := w <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p0</span>, sh_SECP256K1_SIGNED62_ONE) := p <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p1</span>, sh_debruijn) := p0 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p2</span>, sh_modinfo) := p1 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p3</span>, shx) := p2 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p4</span>, modinfo) := p3 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">p5</span>, ptrx) := p4 <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">x</span>, m) := p5 <span class="kr">in</span>
         <span class="kr">fun</span> <span class="nv">x0</span> : argsEnviron =&gt;
         !! (Z.Odd m /\
             <span class="mi">0</span> &lt;= x &lt; m /\
             <span class="mi">1</span> &lt; m &lt; <span class="mi">2</span> ^ <span class="mi">256</span> /\
             (x = <span class="mi">0</span> \/ rel_prime x m) /\
             writable_share shx /\
             readable_share sh_modinfo /\
             readable_share sh_debruijn /\
             readable_share sh_SECP256K1_SIGNED62_ONE /\
             <span class="kt">True</span>) &amp;&amp;
         (!! (snd x0 = [ptrx; modinfo]) &amp;&amp;
          (!! (gvars_denote gv
                 (Clight_seplog.mkEnv (fst x0) [] []) /\
               <span class="kt">True</span>) &amp;&amp;
           (data_at shx t_secp256k1_modinv64_signed62
              [Vlong (Int64.repr (...));
               Vlong (Int64.repr (...));
               Vlong (Int64.repr (...));
               Vlong (Int64.repr (...));
               Vlong (Int64.repr (...))] ptrx
              * (data_at sh_modinfo
                   t_secp256k1_modinv64_modinfo
                   (make_modinfo m) modinfo
                   * (debruijn64_array sh_debruijn gv
                        * 
                        (... * emp))))))) (
          g, args) &amp;&amp;
    !! (<span class="kr">forall</span> <span class="nv">rho&#39;</span> : environ,
        !! (ve_of rho&#39; = Map.empty (block * type)) &amp;&amp;
        (emp
           * (<span class="kr">let</span> (<span class="nv">p</span>, gv) := w <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p0</span>, sh_SECP256K1_SIGNED62_ONE) :=
                p <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p1</span>, sh_debruijn) := p0 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p2</span>, sh_modinfo) := p1 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p3</span>, shx) := p2 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p4</span>, modinfo) := p3 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">p5</span>, ptrx) := p4 <span class="kr">in</span>
              <span class="kr">let</span> (<span class="nv">x</span>, m) := p5 <span class="kr">in</span>
              <span class="kr">fun</span> <span class="nv">_</span> : environ =&gt;
              TT &amp;&amp;
              (TT &amp;&amp;
               (data_at shx
                  t_secp256k1_modinv64_signed62
                  [Vlong ...; 
                   Vlong ...; 
                   Vlong ...; 
                   Vlong ...; 
                   Vlong ...] ptrx
                  * (data_at sh_modinfo
                       t_secp256k1_modinv64_modinfo
                       ... modinfo
                       * 
                       (...))))) rho&#39;)
        |-- (<span class="kr">let</span> (<span class="nv">p</span>, gv) := w <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p0</span>, sh_SECP256K1_SIGNED62_ONE) :=
               p <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p1</span>, sh_debruijn) := p0 <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p2</span>, sh_modinfo) := p1 <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p3</span>, shx) := p2 <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p4</span>, modinfo) := p3 <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">p5</span>, ptrx) := p4 <span class="kr">in</span>
             <span class="kr">let</span> (<span class="nv">x</span>, m) := p5 <span class="kr">in</span>
             <span class="kr">fun</span> <span class="nv">_</span> : environ =&gt;
             TT &amp;&amp;
             (TT &amp;&amp;
              (data_at shx
                 t_secp256k1_modinv64_signed62
                 [Vlong (Int64.repr (...));
                  Vlong (Int64.repr (...));
                  Vlong (Int64.repr (...));
                  Vlong (Int64.repr (...));
                  Vlong (Int64.repr (...))] ptrx
                 * (data_at sh_modinfo
                      t_secp256k1_modinv64_modinfo
                      (make_modinfo m) modinfo
                      * (debruijn64_array sh_debruijn
                        gv
                        * (... * emp)))))) rho&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk165"><span class="nb">destruct</span> w <span class="kr">as</span> [[[[[[[[x m] ptrx] modinfo] shx] sh_modinfo] sh_debruinj] sh_SECP256K1_SIGNED62_ONE] gv].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ptrx, modinfo</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>shx, sh_modinfo, sh_debruinj, sh_SECP256K1_SIGNED62_ONE</var><span class="hyp-type"><b>: </b><span>share</span></span></span><br><span><var>gv</var><span class="hyp-type"><b>: </b><span>globals</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">!! (Z.Odd m /\
    <span class="mi">0</span> &lt;= x &lt; m /\
    m &lt; <span class="mi">2</span> ^ <span class="mi">256</span> /\
    prime m /\
    writable_share shx /\
    readable_share sh_modinfo /\
    readable_share sh_debruinj /\
    readable_share sh_SECP256K1_SIGNED62_ONE /\ <span class="kt">True</span>) &amp;&amp;
(!! (snd (g, args) = [ptrx; modinfo]) &amp;&amp;
 (!! (gvars_denote gv
        (Clight_seplog.mkEnv (fst (g, args)) [] []) /\
      <span class="kt">True</span>) &amp;&amp;
  (data_at shx t_secp256k1_modinv64_signed62
     [Vlong (Int64.repr (x mod <span class="mi">2</span> ^ <span class="mi">62</span>));
      Vlong (Int64.repr (Z.shiftr x <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
      Vlong
        (Int64.repr
           (Z.shiftr (Z.shiftr x <span class="mi">62</span>) <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
      Vlong
        (Int64.repr
           (Z.shiftr (Z.shiftr (Z.shiftr x <span class="mi">62</span>) <span class="mi">62</span>) <span class="mi">62</span>
            mod <span class="mi">2</span> ^ <span class="mi">62</span>));
      Vlong
        (Int64.repr
           (Z.shiftr
              (Z.shiftr (Z.shiftr (Z.shiftr x <span class="mi">62</span>) <span class="mi">62</span>)
                 <span class="mi">62</span>) <span class="mi">62</span>))] ptrx
     * (data_at sh_modinfo
          t_secp256k1_modinv64_modinfo
          (make_modinfo m) modinfo
          * (debruijn64_array sh_debruinj gv
               * (data_at sh_SECP256K1_SIGNED62_ONE
                    t_secp256k1_modinv64_signed62
                    [Vlong (Int64.repr (<span class="mi">1</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
                     Vlong
                       (Int64.repr
                        (Z.shiftr <span class="mi">1</span> <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
                     Vlong
                       (Int64.repr
                        (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span>
                        mod 
                        <span class="mi">2</span> ^ <span class="mi">62</span>));
                     Vlong
                       (Int64.repr
                        (Z.shiftr
                        (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span>)
                        <span class="mi">62</span> mod 
                        <span class="mi">2</span> ^ <span class="mi">62</span>));
                     Vlong
                       (Int64.repr
                        (Z.shiftr
                        (Z.shiftr
                        (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span>)
                        <span class="mi">62</span>) <span class="mi">62</span>))]
                    (gv _SECP256K1_SIGNED62_ONE)
                    * emp))))))
|-- emp
      * (!! (Z.Odd m /\
             <span class="mi">0</span> &lt;= x &lt; m /\
             <span class="mi">1</span> &lt; m &lt; <span class="mi">2</span> ^ <span class="mi">256</span> /\
             (x = <span class="mi">0</span> \/ rel_prime x m) /\
             writable_share shx /\
             readable_share sh_modinfo /\
             readable_share sh_debruinj /\
             readable_share sh_SECP256K1_SIGNED62_ONE /\
             <span class="kt">True</span>) &amp;&amp;
         (!! (snd (g, args) = [ptrx; modinfo]) &amp;&amp;
          (!! (gvars_denote gv
                 (Clight_seplog.mkEnv 
                    (fst (g, args)) [] []) /\ <span class="kt">True</span>) &amp;&amp;
           (data_at shx t_secp256k1_modinv64_signed62
              [Vlong (Int64.repr (x mod <span class="mi">2</span> ^ <span class="mi">62</span>));
               Vlong
                 (Int64.repr
                    (Z.shiftr x <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
               Vlong
                 (Int64.repr
                    (Z.shiftr (Z.shiftr x <span class="mi">62</span>) <span class="mi">62</span>
                     mod 
                     <span class="mi">2</span> ^ <span class="mi">62</span>));
               Vlong
                 (Int64.repr
                    (Z.shiftr
                       (Z.shiftr (Z.shiftr x <span class="mi">62</span>) <span class="mi">62</span>)
                       <span class="mi">62</span> mod 
                     <span class="mi">2</span> ^ <span class="mi">62</span>));
               Vlong
                 (Int64.repr
                    (Z.shiftr
                       (Z.shiftr
                        (Z.shiftr (Z.shiftr x <span class="mi">62</span>) <span class="mi">62</span>)
                        <span class="mi">62</span>) <span class="mi">62</span>))] ptrx
              * (data_at sh_modinfo
                   t_secp256k1_modinv64_modinfo
                   (make_modinfo m) modinfo
                   * (debruijn64_array sh_debruinj gv
                        * 
                        (data_at
                        sh_SECP256K1_SIGNED62_ONE
                        t_secp256k1_modinv64_signed62
                        [Vlong
                        (Int64.repr (<span class="mi">1</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
                        Vlong
                        (Int64.repr
                        (Z.shiftr <span class="mi">1</span> <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
                        Vlong
                        (Int64.repr
                        (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span>
                        mod 
                        <span class="mi">2</span> ^ <span class="mi">62</span>));
                        Vlong
                        (Int64.repr
                        (Z.shiftr (Z.shiftr ... <span class="mi">62</span>) <span class="mi">62</span>
                        mod 
                        <span class="mi">2</span> ^ <span class="mi">62</span>));
                        Vlong
                        (Int64.repr
                        (Z.shiftr 
                        (Z.shiftr (...) <span class="mi">62</span>) <span class="mi">62</span>))]
                        (gv _SECP256K1_SIGNED62_ONE)
                        * emp))))))) &amp;&amp;
    !! (<span class="kr">forall</span> <span class="nv">rho&#39;</span> : environ,
        !! (ve_of rho&#39; = Map.empty (block * type)) &amp;&amp;
        (emp
           * (TT &amp;&amp;
              (TT &amp;&amp;
               (data_at shx
                  t_secp256k1_modinv64_signed62
                  [Vlong
                     (Int64.repr
                        (modInv x m mod <span class="mi">2</span> ^ <span class="mi">62</span>));
                   Vlong
                     (Int64.repr
                        (Z.shiftr (modInv x m) <span class="mi">62</span>
                        mod 
                        <span class="mi">2</span> ^ <span class="mi">62</span>));
                   Vlong
                     (Int64.repr
                        (Z.shiftr
                        (Z.shiftr (modInv x m) <span class="mi">62</span>) <span class="mi">62</span>
                        mod 
                        <span class="mi">2</span> ^ <span class="mi">62</span>));
                   Vlong
                     (Int64.repr
                        (Z.shiftr
                        (Z.shiftr 
                        (Z.shiftr (...) <span class="mi">62</span>) <span class="mi">62</span>) <span class="mi">62</span>
                        mod 
                        <span class="mi">2</span> ^ <span class="mi">62</span>));
                   Vlong
                     (Int64.repr
                        (Z.shiftr
                        (Z.shiftr
                        (Z.shiftr (Z.shiftr ... <span class="mi">62</span>) <span class="mi">62</span>)
                        <span class="mi">62</span>) <span class="mi">62</span>))] ptrx
                  * (data_at sh_modinfo
                       t_secp256k1_modinv64_modinfo
                       (make_modinfo m) modinfo
                       * 
                       (debruijn64_array sh_debruinj
                        gv
                        * (data_at
                        sh_SECP256K1_SIGNED62_ONE
                        t_secp256k1_modinv64_signed62
                        [Vlong
                        (Int64.repr (<span class="mi">1</span> mod ...));
                        Vlong
                        (Int64.repr (... mod ...));
                        Vlong
                        (Int64.repr (... mod ...));
                        Vlong
                        (Int64.repr (... mod ...));
                        Vlong
                        (Int64.repr (Z.shiftr ... <span class="mi">62</span>))]
                        (gv _SECP256K1_SIGNED62_ONE)
                        * emp)))))))
        |-- TT &amp;&amp;
            (TT &amp;&amp;
             (data_at shx
                t_secp256k1_modinv64_signed62
                [Vlong
                   (Int64.repr (modInv x m mod <span class="mi">2</span> ^ <span class="mi">62</span>));
                 Vlong
                   (Int64.repr
                      (Z.shiftr (modInv x m) <span class="mi">62</span>
                       mod 
                       <span class="mi">2</span> ^ <span class="mi">62</span>));
                 Vlong
                   (Int64.repr
                      (Z.shiftr
                        (Z.shiftr (modInv x m) <span class="mi">62</span>) <span class="mi">62</span>
                       mod 
                       <span class="mi">2</span> ^ <span class="mi">62</span>));
                 Vlong
                   (Int64.repr
                      (Z.shiftr
                        (Z.shiftr
                        (Z.shiftr (modInv x m) <span class="mi">62</span>) <span class="mi">62</span>)
                        <span class="mi">62</span> mod 
                       <span class="mi">2</span> ^ <span class="mi">62</span>));
                 Vlong
                   (Int64.repr
                      (Z.shiftr
                        (Z.shiftr
                        (Z.shiftr
                        (Z.shiftr (modInv x m) <span class="mi">62</span>) <span class="mi">62</span>)
                        <span class="mi">62</span>) <span class="mi">62</span>))] ptrx
                * (data_at sh_modinfo
                     t_secp256k1_modinv64_modinfo
                     (make_modinfo m) modinfo
                     * (debruijn64_array sh_debruinj
                        gv
                        * (data_at
                        sh_SECP256K1_SIGNED62_ONE
                        t_secp256k1_modinv64_signed62
                        [Vlong
                        (Int64.repr (<span class="mi">1</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
                        Vlong
                        (Int64.repr
                        (Z.shiftr <span class="mi">1</span> <span class="mi">62</span> mod <span class="mi">2</span> ^ <span class="mi">62</span>));
                        Vlong
                        (Int64.repr
                        (Z.shiftr (Z.shiftr <span class="mi">1</span> <span class="mi">62</span>) <span class="mi">62</span>
                        mod 
                        <span class="mi">2</span> ^ <span class="mi">62</span>));
                        Vlong
                        (Int64.repr
                        (Z.shiftr 
                        (Z.shiftr (...) <span class="mi">62</span>) <span class="mi">62</span>
                        mod 
                        <span class="mi">2</span> ^ <span class="mi">62</span>));
                        Vlong
                        (Int64.repr
                        (Z.shiftr
                        (Z.shiftr (Z.shiftr ... <span class="mi">62</span>) <span class="mi">62</span>)
                        <span class="mi">62</span>))]
                        (gv _SECP256K1_SIGNED62_ONE)
                        * emp))))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk166" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk166">entailer!!.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ptrx, modinfo</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>shx, sh_modinfo, sh_debruinj, sh_SECP256K1_SIGNED62_ONE</var><span class="hyp-type"><b>: </b><span>share</span></span></span><br><span><var>gv</var><span class="hyp-type"><b>: </b><span>globals</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z.Odd m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x &lt; m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>writable_share shx</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>readable_share sh_modinfo</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>readable_share sh_debruinj</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>readable_share sh_SECP256K1_SIGNED62_ONE</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>snd (g, args) = [ptrx; modinfo]</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>gvars_denote gv
  (Clight_seplog.mkEnv (fst (g, args)) [] [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> &lt; m &lt; <span class="mi">2</span> ^ <span class="mi">256</span> /\ (x = <span class="mi">0</span> \/ rel_prime x m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk167"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ptrx, modinfo</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>shx, sh_modinfo, sh_debruinj, sh_SECP256K1_SIGNED62_ONE</var><span class="hyp-type"><b>: </b><span>share</span></span></span><br><span><var>gv</var><span class="hyp-type"><b>: </b><span>globals</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z.Odd m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x &lt; m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>writable_share shx</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>readable_share sh_modinfo</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>readable_share sh_debruinj</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>readable_share sh_SECP256K1_SIGNED62_ONE</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>snd (g, args) = [ptrx; modinfo]</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>gvars_denote gv
  (Clight_seplog.mkEnv (fst (g, args)) [] [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> &lt; m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="spec-modinv64-v-chk168" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ptrx, modinfo</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>shx, sh_modinfo, sh_debruinj, sh_SECP256K1_SIGNED62_ONE</var><span class="hyp-type"><b>: </b><span>share</span></span></span><br><span><var>gv</var><span class="hyp-type"><b>: </b><span>globals</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z.Odd m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x &lt; m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>writable_share shx</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>readable_share sh_modinfo</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>readable_share sh_debruinj</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>readable_share sh_SECP256K1_SIGNED62_ONE</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>snd (g, args) = [ptrx; modinfo]</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>gvars_denote gv
  (Clight_seplog.mkEnv (fst (g, args)) [] [])</span></span></span><br></div><label class="goal-separator" for="spec-modinv64-v-chk168"><hr></label><div class="goal-conclusion">x = <span class="mi">0</span> \/ rel_prime x m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk169">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ptrx, modinfo</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>shx, sh_modinfo, sh_debruinj, sh_SECP256K1_SIGNED62_ONE</var><span class="hyp-type"><b>: </b><span>share</span></span></span><br><span><var>gv</var><span class="hyp-type"><b>: </b><span>globals</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z.Odd m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x &lt; m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>writable_share shx</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>readable_share sh_modinfo</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>readable_share sh_debruinj</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>readable_share sh_SECP256K1_SIGNED62_ONE</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>snd (g, args) = [ptrx; modinfo]</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>gvars_denote gv
  (Clight_seplog.mkEnv (fst (g, args)) [] [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> &lt; m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk16a" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk16a"><span class="nb">cut</span> (m &lt;&gt; <span class="mi">1</span>);[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ptrx, modinfo</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>shx, sh_modinfo, sh_debruinj, sh_SECP256K1_SIGNED62_ONE</var><span class="hyp-type"><b>: </b><span>share</span></span></span><br><span><var>gv</var><span class="hyp-type"><b>: </b><span>globals</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z.Odd m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x &lt; m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>writable_share shx</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>readable_share sh_modinfo</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>readable_share sh_debruinj</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>readable_share sh_SECP256K1_SIGNED62_ONE</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>snd (g, args) = [ptrx; modinfo]</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>gvars_denote gv
  (Clight_seplog.mkEnv (fst (g, args)) [] [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt;&gt; <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk16b"><span class="nb">intros</span> Hm; <span class="nb">apply</span> not_prime_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ptrx, modinfo</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>shx, sh_modinfo, sh_debruinj, sh_SECP256K1_SIGNED62_ONE</var><span class="hyp-type"><b>: </b><span>share</span></span></span><br><span><var>gv</var><span class="hyp-type"><b>: </b><span>globals</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z.Odd m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x &lt; m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>writable_share shx</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>readable_share sh_modinfo</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>readable_share sh_debruinj</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>readable_share sh_SECP256K1_SIGNED62_ONE</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>snd (g, args) = [ptrx; modinfo]</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>gvars_denote gv
  (Clight_seplog.mkEnv (fst (g, args)) [] [])</span></span></span><br><span><var>Hm</var><span class="hyp-type"><b>: </b><span>m = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prime <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk16c">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ptrx, modinfo</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>shx, sh_modinfo, sh_debruinj, sh_SECP256K1_SIGNED62_ONE</var><span class="hyp-type"><b>: </b><span>share</span></span></span><br><span><var>gv</var><span class="hyp-type"><b>: </b><span>globals</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z.Odd m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x &lt; m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>writable_share shx</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>readable_share sh_modinfo</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>readable_share sh_debruinj</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>readable_share sh_SECP256K1_SIGNED62_ONE</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>snd (g, args) = [ptrx; modinfo]</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>gvars_denote gv
  (Clight_seplog.mkEnv (fst (g, args)) [] [])</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = <span class="mi">0</span> \/ rel_prime x m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk16d"><span class="nb">destruct</span> (Z.eq_dec x <span class="mi">0</span>) <span class="kr">as</span> [Hx0|Hx0];[<span class="bp">tauto</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ptrx, modinfo</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>shx, sh_modinfo, sh_debruinj, sh_SECP256K1_SIGNED62_ONE</var><span class="hyp-type"><b>: </b><span>share</span></span></span><br><span><var>gv</var><span class="hyp-type"><b>: </b><span>globals</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z.Odd m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x &lt; m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>writable_share shx</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>readable_share sh_modinfo</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>readable_share sh_debruinj</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>readable_share sh_SECP256K1_SIGNED62_ONE</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>snd (g, args) = [ptrx; modinfo]</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>gvars_denote gv
  (Clight_seplog.mkEnv (fst (g, args)) [] [])</span></span></span><br><span><var>Hx0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = <span class="mi">0</span> \/ rel_prime x m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="spec-modinv64-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="spec-modinv64-v-chk16e"><span class="nb">right</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>ptrx, modinfo</var><span class="hyp-type"><b>: </b><span>val</span></span></span><br><span><var>shx, sh_modinfo, sh_debruinj, sh_SECP256K1_SIGNED62_ONE</var><span class="hyp-type"><b>: </b><span>share</span></span></span><br><span><var>gv</var><span class="hyp-type"><b>: </b><span>globals</span></span></span><br><span><var>g</var><span class="hyp-type"><b>: </b><span>genviron</span></span></span><br><span><var>args</var><span class="hyp-type"><b>: </b><span>list val</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>argsHaveTyps (snd (g, args))
  (fst
     ([tptr t_secp256k1_modinv64_signed62;
       tptr t_secp256k1_modinv64_modinfo], tvoid))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>Z.Odd m</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x &lt; m</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>m &lt; <span class="mi">2</span> ^ <span class="mi">256</span></span></span></span><br><span><var>H3</var><span class="hyp-type"><b>: </b><span>prime m</span></span></span><br><span><var>H4</var><span class="hyp-type"><b>: </b><span>writable_share shx</span></span></span><br><span><var>H5</var><span class="hyp-type"><b>: </b><span>readable_share sh_modinfo</span></span></span><br><span><var>H6</var><span class="hyp-type"><b>: </b><span>readable_share sh_debruinj</span></span></span><br><span><var>H7</var><span class="hyp-type"><b>: </b><span>readable_share sh_SECP256K1_SIGNED62_ONE</span></span></span><br><span><var>H8</var><span class="hyp-type"><b>: </b><span>snd (g, args) = [ptrx; modinfo]</span></span></span><br><span><var>H9</var><span class="hyp-type"><b>: </b><span>gvars_denote gv
  (Clight_seplog.mkEnv (fst (g, args)) [] [])</span></span></span><br><span><var>Hx0</var><span class="hyp-type"><b>: </b><span>x &lt;&gt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime x m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> rel_prime_le_prime;[<span class="bp">assumption</span>|<span class="bp">lia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span></pre></article></body></html>