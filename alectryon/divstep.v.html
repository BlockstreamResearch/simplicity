<!DOCTYPE html>
<html class="alectryon-standalone"><head><title>divstep.v</title><meta charset="utf-8"><meta content="Alectryon" name="generator"><meta name="viewport" content="width=device-width, initial-scale=1"><link href="alectryon.css" rel="stylesheet"><link href="pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" /><script src="alectryon.js"></script></head><body><article class="alectryon-root alectryon-windowed"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.17.0+0.17.3. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> ZArith.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> ZArith.Znumtheory.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> ZArith.Zpow_facts.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Lia.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> List.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> divsteps.divsteps_def.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> extraMath.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> modinv.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> list_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Open Scope</span> Z_scope.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Z.add !x !y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Z.sub !m !n.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Arguments</span> Z.mul !x !y.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk0"><span class="kn">Definition</span> <span class="nf">Zodd_irr</span> <span class="nv">z</span> (<span class="nv">Hz1</span> <span class="nv">Hz2</span> : Zodd z) : Hz1 = Hz2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hz1, Hz2</var><span class="hyp-type"><b>: </b><span>Zodd z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Hz1 = Hz2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hz1, Hz2</var><span class="hyp-type"><b>: </b><span>Zodd z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Hz1 = Hz2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2"><span class="nb">revert</span> Hz1 Hz2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>z</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hz1</span> <span class="nv">Hz2</span> : Zodd z, Hz1 = Hz2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> z <span class="kr">as</span> [|p|p]; <span class="kp">try</span> <span class="nb">destruct</span> p; <span class="kp">try</span> <span class="bp">contradiction</span>; <span class="nb">intros</span> [] []; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Step</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Step</span> : <span class="kt">Set</span> :=
| D : Step
| S : Step
| H : Step.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Step</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Step</span> := Step.Step.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">INC</span> : Z := <span class="mi">1</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">State</span> : <span class="kt">Set</span> :=
 { delta : Z
 ; f : Z
 ; g : Z
 ; oddF : Zodd f
 }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eta</span> (<span class="nv">st</span> : State) := Z.opp (delta st).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">init</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">oddF</span> :=
{| delta := <span class="mi">1</span>
 ; f := f
 ; g := g
 ; oddF := oddF
 |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">step</span> (<span class="nv">st</span> : State) : State * Step :=
<span class="kr">match</span> Zeven_odd_dec (g st) <span class="kr">with</span>
| <span class="nb">left</span> _ =&gt; ({| delta := INC + delta st
              ; f := f st
              ; g := g st / <span class="mi">2</span>
              ; oddF := oddF st
              |}
            , Step.H)
| <span class="nb">right</span> oddG =&gt;
    <span class="kr">if</span> (<span class="mi">0</span> &lt;? delta st)%Z
    <span class="kr">then</span> ({| delta := INC - delta st
           ; f := g st
           ; g := (g st - f st) / <span class="mi">2</span>
           ; oddF := oddG
           |}
         , Step.D)
    <span class="kr">else</span> ({| delta := INC + delta st
           ; f := f st
           ; g := (g st + f st) / <span class="mi">2</span>
           ; oddF := oddF st
           |}
         , Step.S)
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="c">(* Last step is first in the list to facilitate matrix multiplication. *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">stepN</span> (<span class="nv">n</span> : nat) : State -&gt; State * list Step  :=
<span class="kr">match</span> n <span class="kr">with</span>
| O =&gt; <span class="kr">fun</span> <span class="nv">st</span> =&gt; (st, nil)
| (S n) =&gt; <span class="kr">fun</span> <span class="nv">st</span> =&gt;
    <span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span>
    (st1, x :: xs)
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Spec</span> : State -&gt; (State * Step) -&gt; <span class="kt">Set</span> :=
| specH : <span class="kr">forall</span> <span class="nv">d</span> <span class="nv">f&#39;</span> <span class="nv">g&#39;</span>, Spec {| delta := d; f := <span class="mi">2</span>*f&#39;+<span class="mi">1</span>; g := <span class="mi">2</span>*g&#39;; oddF := Zodd_2p_plus_1 f&#39; |}
                               ({| delta := INC + d; f := <span class="mi">2</span>*f&#39;+<span class="mi">1</span>; g := g&#39;; oddF := Zodd_2p_plus_1 f&#39; |}, Step.H)
| specD : <span class="kr">forall</span> <span class="nv">d</span> <span class="nv">f&#39;</span> <span class="nv">g&#39;</span>, Spec {| delta := Z.pos d; f := <span class="mi">2</span>*f&#39;+<span class="mi">1</span>; g := <span class="mi">2</span>*g&#39;+<span class="mi">1</span>; oddF := Zodd_2p_plus_1 f&#39; |}
                               ({| delta := INC - Z.pos d; f := <span class="mi">2</span>*g&#39;+<span class="mi">1</span>; g := g&#39; - f&#39;; oddF := Zodd_2p_plus_1 g&#39; |}, Step.D)
| specS : <span class="kr">forall</span> <span class="nv">d</span> <span class="nv">f&#39;</span> <span class="nv">g&#39;</span>, (d &lt;= <span class="mi">0</span>) -&gt;
                          Spec {| delta := d; f := <span class="mi">2</span>*f&#39;+<span class="mi">1</span>; g := <span class="mi">2</span>*g&#39;+<span class="mi">1</span>; oddF := Zodd_2p_plus_1 f&#39; |}
                               ({| delta := INC + d; f := <span class="mi">2</span>*f&#39;+<span class="mi">1</span>; g := g&#39; + f&#39; + <span class="mi">1</span>; oddF := Zodd_2p_plus_1 f&#39; |}, Step.S).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk3"><span class="kn">Lemma</span> <span class="nf">spec</span> <span class="nv">st</span> : Spec st (step st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec st (step st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec st (step st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk5"><span class="nb">destruct</span> st <span class="kr">as</span> [d0 f0 g0 Hf0].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (step
     {| delta := d0; f := f0; g := g0; oddF := Hf0 |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk6"><span class="nb">unfold</span> step; <span class="nb">cbn</span> -[Z.div].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  <span class="kr">match</span> Zeven_odd_dec g0 <span class="kr">with</span>
  | <span class="nb">left</span> _ =&gt;
      ({|
         delta := <span class="mi">1</span> + d0;
         f := f0;
         g := g0 / <span class="mi">2</span>;
         oddF := Hf0
       |}, Step.H)
  | <span class="nb">right</span> oddG =&gt;
      <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
      <span class="kr">then</span>
       ({|
          delta := <span class="mi">1</span> - d0;
          f := g0;
          g := (g0 - f0) / <span class="mi">2</span>;
          oddF := oddG
        |}, Step.D)
      <span class="kr">else</span>
       ({|
          delta := <span class="mi">1</span> + d0;
          f := f0;
          g := (g0 + f0) / <span class="mi">2</span>;
          oddF := Hf0
        |}, Step.S)
  <span class="kr">end</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk7"><span class="nb">destruct</span> (Zeven_odd_dec g0) <span class="kr">as</span> [Hg0|Hg0].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zeven g0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := f0;
     g := g0 / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk8"><hr></label><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk9"><span class="nb">generalize</span> Hf0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zeven g0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd f0,
Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := f0;
     g := g0 / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chka" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><label class="goal-separator" for="divstep-v-chka"><hr></label><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb"><span class="nb">apply</span> Zodd_bool_iff <span class="kr">in</span> Hf0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zeven g0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd f0,
Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := f0;
     g := g0 / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chkc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><label class="goal-separator" for="divstep-v-chkc"><hr></label><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd"><span class="nb">rewrite</span> (Zdiv2_odd_eqn f0), Hf0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zeven g0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := g0;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g := g0 / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chke" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><label class="goal-separator" for="divstep-v-chke"><hr></label><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkf"><span class="nb">rewrite</span> (Zeven_div2 g0) <span class="bp">by</span> <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zeven g0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g := <span class="mi">2</span> * Z.div2 g0 / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk10" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk10"><hr></label><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk11"><span class="nb">replace</span> (<span class="mi">2</span> * Z.div2 g0 / <span class="mi">2</span>) <span class="kr">with</span> (Z.div2 g0) <span class="bp">by</span> (<span class="nb">rewrite</span> Z.mul_comm, Z.div_mul <span class="bp">by</span> <span class="bp">lia</span>; <span class="bp">reflexivity</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zeven g0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g := Z.div2 g0;
     oddF := Hf0
   |}, Step.H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk12" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk12"><hr></label><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk13"><span class="nb">intros</span> Hf0&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zeven g0</span></span></span><br><span><var>Hf0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0;
    oddF := Hf0&#39;
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g := Z.div2 g0;
     oddF := Hf0&#39;
   |}, Step.H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk14" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk14"><hr></label><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk15"><span class="nb">replace</span> Hf0&#39; <span class="kr">with</span> (Zodd_2p_plus_1 (Z.div2 f0)) <span class="bp">by</span> <span class="nb">apply</span> Zodd_irr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zeven g0</span></span></span><br><span><var>Hf0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0;
    oddF := Zodd_2p_plus_1 (Z.div2 f0)
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g := Z.div2 g0;
     oddF := Zodd_2p_plus_1 (Z.div2 f0)
   |}, Step.H)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk16" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk16"><hr></label><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk17"><span class="nb">apply</span> specH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk18"><span class="nb">generalize</span> Hf0 Hg0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hf0</span> : Zodd f0) (<span class="nv">Hg0</span> : Zodd g0),
Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk19"><span class="nb">apply</span> Zodd_bool_iff <span class="kr">in</span> Hf0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Zodd g0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hf0</span> : Zodd f0) (<span class="nv">Hg0</span> : Zodd g0),
Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1a"><span class="nb">apply</span> Zodd_bool_iff <span class="kr">in</span> Hg0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hf0</span> : Zodd f0) (<span class="nv">Hg0</span> : Zodd g0),
Spec {| delta := d0; f := f0; g := g0; oddF := Hf0 |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - f0) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := f0;
       g := (g0 + f0) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b"><span class="nb">rewrite</span> (Zdiv2_odd_eqn f0), Hf0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>))
  (<span class="nv">Hg0</span> : Zodd g0),
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := g0;
    oddF := Hf0
  |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := g0;
       g := (g0 - (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
       g := (g0 + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1c"><span class="nb">rewrite</span> (Zdiv2_odd_eqn g0), Hg0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>))
  (<span class="nv">Hg0</span> : Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>)),
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    ({|
       delta := <span class="mi">1</span> - d0;
       f := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
       g :=
         (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> - (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
       oddF := Hg0
     |}, Step.D)
   <span class="kr">else</span>
    ({|
       delta := <span class="mi">1</span> + d0;
       f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
       g :=
         (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
       oddF := Hf0
     |}, Step.S))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1d"><span class="nb">destruct</span> (<span class="mi">0</span> &lt;? d0) <span class="nb">eqn</span>:Hd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>))
  (<span class="nv">Hg0</span> : Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>)),
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> - d0;
     f := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
     g :=
       (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> - (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
     oddF := Hg0
   |}, Step.D)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk1e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk1e"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>) -&gt;
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g :=
       (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.S)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f"><span class="nb">destruct</span> d0; <span class="kp">try</span> <span class="kp">solve</span> [<span class="nb">cbn</span> <span class="kr">in</span> Hd; <span class="bp">congruence</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? Z.pos p) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>))
  (<span class="nv">Hg0</span> : Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>)),
Spec
  {|
    delta := Z.pos p;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> - Z.pos p;
     f := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
     g :=
       (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> - (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
     oddF := Hg0
   |}, Step.D)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk20" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk20"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>) -&gt;
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g :=
       (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.S)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk21"><span class="nb">replace</span> (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> - (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) <span class="kr">with</span> ((Z.div2 g0 - Z.div2 f0) * <span class="mi">2</span>) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? Z.pos p) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>))
  (<span class="nv">Hg0</span> : Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>)),
Spec
  {|
    delta := Z.pos p;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> - Z.pos p;
     f := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
     g := (Z.div2 g0 - Z.div2 f0) * <span class="mi">2</span> / <span class="mi">2</span>;
     oddF := Hg0
   |}, Step.D)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk22" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk22"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>) -&gt;
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g :=
       (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.S)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk23"><span class="nb">rewrite</span> Z.div_mul <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? Z.pos p) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>))
  (<span class="nv">Hg0</span> : Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>)),
Spec
  {|
    delta := Z.pos p;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> - Z.pos p;
     f := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
     g := Z.div2 g0 - Z.div2 f0;
     oddF := Hg0
   |}, Step.D)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk24" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk24"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>) -&gt;
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g :=
       (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.S)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk25"><span class="nb">intros</span> Hf0&#39; Hg0&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? Z.pos p) = true</span></span></span><br><span><var>Hf0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)</span></span></span><br><span><var>Hg0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec
  {|
    delta := Z.pos p;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0&#39;
  |}
  ({|
     delta := <span class="mi">1</span> - Z.pos p;
     f := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
     g := Z.div2 g0 - Z.div2 f0;
     oddF := Hg0&#39;
   |}, Step.D)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk26" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk26"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>) -&gt;
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g :=
       (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.S)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk27"><span class="nb">replace</span> Hf0&#39; <span class="kr">with</span> (Zodd_2p_plus_1 (Z.div2 f0)) <span class="bp">by</span> <span class="nb">apply</span> Zodd_irr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? Z.pos p) = true</span></span></span><br><span><var>Hf0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)</span></span></span><br><span><var>Hg0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec
  {|
    delta := Z.pos p;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Zodd_2p_plus_1 (Z.div2 f0)
  |}
  ({|
     delta := <span class="mi">1</span> - Z.pos p;
     f := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
     g := Z.div2 g0 - Z.div2 f0;
     oddF := Hg0&#39;
   |}, Step.D)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk28"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>) -&gt;
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g :=
       (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.S)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk29"><span class="nb">replace</span> Hg0&#39; <span class="kr">with</span> (Zodd_2p_plus_1 (Z.div2 g0)) <span class="bp">by</span> <span class="nb">apply</span> Zodd_irr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? Z.pos p) = true</span></span></span><br><span><var>Hf0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)</span></span></span><br><span><var>Hg0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec
  {|
    delta := Z.pos p;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Zodd_2p_plus_1 (Z.div2 f0)
  |}
  ({|
     delta := <span class="mi">1</span> - Z.pos p;
     f := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
     g := Z.div2 g0 - Z.div2 f0;
     oddF := Zodd_2p_plus_1 (Z.div2 g0)
   |}, Step.D)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk2a"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>) -&gt;
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g :=
       (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.S)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2b"><span class="nb">apply</span> specD.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>) -&gt;
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g :=
       (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2c"><span class="nb">replace</span> (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span> + (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)) <span class="kr">with</span> ((Z.div2 g0 + Z.div2 f0 + <span class="mi">1</span>) * <span class="mi">2</span>) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>) -&gt;
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g := (Z.div2 g0 + Z.div2 f0 + <span class="mi">1</span>) * <span class="mi">2</span> / <span class="mi">2</span>;
     oddF := Hf0
   |}, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2d"><span class="nb">rewrite</span> Z.div_mul <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">Hf0</span> : Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>),
Zodd (<span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>) -&gt;
Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g := Z.div2 g0 + Z.div2 f0 + <span class="mi">1</span>;
     oddF := Hf0
   |}, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2e"><span class="nb">intros</span> Hf0&#39; _.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br><span><var>Hf0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Hf0&#39;
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g := Z.div2 g0 + Z.div2 f0 + <span class="mi">1</span>;
     oddF := Hf0&#39;
   |}, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2f"><span class="nb">replace</span> Hf0&#39; <span class="kr">with</span> (Zodd_2p_plus_1 (Z.div2 f0)) <span class="bp">by</span> <span class="nb">apply</span> Zodd_irr.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br><span><var>Hf0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Spec
  {|
    delta := d0;
    f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
    g := <span class="mi">2</span> * Z.div2 g0 + <span class="mi">1</span>;
    oddF := Zodd_2p_plus_1 (Z.div2 f0)
  |}
  ({|
     delta := <span class="mi">1</span> + d0;
     f := <span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>;
     g := Z.div2 g0 + Z.div2 f0 + <span class="mi">1</span>;
     oddF := Zodd_2p_plus_1 (Z.div2 f0)
   |}, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk30"><span class="nb">apply</span> specS.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>d0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf0</var><span class="hyp-type"><b>: </b><span>Z.odd f0 = true</span></span></span><br><span><var>Hg0</var><span class="hyp-type"><b>: </b><span>Z.odd g0 = true</span></span></span><br><span><var>Hd</var><span class="hyp-type"><b>: </b><span>(<span class="mi">0</span> &lt;? d0) = false</span></span></span><br><span><var>Hf0'</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * Z.div2 f0 + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">d0 &lt;= <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk31"><span class="kn">Lemma</span> <span class="nf">etaBounds</span> <span class="nv">b</span> <span class="nv">n</span> <span class="nv">st</span> : -b &lt;= eta st &lt; b -&gt;
  -b - Z.of_nat n &lt;= eta (fst (stepN n st)) &lt; b + Z.of_nat n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- b &lt;= eta st &lt; b -&gt;
- b - Z.of_nat n &lt;= eta (fst (stepN n st)) &lt;
b + Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk32"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- b &lt;= eta st &lt; b -&gt;
- b - Z.of_nat n &lt;= eta (fst (stepN n st)) &lt;
b + Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk33"><span class="nb">induction</span> n; <span class="nb">simpl</span>; [<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>- b &lt;= eta st &lt; b -&gt;
- b - Z.of_nat n &lt;= eta (fst (stepN n st)) &lt; b + Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- b &lt;= eta st &lt; b -&gt;
- b - Z.pos (Pos.of_succ_nat n) &lt;=
eta
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) &lt;
b + Z.pos (Pos.of_succ_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk34"><span class="nb">destruct</span> (stepN n st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>- b &lt;= eta st &lt; b -&gt; - b - Z.of_nat n &lt;= eta (fst (s, l)) &lt; b + Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- b &lt;= eta st &lt; b -&gt;
- b - Z.pos (Pos.of_succ_nat n) &lt;=
eta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) &lt;
b + Z.pos (Pos.of_succ_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk35"><span class="nb">rewrite</span> Zpos_P_of_succ_nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>- b &lt;= eta st &lt; b -&gt; - b - Z.of_nat n &lt;= eta (fst (s, l)) &lt; b + Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- b &lt;= eta st &lt; b -&gt;
- b - Z.succ (Z.of_nat n) &lt;=
eta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) &lt;
b + Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk36"><span class="nb">revert</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- b &lt;= eta st &lt; b -&gt;
 - b - Z.of_nat n &lt;= eta (fst (s, l)) &lt; b + Z.of_nat n) -&gt;
- b &lt;= eta st &lt; b -&gt;
- b - Z.succ (Z.of_nat n) &lt;=
eta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) &lt;
b + Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">elim</span> (spec s); <span class="nb">intros</span> d f&#39; g&#39;; <span class="kp">try</span> <span class="nb">generalize</span> (Z.pos d); <span class="nb">unfold</span> eta; <span class="nb">cbn</span>; <span class="kp">try</span> <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk37"><span class="kn">Lemma</span> <span class="nf">gHs</span> <span class="nv">n</span> <span class="nv">st</span> : (<span class="mi">2</span>^(Z.of_nat n) | g st) -&gt;
  g (fst (stepN n st)) = g st / <span class="mi">2</span>^(Z.of_nat n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
g (fst (stepN n st)) = g st / <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk38"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
g (fst (stepN n st)) = g st / <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk39"><span class="nb">induction</span> n;[<span class="nb">intros</span>;<span class="nb">rewrite</span> Z.div_1_r; <span class="bp">reflexivity</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; g (fst (stepN n st)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n) | g st) -&gt;
g (fst (stepN (S n) st)) = g st / <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk3a"><span class="nb">rewrite</span> Nat2Z.inj_succ, Z.pow_succ_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; g (fst (stepN n st)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
g (fst (stepN (S n) st)) = g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk3b"><span class="nb">simpl</span> (fst _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; g (fst (stepN n st)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
g
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk3c"><span class="nb">destruct</span> (stepN n st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; g (fst (s, l)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk3d"><span class="nb">intros</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; g (fst (s, l)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk3e"><span class="nb">assert</span> (Hdivide : (<span class="mi">2</span> ^ Z.of_nat n | g st)) <span class="bp">by</span> (<span class="nb">etransitivity</span>;[|<span class="nb">apply</span> Hg]; <span class="nb">auto with</span> *).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; g (fst (s, l)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk3f"><span class="nb">apply</span> Zdivide_mod <span class="kr">in</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; g (fst (s, l)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st mod (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) = <span class="mi">0</span></span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk40"><span class="nb">apply</span> (<span class="nb">f_equal</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x / <span class="mi">2</span> ^ (Z.of_nat n))) <span class="kr">in</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; g (fst (s, l)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st mod (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) / <span class="mi">2</span> ^ Z.of_nat n =
<span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk41"><span class="nb">rewrite</span> Z.mul_comm, Z.rem_mul_r, Z.mul_comm, Z_div_plus_full, Z.mod_div, Z.add_0_l <span class="kr">in</span> Hg <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; g (fst (s, l)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(g st / <span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> =
<span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk42"><span class="nb">rewrite</span> &lt;- IHn <span class="kr">in</span> Hg <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; g (fst (s, l)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk43"><span class="nb">destruct</span> (spec s);
<span class="nb">simpl</span> <span class="kr">in</span> Hg;
<span class="kp">try</span> <span class="kp">solve</span> [<span class="nb">rewrite</span> Zmod_odd, Z.add_comm, Z.odd_add_mul_2 <span class="kr">in</span> Hg;
           <span class="bp">discriminate</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
g
(fst
({|
delta := d; f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>; g := <span class="mi">2</span> * g&#39;; oddF := Zodd_2p_plus_1 f&#39;
|}, l)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.H :: l)) = g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk44"><span class="nb">simpl</span> (g _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
g
(fst
({|
delta := d; f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>; g := <span class="mi">2</span> * g&#39;; oddF := Zodd_2p_plus_1 f&#39;
|}, l)) = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g&#39; = g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk45"><span class="nb">simpl</span> (g _) <span class="kr">in</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; <span class="mi">2</span> * g&#39; = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g&#39; = g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk46"><span class="nb">apply</span> Z.mul_cancel_l <span class="kr">with</span> <span class="mi">2</span>; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; <span class="mi">2</span> * g&#39; = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> * g&#39; = <span class="mi">2</span> * (g st / (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk47"><span class="nb">rewrite</span> !(Z.mul_comm <span class="mi">2</span>), &lt;- Zdiv_Zdiv <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; <span class="mi">2</span> * g&#39; = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g&#39; * <span class="mi">2</span> = g st / <span class="mi">2</span> ^ Z.of_nat n / <span class="mi">2</span> * <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk48"><span class="nb">rewrite</span> &lt;- IHn <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; <span class="mi">2</span> * g&#39; = g st / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g&#39; * <span class="mi">2</span> = <span class="mi">2</span> * g&#39; / <span class="mi">2</span> * <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> !(Z.mul_comm <span class="mi">2</span>), Z.div_mul; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk49"><span class="kn">Lemma</span> <span class="nf">fHs</span> <span class="nv">n</span> <span class="nv">st</span> : (<span class="mi">2</span>^(Z.of_nat n) | g st) -&gt;
  f (fst (stepN n st)) = f st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk4a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk4b"><span class="nb">induction</span> n;[<span class="nb">intros</span>; <span class="bp">reflexivity</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n) | g st) -&gt;
f (fst (stepN (S n) st)) = f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk4c"><span class="nb">rewrite</span> Nat2Z.inj_succ, Z.pow_succ_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
f (fst (stepN (S n) st)) = f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk4d"><span class="nb">intros</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (fst (stepN (S n) st)) = f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk4e"><span class="nb">simpl</span> (fst _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk4f"><span class="nb">assert</span> (Hg&#39; : (<span class="mi">2</span> ^ Z.of_nat n | g st)) <span class="bp">by</span> (<span class="nb">etransitivity</span>;[|<span class="nb">apply</span> Hg]; <span class="nb">auto with</span> *).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk50"><span class="nb">apply</span> Zdivide_mod <span class="kr">in</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st mod (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) = <span class="mi">0</span></span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk51"><span class="nb">apply</span> (<span class="nb">f_equal</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x / <span class="mi">2</span> ^ (Z.of_nat n))) <span class="kr">in</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st mod (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) / <span class="mi">2</span> ^ Z.of_nat n =
<span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk52"><span class="nb">rewrite</span> Z.mul_comm, Z.rem_mul_r, Z.mul_comm, Z_div_plus_full, Z.mod_div, Z.add_0_l <span class="kr">in</span> Hg <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(g st / <span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> =
<span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk53"><span class="nb">rewrite</span> &lt;- gHs <span class="kr">in</span> Hg <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (stepN n st)) = f st</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (stepN n st)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk54"><span class="nb">destruct</span> (stepN n st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (s, l)) = f st</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk55"><span class="nb">rewrite</span> &lt;- IHn <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; f (fst (s, l)) = f st</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
f (fst (s, l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk56"><span class="nb">destruct</span> (spec s);
<span class="nb">simpl</span> <span class="kr">in</span> Hg;
<span class="kp">try</span> <span class="kp">solve</span> [<span class="nb">rewrite</span> Zmod_odd, Z.add_comm, Z.odd_add_mul_2 <span class="kr">in</span> Hg;
           <span class="bp">discriminate</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
f
(fst
({|
delta := d; f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>; g := <span class="mi">2</span> * g&#39;; oddF := Zodd_2p_plus_1 f&#39;
|}, l)) = f st</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.H :: l)) =
f
  (fst
     ({|
        delta := d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := <span class="mi">2</span> * g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, l))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk57"><span class="kn">Lemma</span> <span class="nf">etaHs</span> <span class="nv">n</span> <span class="nv">st</span> : (<span class="mi">2</span>^(Z.of_nat n) | g st) -&gt;
  eta (fst (stepN n st)) = eta st - (Z.of_nat n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
eta (fst (stepN n st)) = eta st - Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk58"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
eta (fst (stepN n st)) = eta st - Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk59"><span class="nb">induction</span> n;[<span class="nb">intros</span>;<span class="nb">cbn</span>;<span class="bp">ring</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n) | g st) -&gt;
eta (fst (stepN (S n) st)) = eta st - Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk5a"><span class="nb">rewrite</span> Nat2Z.inj_succ, Z.pow_succ_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
eta (fst (stepN (S n) st)) =
eta st - Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk5b"><span class="nb">intros</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (stepN (S n) st)) =
eta st - Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk5c"><span class="nb">simpl</span> (fst _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
eta st - Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk5d"><span class="nb">assert</span> (Hg&#39; : (<span class="mi">2</span> ^ Z.of_nat n | g st)) <span class="bp">by</span> (<span class="nb">etransitivity</span>;[|<span class="nb">apply</span> Hg]; <span class="nb">auto with</span> *).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
eta st - Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk5e"><span class="nb">apply</span> Zdivide_mod <span class="kr">in</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st mod (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) = <span class="mi">0</span></span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
eta st - Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk5f"><span class="nb">apply</span> (<span class="nb">f_equal</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x / <span class="mi">2</span> ^ (Z.of_nat n))) <span class="kr">in</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st mod (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) / <span class="mi">2</span> ^ Z.of_nat n =
<span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
eta st - Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk60"><span class="nb">rewrite</span> Z.mul_comm, Z.rem_mul_r, Z.mul_comm, Z_div_plus_full, Z.mod_div, Z.add_0_l <span class="kr">in</span> Hg <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(g st / <span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> =
<span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
eta st - Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk61"><span class="nb">rewrite</span> &lt;- gHs <span class="kr">in</span> Hg <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (stepN n st)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
eta st - Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk62"><span class="nb">destruct</span> (stepN n st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (s, l)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
eta st - Z.succ (Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk63"><span class="nb">replace</span> (eta st - _) <span class="kr">with</span> (eta st - (Z.of_nat n) - <span class="mi">1</span>) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (s, l)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
eta st - Z.of_nat n - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk64"><span class="nb">rewrite</span> &lt;- IHn <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt; eta (fst (s, l)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
eta (fst (s, l)) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk65"><span class="nb">destruct</span> (spec s);
<span class="nb">simpl</span> <span class="kr">in</span> Hg;
<span class="kp">try</span> <span class="kp">solve</span> [<span class="nb">rewrite</span> Zmod_odd, Z.add_comm, Z.odd_add_mul_2 <span class="kr">in</span> Hg;
           <span class="bp">discriminate</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
eta
(fst
({|
delta := d; f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>; g := <span class="mi">2</span> * g&#39;; oddF := Zodd_2p_plus_1 f&#39;
|}, l)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.H :: l)) =
eta
  (fst
     ({|
        delta := d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := <span class="mi">2</span> * g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, l)) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk66"><span class="nb">unfold</span> eta, INC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
eta
(fst
({|
delta := d; f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>; g := <span class="mi">2</span> * g&#39;; oddF := Zodd_2p_plus_1 f&#39;
|}, l)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-
delta
  (fst
     ({|
        delta := <span class="mi">1</span> + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.H :: l)) =
-
delta
  (fst
     ({|
        delta := d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := <span class="mi">2</span> * g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, l)) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk67"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
eta
(fst
({|
delta := d; f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>; g := <span class="mi">2</span> * g&#39;; oddF := Zodd_2p_plus_1 f&#39;
|}, l)) = eta st - Z.of_nat n</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- (<span class="mi">1</span> + d) = - d - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk68"><span class="kn">Lemma</span> <span class="nf">etaSs</span> <span class="nv">n</span> <span class="nv">st</span> : <span class="mi">0</span> &lt;= eta st -&gt;
       Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt;
       eta (fst (stepN n st)) = eta st - Z.of_nat n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt;
eta (fst (stepN n st)) = eta st - Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk69"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt;
eta (fst (stepN n st)) = eta st - Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk6a"><span class="nb">induction</span> n;[<span class="nb">intros</span>;<span class="nb">cbn</span>;<span class="bp">ring</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat (S n) &lt;= <span class="mi">1</span> + eta st -&gt;
eta (fst (stepN (S n) st)) = eta st - Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk6b"><span class="nb">rewrite</span> Nat2Z.inj_succ, &lt;- Z.add_1_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;= eta st -&gt;
<span class="mi">1</span> + Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt;
eta (fst (stepN (S n) st)) = eta st - (<span class="mi">1</span> + Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk6c"><span class="nb">intros</span> Heta Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + Z.of_nat n &lt;= <span class="mi">1</span> + eta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (stepN (S n) st)) = eta st - (<span class="mi">1</span> + Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk6d"><span class="nb">simpl</span> (fst _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt; eta (fst (stepN n st)) = eta st - Z.of_nat n</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + Z.of_nat n &lt;= <span class="mi">1</span> + eta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
eta st - (<span class="mi">1</span> + Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk6e"><span class="nb">destruct</span> (stepN n st) <span class="kr">as</span> [s l].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt; eta (fst (s, l)) = eta st - Z.of_nat n</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + Z.of_nat n &lt;= <span class="mi">1</span> + eta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
eta st - (<span class="mi">1</span> + Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk6f"><span class="nb">transitivity</span> (eta st - Z.of_nat n - <span class="mi">1</span>);[|<span class="bp">ring</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt; eta (fst (s, l)) = eta st - Z.of_nat n</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + Z.of_nat n &lt;= <span class="mi">1</span> + eta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
eta st - Z.of_nat n - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk70"><span class="nb">assert</span> (Hs : eta (fst (s, l)) = eta st - Z.of_nat n) <span class="bp">by</span> (<span class="nb">apply</span> IHn; <span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt; eta (fst (s, l)) = eta st - Z.of_nat n</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + Z.of_nat n &lt;= <span class="mi">1</span> + eta st</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>eta (fst (s, l)) = eta st - Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
eta st - Z.of_nat n - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk71"><span class="nb">rewrite</span> &lt;- Hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + eta st -&gt; eta (fst (s, l)) = eta st - Z.of_nat n</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= eta st</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + Z.of_nat n &lt;= <span class="mi">1</span> + eta st</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>eta (fst (s, l)) = eta st - Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
eta (fst (s, l)) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk72"><span class="nb">unfold</span> eta <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= - delta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + - delta st -&gt;
- delta (fst (s, l)) = - delta st - Z.of_nat n</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= - delta st</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + Z.of_nat n &lt;= <span class="mi">1</span> + - delta st</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>- delta (fst (s, l)) = - delta st - Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-
delta (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l))) =
- delta (fst (s, l)) - <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk73"><span class="nb">destruct</span> (spec s); <span class="nb">cbn</span>; <span class="kp">try</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= - delta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + - delta st -&gt;
-
delta
(fst
({|
delta := Z.pos d;
f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
oddF := Zodd_2p_plus_1 f&#39;
|}, l)) = - delta st - Z.of_nat n</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= - delta st</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + Z.of_nat n &lt;= <span class="mi">1</span> + - delta st</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>-
delta
  (fst
     ({|
        delta := Z.pos d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, l)) = - delta st - Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- Z.pos_sub <span class="mi">1</span> d = Z.neg (d + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk74"><span class="nb">cbn</span> <span class="kr">in</span> Hs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= - delta st -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> + - delta st -&gt;
-
delta
(fst
({|
delta := Z.pos d;
f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
oddF := Zodd_2p_plus_1 f&#39;
|}, l)) = - delta st - Z.of_nat n</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= - delta st</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> + Z.of_nat n &lt;= <span class="mi">1</span> + - delta st</span></span></span><br><span><var>Hs</var><span class="hyp-type"><b>: </b><span>Z.neg d = - delta st - Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- Z.pos_sub <span class="mi">1</span> d = Z.neg (d + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk75"><span class="kn">Lemma</span> <span class="nf">stepN_app</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) <span class="nv">st</span> : stepN (n + m) st = <span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
  (fst (stepN n (fst st1)), snd (stepN n (fst st1)) ++ snd st1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">stepN (n + m) st =
(<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
 (fst (stepN n (fst st1)),
  snd (stepN n (fst st1)) ++ snd st1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk76"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">stepN (n + m) st =
(<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
 (fst (stepN n (fst st1)),
  snd (stepN n (fst st1)) ++ snd st1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk77"><span class="nb">induction</span> n;[<span class="nb">destruct</span> (stepN _ _);<span class="bp">reflexivity</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>stepN (n + m) st =
(<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
(fst (stepN n (fst st1)), snd (stepN n (fst st1)) ++ snd st1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">stepN (S n + m) st =
(<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
 (fst (stepN (S n) (fst st1)),
  snd (stepN (S n) (fst st1)) ++ snd st1))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk78"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>stepN (n + m) st =
(<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
(fst (stepN n (fst st1)), snd (stepN n (fst st1)) ++ snd st1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN (n + m) st <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)) =
(fst
   (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n (fst (stepN m st)) <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)),
 snd
   (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n (fst (stepN m st)) <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)) ++
 snd (stepN m st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk79"><span class="nb">rewrite</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>stepN (n + m) st =
(<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
(fst (stepN n (fst st1)), snd (stepN n (fst st1)) ++ snd st1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">st0</span>, xs) :=
   <span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
   (fst (stepN n (fst st1)),
    snd (stepN n (fst st1)) ++ snd st1) <span class="kr">in</span>
 <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)) =
(fst
   (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n (fst (stepN m st)) <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)),
 snd
   (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n (fst (stepN m st)) <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)) ++
 snd (stepN m st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk7a"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>stepN (n + m) st =
(<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
(fst (stepN n (fst st1)), snd (stepN n (fst st1)) ++ snd st1))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
   step (fst (stepN n (fst (stepN m st)))) <span class="kr">in</span>
 (st1,
  x
  :: snd (stepN n (fst (stepN m st))) ++
     snd (stepN m st))) =
(fst
   (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n (fst (stepN m st)) <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)),
 snd
   (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n (fst (stepN m st)) <span class="kr">in</span>
    <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)) ++
 snd (stepN m st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk7b"><span class="nb">destruct</span> (stepN n _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>stepN (n + m) st =
(<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
(fst (stepN n (fst st1)), snd (stepN n (fst st1)) ++ snd st1))</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">st1</span>, x) := step (fst (s, l)) <span class="kr">in</span>
 (st1, x :: snd (s, l) ++ snd (stepN m st))) =
(fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l)),
 snd (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l)) ++
 snd (stepN m st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk7c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>stepN (n + m) st =
(<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
(fst (stepN n (fst st1)), snd (stepN n (fst st1)) ++ snd st1))</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span>
 (st1, x :: l ++ snd (stepN m st))) =
(fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l)),
 snd (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l)) ++
 snd (stepN m st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk7d"><span class="nb">destruct</span> (step s).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>stepN (n + m) st =
(<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
(fst (stepN n (fst st1)), snd (stepN n (fst st1)) ++ snd st1))</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>s0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>s1</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(s0, s1 :: l ++ snd (stepN m st)) =
(fst (s0, s1 :: l),
 snd (s0, s1 :: l) ++ snd (stepN m st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk7e"><span class="kn">Lemma</span> <span class="nf">stepN_app_fst</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) <span class="nv">st</span> : fst (stepN (n + m) st) = fst (stepN n (fst (stepN m st))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (stepN (n + m) st) =
fst (stepN n (fst (stepN m st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk7f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst (stepN (n + m) st) =
fst (stepN n (fst (stepN m st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk80"><span class="nb">rewrite</span> stepN_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">fst
  (<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
   (fst (stepN n (fst st1)),
    snd (stepN n (fst st1)) ++ snd st1)) =
fst (stepN n (fst (stepN m st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk81"><span class="kn">Lemma</span> <span class="nf">stepN_app_snd</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) <span class="nv">st</span> : snd (stepN (n + m) st) = 
  snd (stepN n (fst (stepN m st))) ++ snd (stepN m st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd (stepN (n + m) st) =
snd (stepN n (fst (stepN m st))) ++ snd (stepN m st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk82"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd (stepN (n + m) st) =
snd (stepN n (fst (stepN m st))) ++ snd (stepN m st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk83"><span class="nb">rewrite</span> stepN_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">snd
  (<span class="kr">let</span> <span class="nv">st1</span> := stepN m st <span class="kr">in</span>
   (fst (stepN n (fst st1)),
    snd (stepN n (fst st1)) ++ snd st1)) =
snd (stepN n (fst (stepN m st))) ++ snd (stepN m st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk84"><span class="kn">Lemma</span> <span class="nf">etaDs</span> <span class="nv">n</span> <span class="nv">st</span> : Zodd (g st) -&gt; eta st &lt; <span class="mi">0</span> -&gt;
       <span class="mi">0</span> &lt; Z.of_nat n &lt;= <span class="mi">1</span> - eta st -&gt;
       eta (fst (stepN n st)) = -eta st - Z.of_nat n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd (g st) -&gt;
eta st &lt; <span class="mi">0</span> -&gt;
<span class="mi">0</span> &lt; Z.of_nat n &lt;= <span class="mi">1</span> - eta st -&gt;
eta (fst (stepN n st)) = - eta st - Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk85"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd (g st) -&gt;
eta st &lt; <span class="mi">0</span> -&gt;
<span class="mi">0</span> &lt; Z.of_nat n &lt;= <span class="mi">1</span> - eta st -&gt;
eta (fst (stepN n st)) = - eta st - Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk86"><span class="nb">intros</span> Hodd Heta Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (g st)</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span>eta st &lt; <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat n &lt;= <span class="mi">1</span> - eta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (stepN n st)) = - eta st - Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk87"><span class="nb">destruct</span> n;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (g st)</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span>eta st &lt; <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n) &lt;= <span class="mi">1</span> - eta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (stepN (S n) st)) = - eta st - Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk88"><span class="nb">rewrite</span> &lt;- Nat.add_1_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (g st)</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span>eta st &lt; <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n) &lt;= <span class="mi">1</span> - eta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (stepN (n + <span class="mi">1</span>) st)) =
- eta st - Z.of_nat (n + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk89"><span class="nb">rewrite</span> stepN_app_fst.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (g st)</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span>eta st &lt; <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n) &lt;= <span class="mi">1</span> - eta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta (fst (stepN n (fst (stepN <span class="mi">1</span> st)))) =
- eta st - Z.of_nat (n + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk8a"><span class="nb">simpl</span> (stepN <span class="mi">1</span> st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (g st)</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span>eta st &lt; <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n) &lt;= <span class="mi">1</span> - eta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta
  (fst
     (stepN n
        (fst
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st <span class="kr">in</span> (st1, x :: nil))))) =
- eta st - Z.of_nat (n + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk8b"><span class="nb">destruct</span> (spec st);[<span class="nb">elim</span> (Zodd_not_Zeven _ Hodd); <span class="nb">apply</span> Zeven_2p| |<span class="nb">unfold</span> eta <span class="kr">in</span> *;<span class="nb">cbn</span> <span class="kr">in</span> *;<span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd
  (g
     {|
       delta := Z.pos d;
       f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       oddF := Zodd_2p_plus_1 f&#39;
     |})</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span>eta
  {|
    delta := Z.pos d;
    f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
    g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
    oddF := Zodd_2p_plus_1 f&#39;
  |} &lt; <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n) &lt;=
<span class="mi">1</span> -
eta
  {|
    delta := Z.pos d;
    f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
    g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
    oddF := Zodd_2p_plus_1 f&#39;
  |}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eta
  (fst
     (stepN n
        (fst
           ({|
              delta := INC - Z.pos d;
              f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
              g := g&#39; - f&#39;;
              oddF := Zodd_2p_plus_1 g&#39;
            |}, Step.D :: nil)))) =
-
eta
  {|
    delta := Z.pos d;
    f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
    g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
    oddF := Zodd_2p_plus_1 f&#39;
  |} - Z.of_nat (n + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk8c"><span class="nb">rewrite</span> etaSs; <span class="nb">unfold</span> eta <span class="kr">in</span> *; <span class="nb">cbn</span> <span class="kr">in</span> *; <span class="nb">change</span> (Z.pos_sub <span class="mi">1</span> d) <span class="kr">with</span> (<span class="mi">1</span> - Z.pos d); <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span>Z.neg d &lt; <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.pos (Pos.of_succ_nat n) &lt;=
Z.pos
  <span class="kr">match</span> d <span class="kr">with</span>
  | q~<span class="mi">1</span> =&gt; (Pos.succ q)~<span class="mi">0</span>
  | q~<span class="mi">0</span> =&gt; q~<span class="mi">1</span>
  | <span class="mi">1</span> =&gt; <span class="mi">2</span>
  <span class="kr">end</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.of_nat n &lt;= <span class="mi">1</span> + - (<span class="mi">1</span> - Z.pos d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk8d"><span class="nb">change</span> (<span class="mi">0</span> &lt; Z.of_nat (S n) &lt;= <span class="mi">1</span> - -(Z.pos d)) <span class="kr">in</span> Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Heta</var><span class="hyp-type"><b>: </b><span>Z.neg d &lt; <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n) &lt;= <span class="mi">1</span> - - Z.pos d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.of_nat n &lt;= <span class="mi">1</span> + - (<span class="mi">1</span> - Z.pos d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk8e"><span class="kn">Lemma</span> <span class="nf">stepN_mod</span> <span class="nv">n</span> <span class="nv">st1</span> <span class="nv">st2</span> :
  eqm (<span class="mi">2</span>^Z.of_nat n) (f st1) (f st2) -&gt;
  eqm (<span class="mi">2</span>^Z.of_nat n) (g st1) (g st2) -&gt;
  delta st1 = delta st2 -&gt;
  delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
  snd (stepN n st1) = snd (stepN n st2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk8f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk90"><span class="nb">revert</span> st1 st2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk91"><span class="nb">induction</span> n;[<span class="nb">simpl</span>;<span class="kp">repeat</span> <span class="nb">split</span>;<span class="bp">congruence</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN (S n) st1)) =
delta (fst (stepN (S n) st2)) /\
snd (stepN (S n) st1) = snd (stepN (S n) st2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk92"><span class="nb">intros</span> st1 st2 Hf Hg Hdelta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (fst (stepN (S n) st1)) =
delta (fst (stepN (S n) st2)) /\
snd (stepN (S n) st1) = snd (stepN (S n) st2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk93"><span class="nb">replace</span> (S n) <span class="kr">with</span> (n + <span class="mi">1</span>)%nat <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (fst (stepN (n + <span class="mi">1</span>) st1)) =
delta (fst (stepN (n + <span class="mi">1</span>) st2)) /\
snd (stepN (n + <span class="mi">1</span>) st1) = snd (stepN (n + <span class="mi">1</span>) st2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk94"><span class="nb">rewrite</span> !stepN_app_fst, !stepN_app_snd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (fst (stepN n (fst (stepN <span class="mi">1</span> st1)))) =
delta (fst (stepN n (fst (stepN <span class="mi">1</span> st2)))) /\
snd (stepN n (fst (stepN <span class="mi">1</span> st1))) ++ snd (stepN <span class="mi">1</span> st1) =
snd (stepN n (fst (stepN <span class="mi">1</span> st2))) ++ snd (stepN <span class="mi">1</span> st2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk95"><span class="nb">simpl</span> (stepN <span class="mi">1</span> st1); <span class="nb">simpl</span> (stepN <span class="mi">1</span> st2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst
     (stepN n
        (fst
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st1 <span class="kr">in</span>
            (st1, x :: nil))))) =
delta
  (fst
     (stepN n
        (fst
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st2 <span class="kr">in</span>
            (st1, x :: nil))))) /\
snd
  (stepN n
     (fst
        (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st1 <span class="kr">in</span> (st1, x :: nil)))) ++
snd (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st1 <span class="kr">in</span> (st1, x :: nil)) =
snd
  (stepN n
     (fst
        (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st2 <span class="kr">in</span> (st1, x :: nil)))) ++
snd (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st2 <span class="kr">in</span> (st1, x :: nil))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk96"><span class="nb">unfold</span> step; <span class="nb">rewrite</span> Hdelta.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst
     (stepN n
        (fst
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
              <span class="kr">match</span> Zeven_odd_dec (g st1) <span class="kr">with</span>
              | <span class="nb">left</span> _ =&gt;
                  ({|
                     delta := INC + delta st2;
                     f := f st1;
                     g := g st1 / <span class="mi">2</span>;
                     oddF := oddF st1
                   |}, Step.H)
              | <span class="nb">right</span> oddG =&gt;
                  <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
                  <span class="kr">then</span>
                   ({|
                      delta := INC - delta st2;
                      f := g st1;
                      g := (g st1 - f st1) / <span class="mi">2</span>;
                      oddF := oddG
                    |}, Step.D)
                  <span class="kr">else</span>
                   ({|
                      delta := INC + delta st2;
                      f := f st1;
                      g := (g st1 + f st1) / <span class="mi">2</span>;
                      oddF := oddF st1
                    |}, Step.S)
              <span class="kr">end</span> <span class="kr">in</span>
            (st1, x :: nil))))) =
delta
  (fst
     (stepN n
        (fst
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
              <span class="kr">match</span> Zeven_odd_dec (g st2) <span class="kr">with</span>
              | <span class="nb">left</span> _ =&gt;
                  ({|
                     delta := INC + delta st2;
                     f := f st2;
                     g := g st2 / <span class="mi">2</span>;
                     oddF := oddF st2
                   |}, Step.H)
              | <span class="nb">right</span> oddG =&gt;
                  <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
                  <span class="kr">then</span>
                   ({|
                      delta := INC - delta st2;
                      f := g st2;
                      g := (g st2 - f st2) / <span class="mi">2</span>;
                      oddF := oddG
                    |}, Step.D)
                  <span class="kr">else</span>
                   ({|
                      delta := INC + delta st2;
                      f := f st2;
                      g := (g st2 + f st2) / <span class="mi">2</span>;
                      oddF := oddF st2
                    |}, Step.S)
              <span class="kr">end</span> <span class="kr">in</span>
            (st1, x :: nil))))) /\
snd
  (stepN n
     (fst
        (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
           <span class="kr">match</span> Zeven_odd_dec (g st1) <span class="kr">with</span>
           | <span class="nb">left</span> _ =&gt;
               ({|
                  delta := INC + delta st2;
                  f := f st1;
                  g := g st1 / <span class="mi">2</span>;
                  oddF := oddF st1
                |}, Step.H)
           | <span class="nb">right</span> oddG =&gt;
               <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
               <span class="kr">then</span>
                ({|
                   delta := INC - delta st2;
                   f := g st1;
                   g := (g st1 - f st1) / <span class="mi">2</span>;
                   oddF := oddG
                 |}, Step.D)
               <span class="kr">else</span>
                ({|
                   delta := INC + delta st2;
                   f := f st1;
                   g := (g st1 + f st1) / <span class="mi">2</span>;
                   oddF := oddF st1
                 |}, Step.S)
           <span class="kr">end</span> <span class="kr">in</span>
         (st1, x :: nil)))) ++
snd
  (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
     <span class="kr">match</span> Zeven_odd_dec (g st1) <span class="kr">with</span>
     | <span class="nb">left</span> _ =&gt;
         ({|
            delta := INC + delta st2;
            f := f st1;
            g := g st1 / <span class="mi">2</span>;
            oddF := oddF st1
          |}, Step.H)
     | <span class="nb">right</span> oddG =&gt;
         <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
         <span class="kr">then</span>
          ({|
             delta := INC - delta st2;
             f := g st1;
             g := (g st1 - f st1) / <span class="mi">2</span>;
             oddF := oddG
           |}, Step.D)
         <span class="kr">else</span>
          ({|
             delta := INC + delta st2;
             f := f st1;
             g := (g st1 + f st1) / <span class="mi">2</span>;
             oddF := oddF st1
           |}, Step.S)
     <span class="kr">end</span> <span class="kr">in</span>
   (st1, x :: nil)) =
snd
  (stepN n
     (fst
        (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
           <span class="kr">match</span> Zeven_odd_dec (g st2) <span class="kr">with</span>
           | <span class="nb">left</span> _ =&gt;
               ({|
                  delta := INC + delta st2;
                  f := f st2;
                  g := g st2 / <span class="mi">2</span>;
                  oddF := oddF st2
                |}, Step.H)
           | <span class="nb">right</span> oddG =&gt;
               <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
               <span class="kr">then</span>
                ({|
                   delta := INC - delta st2;
                   f := g st2;
                   g := (g st2 - f st2) / <span class="mi">2</span>;
                   oddF := oddG
                 |}, Step.D)
               <span class="kr">else</span>
                ({|
                   delta := INC + delta st2;
                   f := f st2;
                   g := (g st2 + f st2) / <span class="mi">2</span>;
                   oddF := oddF st2
                 |}, Step.S)
           <span class="kr">end</span> <span class="kr">in</span>
         (st1, x :: nil)))) ++
snd
  (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
     <span class="kr">match</span> Zeven_odd_dec (g st2) <span class="kr">with</span>
     | <span class="nb">left</span> _ =&gt;
         ({|
            delta := INC + delta st2;
            f := f st2;
            g := g st2 / <span class="mi">2</span>;
            oddF := oddF st2
          |}, Step.H)
     | <span class="nb">right</span> oddG =&gt;
         <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
         <span class="kr">then</span>
          ({|
             delta := INC - delta st2;
             f := g st2;
             g := (g st2 - f st2) / <span class="mi">2</span>;
             oddF := oddG
           |}, Step.D)
         <span class="kr">else</span>
          ({|
             delta := INC + delta st2;
             f := f st2;
             g := (g st2 + f st2) / <span class="mi">2</span>;
             oddF := oddF st2
           |}, Step.S)
     <span class="kr">end</span> <span class="kr">in</span>
   (st1, x :: nil))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk97"><span class="nb">assert</span> (Hdiv2 : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt; eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk98" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) =
delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk98"><hr></label><div class="goal-conclusion">delta
  (fst
     (stepN n
        (fst
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
              <span class="kr">match</span> Zeven_odd_dec (g st1) <span class="kr">with</span>
              | <span class="nb">left</span> _ =&gt;
                  ({|
                     delta := INC + delta st2;
                     f := f st1;
                     g := g st1 / <span class="mi">2</span>;
                     oddF := oddF st1
                   |}, Step.H)
              | <span class="nb">right</span> oddG =&gt;
                  <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
                  <span class="kr">then</span>
                   ({|
                      delta := INC - delta st2;
                      f := g st1;
                      g := (g st1 - f st1) / <span class="mi">2</span>;
                      oddF := oddG
                    |}, Step.D)
                  <span class="kr">else</span>
                   ({|
                      delta := INC + delta st2;
                      f := f st1;
                      g := (g st1 + f st1) / <span class="mi">2</span>;
                      oddF := oddF st1
                    |}, Step.S)
              <span class="kr">end</span> <span class="kr">in</span>
            (st1, x :: nil))))) =
delta
  (fst
     (stepN n
        (fst
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
              <span class="kr">match</span> Zeven_odd_dec (g st2) <span class="kr">with</span>
              | <span class="nb">left</span> _ =&gt;
                  ({|
                     delta := INC + delta st2;
                     f := f st2;
                     g := g st2 / <span class="mi">2</span>;
                     oddF := oddF st2
                   |}, Step.H)
              | <span class="nb">right</span> oddG =&gt;
                  <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
                  <span class="kr">then</span>
                   ({|
                      delta := INC - delta st2;
                      f := g st2;
                      g := (g st2 - f st2) / <span class="mi">2</span>;
                      oddF := oddG
                    |}, Step.D)
                  <span class="kr">else</span>
                   ({|
                      delta := INC + delta st2;
                      f := f st2;
                      g := (g st2 + f st2) / <span class="mi">2</span>;
                      oddF := oddF st2
                    |}, Step.S)
              <span class="kr">end</span> <span class="kr">in</span>
            (st1, x :: nil))))) /\
snd
  (stepN n
     (fst
        (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
           <span class="kr">match</span> Zeven_odd_dec (g st1) <span class="kr">with</span>
           | <span class="nb">left</span> _ =&gt;
               ({|
                  delta := INC + delta st2;
                  f := f st1;
                  g := g st1 / <span class="mi">2</span>;
                  oddF := oddF st1
                |}, Step.H)
           | <span class="nb">right</span> oddG =&gt;
               <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
               <span class="kr">then</span>
                ({|
                   delta := INC - delta st2;
                   f := g st1;
                   g := (g st1 - f st1) / <span class="mi">2</span>;
                   oddF := oddG
                 |}, Step.D)
               <span class="kr">else</span>
                ({|
                   delta := INC + delta st2;
                   f := f st1;
                   g := (g st1 + f st1) / <span class="mi">2</span>;
                   oddF := oddF st1
                 |}, Step.S)
           <span class="kr">end</span> <span class="kr">in</span>
         (st1, x :: nil)))) ++
snd
  (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
     <span class="kr">match</span> Zeven_odd_dec (g st1) <span class="kr">with</span>
     | <span class="nb">left</span> _ =&gt;
         ({|
            delta := INC + delta st2;
            f := f st1;
            g := g st1 / <span class="mi">2</span>;
            oddF := oddF st1
          |}, Step.H)
     | <span class="nb">right</span> oddG =&gt;
         <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
         <span class="kr">then</span>
          ({|
             delta := INC - delta st2;
             f := g st1;
             g := (g st1 - f st1) / <span class="mi">2</span>;
             oddF := oddG
           |}, Step.D)
         <span class="kr">else</span>
          ({|
             delta := INC + delta st2;
             f := f st1;
             g := (g st1 + f st1) / <span class="mi">2</span>;
             oddF := oddF st1
           |}, Step.S)
     <span class="kr">end</span> <span class="kr">in</span>
   (st1, x :: nil)) =
snd
  (stepN n
     (fst
        (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
           <span class="kr">match</span> Zeven_odd_dec (g st2) <span class="kr">with</span>
           | <span class="nb">left</span> _ =&gt;
               ({|
                  delta := INC + delta st2;
                  f := f st2;
                  g := g st2 / <span class="mi">2</span>;
                  oddF := oddF st2
                |}, Step.H)
           | <span class="nb">right</span> oddG =&gt;
               <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
               <span class="kr">then</span>
                ({|
                   delta := INC - delta st2;
                   f := g st2;
                   g := (g st2 - f st2) / <span class="mi">2</span>;
                   oddF := oddG
                 |}, Step.D)
               <span class="kr">else</span>
                ({|
                   delta := INC + delta st2;
                   f := f st2;
                   g := (g st2 + f st2) / <span class="mi">2</span>;
                   oddF := oddF st2
                 |}, Step.S)
           <span class="kr">end</span> <span class="kr">in</span>
         (st1, x :: nil)))) ++
snd
  (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
     <span class="kr">match</span> Zeven_odd_dec (g st2) <span class="kr">with</span>
     | <span class="nb">left</span> _ =&gt;
         ({|
            delta := INC + delta st2;
            f := f st2;
            g := g st2 / <span class="mi">2</span>;
            oddF := oddF st2
          |}, Step.H)
     | <span class="nb">right</span> oddG =&gt;
         <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
         <span class="kr">then</span>
          ({|
             delta := INC - delta st2;
             f := g st2;
             g := (g st2 - f st2) / <span class="mi">2</span>;
             oddF := oddG
           |}, Step.D)
         <span class="kr">else</span>
          ({|
             delta := INC + delta st2;
             f := f st2;
             g := (g st2 + f st2) / <span class="mi">2</span>;
             oddF := oddF st2
           |}, Step.S)
     <span class="kr">end</span> <span class="kr">in</span>
   (st1, x :: nil))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk99"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk9a"><span class="nb">intros</span> x y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk9b"><span class="nb">unfold</span> eqm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x mod <span class="mi">2</span> ^ Z.of_nat (S n) = y mod <span class="mi">2</span> ^ Z.of_nat (S n) -&gt;
(x / <span class="mi">2</span>) mod <span class="mi">2</span> ^ Z.of_nat n =
(y / <span class="mi">2</span>) mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk9c"><span class="nb">rewrite</span> &lt;-!Z.land_ones, &lt;-!(Z.shiftr_div_pow2 _ <span class="mi">1</span>) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.land x (Z.ones (Z.of_nat (S n))) =
Z.land y (Z.ones (Z.of_nat (S n))) -&gt;
Z.land (Z.shiftr x <span class="mi">1</span>) (Z.ones (Z.of_nat n)) =
Z.land (Z.shiftr y <span class="mi">1</span>) (Z.ones (Z.of_nat n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk9d"><span class="nb">replace</span> (Z.of_nat n) <span class="kr">with</span> (Z.of_nat (S n) - <span class="mi">1</span>) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.land x (Z.ones (Z.of_nat (S n))) =
Z.land y (Z.ones (Z.of_nat (S n))) -&gt;
Z.land (Z.shiftr x <span class="mi">1</span>) (Z.ones (Z.of_nat (S n) - <span class="mi">1</span>)) =
Z.land (Z.shiftr y <span class="mi">1</span>) (Z.ones (Z.of_nat (S n) - <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk9e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk9e"><span class="nb">rewrite</span> &lt;-!extraMath.Z_shiftr_ones, &lt;-!Z.shiftr_land <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.land x (Z.ones (Z.of_nat (S n))) =
Z.land y (Z.ones (Z.of_nat (S n))) -&gt;
Z.shiftr (Z.land x (Z.ones (Z.of_nat (S n)))) <span class="mi">1</span> =
Z.shiftr (Z.land y (Z.ones (Z.of_nat (S n)))) <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk9f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst
     (stepN n
        (fst
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
              <span class="kr">match</span> Zeven_odd_dec (g st1) <span class="kr">with</span>
              | <span class="nb">left</span> _ =&gt;
                  ({|
                     delta := INC + delta st2;
                     f := f st1;
                     g := g st1 / <span class="mi">2</span>;
                     oddF := oddF st1
                   |}, Step.H)
              | <span class="nb">right</span> oddG =&gt;
                  <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
                  <span class="kr">then</span>
                   ({|
                      delta := INC - delta st2;
                      f := g st1;
                      g := (g st1 - f st1) / <span class="mi">2</span>;
                      oddF := oddG
                    |}, Step.D)
                  <span class="kr">else</span>
                   ({|
                      delta := INC + delta st2;
                      f := f st1;
                      g := (g st1 + f st1) / <span class="mi">2</span>;
                      oddF := oddF st1
                    |}, Step.S)
              <span class="kr">end</span> <span class="kr">in</span>
            (st1, x :: nil))))) =
delta
  (fst
     (stepN n
        (fst
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
              <span class="kr">match</span> Zeven_odd_dec (g st2) <span class="kr">with</span>
              | <span class="nb">left</span> _ =&gt;
                  ({|
                     delta := INC + delta st2;
                     f := f st2;
                     g := g st2 / <span class="mi">2</span>;
                     oddF := oddF st2
                   |}, Step.H)
              | <span class="nb">right</span> oddG =&gt;
                  <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
                  <span class="kr">then</span>
                   ({|
                      delta := INC - delta st2;
                      f := g st2;
                      g := (g st2 - f st2) / <span class="mi">2</span>;
                      oddF := oddG
                    |}, Step.D)
                  <span class="kr">else</span>
                   ({|
                      delta := INC + delta st2;
                      f := f st2;
                      g := (g st2 + f st2) / <span class="mi">2</span>;
                      oddF := oddF st2
                    |}, Step.S)
              <span class="kr">end</span> <span class="kr">in</span>
            (st1, x :: nil))))) /\
snd
  (stepN n
     (fst
        (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
           <span class="kr">match</span> Zeven_odd_dec (g st1) <span class="kr">with</span>
           | <span class="nb">left</span> _ =&gt;
               ({|
                  delta := INC + delta st2;
                  f := f st1;
                  g := g st1 / <span class="mi">2</span>;
                  oddF := oddF st1
                |}, Step.H)
           | <span class="nb">right</span> oddG =&gt;
               <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
               <span class="kr">then</span>
                ({|
                   delta := INC - delta st2;
                   f := g st1;
                   g := (g st1 - f st1) / <span class="mi">2</span>;
                   oddF := oddG
                 |}, Step.D)
               <span class="kr">else</span>
                ({|
                   delta := INC + delta st2;
                   f := f st1;
                   g := (g st1 + f st1) / <span class="mi">2</span>;
                   oddF := oddF st1
                 |}, Step.S)
           <span class="kr">end</span> <span class="kr">in</span>
         (st1, x :: nil)))) ++
snd
  (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
     <span class="kr">match</span> Zeven_odd_dec (g st1) <span class="kr">with</span>
     | <span class="nb">left</span> _ =&gt;
         ({|
            delta := INC + delta st2;
            f := f st1;
            g := g st1 / <span class="mi">2</span>;
            oddF := oddF st1
          |}, Step.H)
     | <span class="nb">right</span> oddG =&gt;
         <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
         <span class="kr">then</span>
          ({|
             delta := INC - delta st2;
             f := g st1;
             g := (g st1 - f st1) / <span class="mi">2</span>;
             oddF := oddG
           |}, Step.D)
         <span class="kr">else</span>
          ({|
             delta := INC + delta st2;
             f := f st1;
             g := (g st1 + f st1) / <span class="mi">2</span>;
             oddF := oddF st1
           |}, Step.S)
     <span class="kr">end</span> <span class="kr">in</span>
   (st1, x :: nil)) =
snd
  (stepN n
     (fst
        (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
           <span class="kr">match</span> Zeven_odd_dec (g st2) <span class="kr">with</span>
           | <span class="nb">left</span> _ =&gt;
               ({|
                  delta := INC + delta st2;
                  f := f st2;
                  g := g st2 / <span class="mi">2</span>;
                  oddF := oddF st2
                |}, Step.H)
           | <span class="nb">right</span> oddG =&gt;
               <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
               <span class="kr">then</span>
                ({|
                   delta := INC - delta st2;
                   f := g st2;
                   g := (g st2 - f st2) / <span class="mi">2</span>;
                   oddF := oddG
                 |}, Step.D)
               <span class="kr">else</span>
                ({|
                   delta := INC + delta st2;
                   f := f st2;
                   g := (g st2 + f st2) / <span class="mi">2</span>;
                   oddF := oddF st2
                 |}, Step.S)
           <span class="kr">end</span> <span class="kr">in</span>
         (st1, x :: nil)))) ++
snd
  (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
     <span class="kr">match</span> Zeven_odd_dec (g st2) <span class="kr">with</span>
     | <span class="nb">left</span> _ =&gt;
         ({|
            delta := INC + delta st2;
            f := f st2;
            g := g st2 / <span class="mi">2</span>;
            oddF := oddF st2
          |}, Step.H)
     | <span class="nb">right</span> oddG =&gt;
         <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st2
         <span class="kr">then</span>
          ({|
             delta := INC - delta st2;
             f := g st2;
             g := (g st2 - f st2) / <span class="mi">2</span>;
             oddF := oddG
           |}, Step.D)
         <span class="kr">else</span>
          ({|
             delta := INC + delta st2;
             f := f st2;
             g := (g st2 + f st2) / <span class="mi">2</span>;
             oddF := oddF st2
           |}, Step.S)
     <span class="kr">end</span> <span class="kr">in</span>
   (st1, x :: nil))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chka0"><span class="nb">destruct</span> (Zeven_odd_dec (g st1)); <span class="nb">destruct</span> (Zeven_odd_dec (g st2)); 
<span class="kp">try</span> <span class="kp">solve</span>
[<span class="nb">exfalso</span>;
<span class="nb">rewrite</span> &lt;-<span class="nl">?Zeven_bool_iff</span>, &lt;-<span class="nl">?Zodd_bool_iff</span>, <span class="nl">?Zeven_mod</span>, <span class="nl">?Zodd_mod</span> <span class="kr">in</span> *;
<span class="nb">apply</span> Zeq_bool_eq <span class="kr">in</span> z, z0;
<span class="nb">apply</span> (extraMath.eqm_2_pow_le <span class="mi">1</span>) <span class="kr">in</span> Hg; <span class="kp">try</span> <span class="bp">lia</span>;
<span class="nb">change</span> (<span class="mi">2</span>^<span class="mi">1</span>) <span class="kr">with</span> <span class="mi">2</span> <span class="kr">in</span> *;
<span class="nb">rewrite</span> Hg <span class="kr">in</span> z;
<span class="bp">congruence</span>
];[|<span class="nb">destruct</span> (<span class="mi">0</span> &lt;? delta st2)];<span class="nb">cbn</span>;
  <span class="nb">set</span> (st1&#39; := Build_State _ _ _ _);
  <span class="nb">set</span> (st2&#39; := Build_State _ _ _ _);
  <span class="nb">destruct</span> (IHn st1&#39; st2&#39;);
  <span class="kp">try</span> <span class="kp">solve</span> [<span class="nb">cbn</span>; <span class="bp">lia</span>|<span class="nb">split</span>; <span class="bp">congruence</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zeven (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zeven (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st1;
  g := g st1 / <span class="mi">2</span>;
  oddF := oddF st1
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st2;
  g := g st2 / <span class="mi">2</span>;
  oddF := oddF st2
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1&#39;) (f st2&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chka1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) =
delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zeven (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zeven (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st1;
  g := g st1 / <span class="mi">2</span>;
  oddF := oddF st1
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st2;
  g := g st2 / <span class="mi">2</span>;
  oddF := oddF st2
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chka1"><hr></label><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1&#39;) (g st2&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chka2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) =
delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zodd (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zodd (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - delta st2;
  f := g st1;
  g := (g st1 - f st1) / <span class="mi">2</span>;
  oddF := z
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - delta st2;
  f := g st2;
  g := (g st2 - f st2) / <span class="mi">2</span>;
  oddF := z0
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chka2"><hr></label><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1&#39;) (f st2&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chka3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) =
delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zodd (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zodd (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - delta st2;
  f := g st1;
  g := (g st1 - f st1) / <span class="mi">2</span>;
  oddF := z
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - delta st2;
  f := g st2;
  g := (g st2 - f st2) / <span class="mi">2</span>;
  oddF := z0
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chka3"><hr></label><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1&#39;) (g st2&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chka4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) =
delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zodd (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zodd (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st1;
  g := (g st1 + f st1) / <span class="mi">2</span>;
  oddF := oddF st1
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st2;
  g := (g st2 + f st2) / <span class="mi">2</span>;
  oddF := oddF st2
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chka4"><hr></label><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1&#39;) (f st2&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chka5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) =
delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zodd (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zodd (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st1;
  g := (g st1 + f st1) / <span class="mi">2</span>;
  oddF := oddF st1
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st2;
  g := (g st2 + f st2) / <span class="mi">2</span>;
  oddF := oddF st2
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chka5"><hr></label><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1&#39;) (g st2&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chka6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chka6">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zeven (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zeven (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st1;
  g := g st1 / <span class="mi">2</span>;
  oddF := oddF st1
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st2;
  g := g st2 / <span class="mi">2</span>;
  oddF := oddF st2
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1&#39;) (f st2&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> extraMath.eqm_2_pow_le;[|<span class="nb">apply</span> Hf]; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chka7">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zeven (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zeven (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st1;
  g := g st1 / <span class="mi">2</span>;
  oddF := oddF st1
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st2;
  g := g st2 / <span class="mi">2</span>;
  oddF := oddF st2
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1&#39;) (g st2&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hdiv2; <span class="nb">apply</span> Hg.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chka8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chka8">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zodd (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zodd (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - delta st2;
  f := g st1;
  g := (g st1 - f st1) / <span class="mi">2</span>;
  oddF := z
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - delta st2;
  f := g st2;
  g := (g st2 - f st2) / <span class="mi">2</span>;
  oddF := z0
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1&#39;) (f st2&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> extraMath.eqm_2_pow_le;[|<span class="nb">apply</span> Hg]; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chka9">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zodd (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zodd (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - delta st2;
  f := g st1;
  g := (g st1 - f st1) / <span class="mi">2</span>;
  oddF := z
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - delta st2;
  f := g st2;
  g := (g st2 - f st2) / <span class="mi">2</span>;
  oddF := z0
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1&#39;) (g st2&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hdiv2; <span class="nb">apply</span> Zminus_eqm; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkaa" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkaa">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zodd (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zodd (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st1;
  g := (g st1 + f st1) / <span class="mi">2</span>;
  oddF := oddF st1
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st2;
  g := (g st2 + f st2) / <span class="mi">2</span>;
  oddF := oddF st2
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1&#39;) (f st2&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">eapply</span> extraMath.eqm_2_pow_le;[|<span class="nb">apply</span> Hf]; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkab">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st1</span> <span class="nv">st2</span> : State,
eqm (<span class="mi">2</span> ^ Z.of_nat n) (f st1) (f st2) -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1) (g st2) -&gt;
delta st1 = delta st2 -&gt;
delta (fst (stepN n st1)) = delta (fst (stepN n st2)) /\
snd (stepN n st1) = snd (stepN n st2)</span></span></span><br><span><var>st1, st2</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (f st1) (f st2)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) (g st1) (g st2)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st1 = delta st2</span></span></span><br><span><var>Hdiv2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : Z,
eqm (<span class="mi">2</span> ^ Z.of_nat (S n)) x y -&gt;
eqm (<span class="mi">2</span> ^ Z.of_nat n) (x / <span class="mi">2</span>) (y / <span class="mi">2</span>)</span></span></span><br><span><var>z</var><span class="hyp-type"><b>: </b><span>Zodd (g st1)</span></span></span><br><span><var>z0</var><span class="hyp-type"><b>: </b><span>Zodd (g st2)</span></span></span><br><span><var>st1'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st1;
  g := (g st1 + f st1) / <span class="mi">2</span>;
  oddF := oddF st1
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st2'</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> + delta st2;
  f := f st2;
  g := (g st2 + f st2) / <span class="mi">2</span>;
  oddF := oddF st2
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n) (g st1&#39;) (g st2&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hdiv2; <span class="nb">apply</span> Zplus_eqm; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkac" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkac"><span class="kn">Lemma</span> <span class="nf">fStepBounds</span> <span class="nv">st</span> : Z.abs (f (fst (step st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (f (fst (step st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkad"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (f (fst (step st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (spec st); <span class="nb">cbn</span>;<span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkae" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkae"><span class="kn">Lemma</span> <span class="nf">gStepBounds</span> <span class="nv">st</span> : <span class="mi">2</span> * Z.abs (g (fst (step st))) &lt;= Z.abs (f st) + Z.abs (g st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> * Z.abs (g (fst (step st))) &lt;=
Z.abs (f st) + Z.abs (g st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkaf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> * Z.abs (g (fst (step st))) &lt;=
Z.abs (f st) + Z.abs (g st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (spec st); <span class="nb">cbn</span>;<span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb0"><span class="kn">Lemma</span> <span class="nf">fgBounds</span> <span class="nv">st</span> <span class="nv">n</span> :
 Z.abs (f (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
 Z.abs (g (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (f (fst (stepN n st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (f (fst (stepN n st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb2"><span class="nb">induction</span> n;[<span class="nb">cbn</span>; <span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (f (fst (stepN (S n) st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN (S n) st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb3"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs
  (f
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs
  (g
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb4"><span class="nb">assert</span> (Hf := fStepBounds (fst (stepN n st))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (step (fst (stepN n st))))) &lt;=
Z.max (Z.abs (f (fst (stepN n st))))
  (Z.abs (g (fst (stepN n st))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs
  (f
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs
  (g
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb5"><span class="nb">assert</span> (Hg := gStepBounds (fst (stepN n st))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (step (fst (stepN n st))))) &lt;=
Z.max (Z.abs (f (fst (stepN n st))))
  (Z.abs (g (fst (stepN n st))))</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * Z.abs (g (fst (step (fst (stepN n st))))) &lt;=
Z.abs (f (fst (stepN n st))) +
Z.abs (g (fst (stepN n st)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs
  (f
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs
  (g
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb6"><span class="nb">destruct</span> (stepN n st) <span class="kr">as</span> [st&#39; xs].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st'</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (st&#39;, xs))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (st&#39;, xs))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (step (fst (st&#39;, xs))))) &lt;=
Z.max (Z.abs (f (fst (st&#39;, xs))))
  (Z.abs (g (fst (st&#39;, xs))))</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * Z.abs (g (fst (step (fst (st&#39;, xs))))) &lt;=
Z.abs (f (fst (st&#39;, xs))) +
Z.abs (g (fst (st&#39;, xs)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs
  (f
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs
  (g
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb7"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st'</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (f st&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g st&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (step st&#39;))) &lt;=
Z.max (Z.abs (f st&#39;)) (Z.abs (g st&#39;))</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * Z.abs (g (fst (step st&#39;))) &lt;=
Z.abs (f st&#39;) + Z.abs (g st&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs
  (f
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs
  (g
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb8"><span class="nb">destruct</span> (step st&#39;) <span class="kr">as</span> [st&#39;&#39; xs&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st'</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (f st&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g st&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>st''</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (st&#39;&#39;, xs&#39;))) &lt;=
Z.max (Z.abs (f st&#39;)) (Z.abs (g st&#39;))</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * Z.abs (g (fst (st&#39;&#39;, xs&#39;))) &lt;=
Z.abs (f st&#39;) + Z.abs (g st&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (f (fst (st&#39;&#39;, xs&#39; :: xs))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (st&#39;&#39;, xs&#39; :: xs))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkb9"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st'</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (f st&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g st&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>st''</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f st&#39;&#39;) &lt;=
Z.max (Z.abs (f st&#39;)) (Z.abs (g st&#39;))</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * Z.abs (g st&#39;&#39;) &lt;=
Z.abs (f st&#39;) + Z.abs (g st&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (f st&#39;&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g st&#39;&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkba" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkba"><span class="kn">Lemma</span> <span class="nf">fgBoundsStrict</span> <span class="nv">st</span> <span class="nv">n</span> :
 Z.abs (g st) &lt; Z.abs (f st) -&gt;
 Z.abs (f (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
 Z.abs (g (fst (stepN n st))) &lt; Z.max (Z.abs (f st)) (Z.abs (g st)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f (fst (stepN n st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt;
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkbb"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f (fst (stepN n st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt;
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkbc"><span class="nb">induction</span> n;[<span class="nb">cbn</span>; <span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt; Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f (fst (stepN (S n) st))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN (S n) st))) &lt;
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkbd" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkbd"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt; Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs
  (f
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs
  (g
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkbe"><span class="nb">assert</span> (Hf := fStepBounds (fst (stepN n st))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt; Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (step (fst (stepN n st))))) &lt;=
Z.max (Z.abs (f (fst (stepN n st))))
  (Z.abs (g (fst (stepN n st))))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs
  (f
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs
  (g
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkbf" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkbf"><span class="nb">assert</span> (Hg := gStepBounds (fst (stepN n st))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f (fst (stepN n st))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (stepN n st))) &lt; Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (step (fst (stepN n st))))) &lt;=
Z.max (Z.abs (f (fst (stepN n st))))
  (Z.abs (g (fst (stepN n st))))</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * Z.abs (g (fst (step (fst (stepN n st))))) &lt;=
Z.abs (f (fst (stepN n st))) +
Z.abs (g (fst (stepN n st)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs
  (f
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs
  (g
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) &lt;
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkc0"><span class="nb">destruct</span> (stepN n st) <span class="kr">as</span> [st&#39; xs].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st'</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f (fst (st&#39;, xs))) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (st&#39;, xs))) &lt; Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (step (fst (st&#39;, xs))))) &lt;=
Z.max (Z.abs (f (fst (st&#39;, xs))))
  (Z.abs (g (fst (st&#39;, xs))))</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * Z.abs (g (fst (step (fst (st&#39;, xs))))) &lt;=
Z.abs (f (fst (st&#39;, xs))) +
Z.abs (g (fst (st&#39;, xs)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs
  (f
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs
  (g
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: xs)))) &lt;
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkc1"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st'</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f st&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g st&#39;) &lt; Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (step st&#39;))) &lt;=
Z.max (Z.abs (f st&#39;)) (Z.abs (g st&#39;))</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * Z.abs (g (fst (step st&#39;))) &lt;=
Z.abs (f st&#39;) + Z.abs (g st&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs
  (f
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: xs)))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs
  (g
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: xs)))) &lt;
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkc2"><span class="nb">destruct</span> (step st&#39;) <span class="kr">as</span> [st&#39;&#39; xs&#39;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st'</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f st&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g st&#39;) &lt; Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>st''</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f (fst (st&#39;&#39;, xs&#39;))) &lt;=
Z.max (Z.abs (f st&#39;)) (Z.abs (g st&#39;))</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * Z.abs (g (fst (st&#39;&#39;, xs&#39;))) &lt;=
Z.abs (f st&#39;) + Z.abs (g st&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f (fst (st&#39;&#39;, xs&#39; :: xs))) &lt;=
Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g (fst (st&#39;&#39;, xs&#39; :: xs))) &lt;
Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkc3"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st'</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f st&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g st&#39;) &lt; Z.max (Z.abs (f st)) (Z.abs (g st))</span></span></span><br><span><var>st''</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs'</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Z.abs (f st&#39;&#39;) &lt;=
Z.max (Z.abs (f st&#39;)) (Z.abs (g st&#39;))</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * Z.abs (g st&#39;&#39;) &lt;=
Z.abs (f st&#39;) + Z.abs (g st&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (g st) &lt; Z.abs (f st) -&gt;
Z.abs (f st&#39;&#39;) &lt;= Z.max (Z.abs (f st)) (Z.abs (g st)) /\
Z.abs (g st&#39;&#39;) &lt; Z.max (Z.abs (f st)) (Z.abs (g st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkc4"><span class="kn">Lemma</span> <span class="nf">fixed</span> <span class="nv">st</span> <span class="nv">n</span> : g st = <span class="mi">0</span> -&gt;
 f (fst (stepN n st)) = f st /\ g (fst (stepN n st)) = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g st = <span class="mi">0</span> -&gt;
f (fst (stepN n st)) = f st /\
g (fst (stepN n st)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkc5"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g st = <span class="mi">0</span> -&gt;
f (fst (stepN n st)) = f st /\
g (fst (stepN n st)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkc6"><span class="nb">intros</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (fst (stepN n st)) = f st /\
g (fst (stepN n st)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkc7"><span class="nb">induction</span> n;[<span class="nb">auto</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st = <span class="mi">0</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>f (fst (stepN n st)) = f st /\ g (fst (stepN n st)) = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (fst (stepN (S n) st)) = f st /\
g (fst (stepN (S n) st)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkc8"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st = <span class="mi">0</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>f (fst (stepN n st)) = f st /\ g (fst (stepN n st)) = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
f st /\
g
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkc9"><span class="nb">destruct</span> (stepN n st) <span class="kr">as</span> [[eta f g Hf] l].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>divstep.g st = <span class="mi">0</span></span></span></span><br><span><var>eta, f, g</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd f</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>divstep.f (fst ({| delta := eta; f := f; g := g; oddF := Hf |}, l)) =
divstep.f st /\
divstep.g (fst ({| delta := eta; f := f; g := g; oddF := Hf |}, l)) = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">divstep.f
  (fst
     (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
        step
          {|
            delta := eta; f := f; g := g; oddF := Hf
          |} <span class="kr">in</span>
      (st1, x :: l))) = divstep.f st /\
divstep.g
  (fst
     (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
        step
          {|
            delta := eta; f := f; g := g; oddF := Hf
          |} <span class="kr">in</span>
      (st1, x :: l))) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkca"><span class="nb">unfold</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>divstep.g st = <span class="mi">0</span></span></span></span><br><span><var>eta, f, g</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd f</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>divstep.f (fst ({| delta := eta; f := f; g := g; oddF := Hf |}, l)) =
divstep.f st /\
divstep.g (fst ({| delta := eta; f := f; g := g; oddF := Hf |}, l)) = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">divstep.f
  (fst
     (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
        <span class="kr">match</span>
          Zeven_odd_dec
            (divstep.g
               {|
                 delta := eta;
                 f := f;
                 g := g;
                 oddF := Hf
               |})
        <span class="kr">with</span>
        | <span class="nb">left</span> _ =&gt;
            ({|
               delta :=
                 INC +
                 delta
                   {|
                     delta := eta;
                     f := f;
                     g := g;
                     oddF := Hf
                   |};
               f :=
                 divstep.f
                   {|
                     delta := eta;
                     f := f;
                     g := g;
                     oddF := Hf
                   |};
               g :=
                 divstep.g
                   {|
                     delta := eta;
                     f := f;
                     g := g;
                     oddF := Hf
                   |} / <span class="mi">2</span>;
               oddF :=
                 oddF
                   {|
                     delta := eta;
                     f := f;
                     g := g;
                     oddF := Hf
                   |}
             |}, Step.H)
        | <span class="nb">right</span> oddG =&gt;
            <span class="kr">if</span>
             <span class="mi">0</span> &lt;?
             delta
               {|
                 delta := eta;
                 f := f;
                 g := g;
                 oddF := Hf
               |}
            <span class="kr">then</span>
             ({|
                delta :=
                  INC -
                  delta
                    {|
                      delta := eta;
                      f := f;
                      g := g;
                      oddF := Hf
                    |};
                f :=
                  divstep.g
                    {|
                      delta := eta;
                      f := f;
                      g := g;
                      oddF := Hf
                    |};
                g :=
                  (divstep.g
                     {|
                       delta := eta;
                       f := f;
                       g := g;
                       oddF := Hf
                     |} -
                   divstep.f
                     {|
                       delta := eta;
                       f := f;
                       g := g;
                       oddF := Hf
                     |}) / <span class="mi">2</span>;
                oddF := oddG
              |}, Step.D)
            <span class="kr">else</span>
             ({|
                delta :=
                  INC +
                  delta
                    {|
                      delta := eta;
                      f := f;
                      g := g;
                      oddF := Hf
                    |};
                f :=
                  divstep.f
                    {|
                      delta := eta;
                      f := f;
                      g := g;
                      oddF := Hf
                    |};
                g :=
                  (divstep.g
                     {|
                       delta := eta;
                       f := f;
                       g := g;
                       oddF := Hf
                     |} +
                   divstep.f
                     {|
                       delta := eta;
                       f := f;
                       g := g;
                       oddF := Hf
                     |}) / <span class="mi">2</span>;
                oddF :=
                  oddF
                    {|
                      delta := eta;
                      f := f;
                      g := g;
                      oddF := Hf
                    |}
              |}, Step.S)
        <span class="kr">end</span> <span class="kr">in</span>
      (st1, x :: l))) = divstep.f st /\
divstep.g
  (fst
     (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
        <span class="kr">match</span>
          Zeven_odd_dec
            (divstep.g
               {|
                 delta := eta;
                 f := f;
                 g := g;
                 oddF := Hf
               |})
        <span class="kr">with</span>
        | <span class="nb">left</span> _ =&gt;
            ({|
               delta :=
                 INC +
                 delta
                   {|
                     delta := eta;
                     f := f;
                     g := g;
                     oddF := Hf
                   |};
               f :=
                 divstep.f
                   {|
                     delta := eta;
                     f := f;
                     g := g;
                     oddF := Hf
                   |};
               g :=
                 divstep.g
                   {|
                     delta := eta;
                     f := f;
                     g := g;
                     oddF := Hf
                   |} / <span class="mi">2</span>;
               oddF :=
                 oddF
                   {|
                     delta := eta;
                     f := f;
                     g := g;
                     oddF := Hf
                   |}
             |}, Step.H)
        | <span class="nb">right</span> oddG =&gt;
            <span class="kr">if</span>
             <span class="mi">0</span> &lt;?
             delta
               {|
                 delta := eta;
                 f := f;
                 g := g;
                 oddF := Hf
               |}
            <span class="kr">then</span>
             ({|
                delta :=
                  INC -
                  delta
                    {|
                      delta := eta;
                      f := f;
                      g := g;
                      oddF := Hf
                    |};
                f :=
                  divstep.g
                    {|
                      delta := eta;
                      f := f;
                      g := g;
                      oddF := Hf
                    |};
                g :=
                  (divstep.g
                     {|
                       delta := eta;
                       f := f;
                       g := g;
                       oddF := Hf
                     |} -
                   divstep.f
                     {|
                       delta := eta;
                       f := f;
                       g := g;
                       oddF := Hf
                     |}) / <span class="mi">2</span>;
                oddF := oddG
              |}, Step.D)
            <span class="kr">else</span>
             ({|
                delta :=
                  INC +
                  delta
                    {|
                      delta := eta;
                      f := f;
                      g := g;
                      oddF := Hf
                    |};
                f :=
                  divstep.f
                    {|
                      delta := eta;
                      f := f;
                      g := g;
                      oddF := Hf
                    |};
                g :=
                  (divstep.g
                     {|
                       delta := eta;
                       f := f;
                       g := g;
                       oddF := Hf
                     |} +
                   divstep.f
                     {|
                       delta := eta;
                       f := f;
                       g := g;
                       oddF := Hf
                     |}) / <span class="mi">2</span>;
                oddF :=
                  oddF
                    {|
                      delta := eta;
                      f := f;
                      g := g;
                      oddF := Hf
                    |}
              |}, Step.S)
        <span class="kr">end</span> <span class="kr">in</span>
      (st1, x :: l))) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkcb" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkcb"><span class="nb">cbn</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>divstep.g st = <span class="mi">0</span></span></span></span><br><span><var>eta, f, g</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd f</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>f = divstep.f st /\ g = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">divstep.f
  (fst
     (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
        <span class="kr">match</span> Zeven_odd_dec g <span class="kr">with</span>
        | <span class="nb">left</span> _ =&gt;
            ({|
               delta := <span class="mi">1</span> + eta;
               f := f;
               g := g / <span class="mi">2</span>;
               oddF := Hf
             |}, Step.H)
        | <span class="nb">right</span> oddG =&gt;
            <span class="kr">if</span> <span class="mi">0</span> &lt;? eta
            <span class="kr">then</span>
             ({|
                delta := <span class="mi">1</span> - eta;
                f := g;
                g := (g - f) / <span class="mi">2</span>;
                oddF := oddG
              |}, Step.D)
            <span class="kr">else</span>
             ({|
                delta := <span class="mi">1</span> + eta;
                f := f;
                g := (g + f) / <span class="mi">2</span>;
                oddF := Hf
              |}, Step.S)
        <span class="kr">end</span> <span class="kr">in</span>
      (st1, x :: l))) = divstep.f st /\
divstep.g
  (fst
     (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
        <span class="kr">match</span> Zeven_odd_dec g <span class="kr">with</span>
        | <span class="nb">left</span> _ =&gt;
            ({|
               delta := <span class="mi">1</span> + eta;
               f := f;
               g := g / <span class="mi">2</span>;
               oddF := Hf
             |}, Step.H)
        | <span class="nb">right</span> oddG =&gt;
            <span class="kr">if</span> <span class="mi">0</span> &lt;? eta
            <span class="kr">then</span>
             ({|
                delta := <span class="mi">1</span> - eta;
                f := g;
                g := (g - f) / <span class="mi">2</span>;
                oddF := oddG
              |}, Step.D)
            <span class="kr">else</span>
             ({|
                delta := <span class="mi">1</span> + eta;
                f := f;
                g := (g + f) / <span class="mi">2</span>;
                oddF := Hf
              |}, Step.S)
        <span class="kr">end</span> <span class="kr">in</span>
      (st1, x :: l))) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkcc" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkcc"><span class="nb">destruct</span> IHn <span class="kr">as</span> [-&gt; -&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st = <span class="mi">0</span></span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd (f st)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f
  (fst
     (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
        <span class="kr">match</span> Zeven_odd_dec <span class="mi">0</span> <span class="kr">with</span>
        | <span class="nb">left</span> _ =&gt;
            ({|
               delta := <span class="mi">1</span> + eta;
               f := f st;
               g := <span class="mi">0</span> / <span class="mi">2</span>;
               oddF := Hf
             |}, Step.H)
        | <span class="nb">right</span> oddG =&gt;
            <span class="kr">if</span> <span class="mi">0</span> &lt;? eta
            <span class="kr">then</span>
             ({|
                delta := <span class="mi">1</span> - eta;
                f := <span class="mi">0</span>;
                g := (<span class="mi">0</span> - f st) / <span class="mi">2</span>;
                oddF := oddG
              |}, Step.D)
            <span class="kr">else</span>
             ({|
                delta := <span class="mi">1</span> + eta;
                f := f st;
                g := (<span class="mi">0</span> + f st) / <span class="mi">2</span>;
                oddF := Hf
              |}, Step.S)
        <span class="kr">end</span> <span class="kr">in</span>
      (st1, x :: l))) = f st /\
g
  (fst
     (<span class="kr">let</span> (<span class="nv">st1</span>, x) :=
        <span class="kr">match</span> Zeven_odd_dec <span class="mi">0</span> <span class="kr">with</span>
        | <span class="nb">left</span> _ =&gt;
            ({|
               delta := <span class="mi">1</span> + eta;
               f := f st;
               g := <span class="mi">0</span> / <span class="mi">2</span>;
               oddF := Hf
             |}, Step.H)
        | <span class="nb">right</span> oddG =&gt;
            <span class="kr">if</span> <span class="mi">0</span> &lt;? eta
            <span class="kr">then</span>
             ({|
                delta := <span class="mi">1</span> - eta;
                f := <span class="mi">0</span>;
                g := (<span class="mi">0</span> - f st) / <span class="mi">2</span>;
                oddF := oddG
              |}, Step.D)
            <span class="kr">else</span>
             ({|
                delta := <span class="mi">1</span> + eta;
                f := f st;
                g := (<span class="mi">0</span> + f st) / <span class="mi">2</span>;
                oddF := Hf
              |}, Step.S)
        <span class="kr">end</span> <span class="kr">in</span>
      (st1, x :: l))) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkcd"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st = <span class="mi">0</span></span></span></span><br><span><var>eta</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd (f st)</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f st = f st /\ <span class="mi">0</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkce" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkce"><span class="kn">Lemma</span> <span class="nf">fixed_f</span> <span class="nv">st</span> <span class="nv">n</span> : g st = <span class="mi">0</span> -&gt;
 f (fst (stepN n st)) = f st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g st = <span class="mi">0</span> -&gt; f (fst (stepN n st)) = f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkcf" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkcf"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g st = <span class="mi">0</span> -&gt; f (fst (stepN n st)) = f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd0"><span class="nb">intros</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (fst (stepN n st)) = f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd1"><span class="nb">destruct</span> (fixed st n Hg).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st = <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f (fst (stepN n st)) = f st</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>g (fst (stepN n st)) = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (fst (stepN n st)) = f st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd2"><span class="kn">Lemma</span> <span class="nf">fixed_g</span> <span class="nv">st</span> <span class="nv">n</span> : g st = <span class="mi">0</span> -&gt;
 g (fst (stepN n st)) = <span class="mi">0</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g st = <span class="mi">0</span> -&gt; g (fst (stepN n st)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd3"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g st = <span class="mi">0</span> -&gt; g (fst (stepN n st)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd4"><span class="nb">intros</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (stepN n st)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd5"><span class="nb">destruct</span> (fixed st n Hg).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st = <span class="mi">0</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f (fst (stepN n st)) = f st</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>g (fst (stepN n st)) = <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (stepN n st)) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd6"><span class="kn">Lemma</span> <span class="nf">gcd</span> <span class="nv">st</span> <span class="nv">d</span> <span class="nv">n</span> : Zis_gcd (f st) (g st) d -&gt;
 Zis_gcd (f (fst (stepN n st))) (g (fst (stepN n st))) d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zis_gcd (f st) (g st) d -&gt;
Zis_gcd (f (fst (stepN n st))) (g (fst (stepN n st)))
  d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd7"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zis_gcd (f st) (g st) d -&gt;
Zis_gcd (f (fst (stepN n st))) (g (fst (stepN n st)))
  d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd8"><span class="nb">intros</span> Hgcd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zis_gcd (f (fst (stepN n st))) (g (fst (stepN n st)))
  d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkd9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkd9"><span class="nb">induction</span> n;[<span class="nb">auto</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f (fst (stepN n st)))
  (g (fst (stepN n st))) d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zis_gcd (f (fst (stepN (S n) st)))
  (g (fst (stepN (S n) st))) d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkda"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f (fst (stepN n st)))
  (g (fst (stepN n st))) d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zis_gcd
  (f
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))))
  (g
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))))
  d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkdb" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkdb"><span class="nb">destruct</span> (stepN n st) <span class="kr">as</span> [st0 l].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f (fst (st0, l))) (g (fst (st0, l))) d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zis_gcd
  (f (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))))
  (g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))))
  d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkdc"><span class="nb">cbn</span> <span class="kr">in</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st0) (g st0) d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zis_gcd
  (f (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))))
  (g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))))
  d</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkdd"><span class="nb">destruct</span> (spec st0);<span class="nb">cbn</span> <span class="kr">in</span> *;
  <span class="nb">revert</span> IHn;
  <span class="nb">apply</span> Zis_gcd_ind;
  <span class="nb">intros</span> Hd1 Hd2 Hdx;
  <span class="nb">apply</span> Zis_gcd_intro; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | g&#39;)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chkde" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chkde"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Z, (x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | g&#39;) -&gt; (x | d)</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chkdf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chkdf"><hr></label><div class="goal-conclusion">(d | g&#39; - f&#39;)</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chke0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chke0"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | g&#39; - f&#39;) -&gt; (x | d)</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chke1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chke1"><hr></label><div class="goal-conclusion">(d | g&#39; + f&#39; + <span class="mi">1</span>)</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chke2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chke2"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | g&#39; + f&#39; + <span class="mi">1</span>) -&gt; (x | d)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chke3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chke3">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | g&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chke4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chke4"><span class="nb">assert</span> (Hodd : Z.odd d = true).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chke5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><label class="goal-separator" for="divstep-v-chke5"><hr></label><div class="goal-conclusion">(d | g&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chke6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chke6"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chke7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chke7"><span class="nb">destruct</span> Hd1 <span class="kr">as</span> [z1 Hd1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g', z1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * f&#39; + <span class="mi">1</span> = z1 * d</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chke8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chke8"><span class="nb">apply</span> (<span class="nb">f_equal</span> Z.odd) <span class="kr">in</span> Hd1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g', z1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>Z.odd (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) = Z.odd (z1 * d)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chke9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chke9"><span class="nb">rewrite</span> Z.add_comm, Z.odd_add_mul_2, Z.mul_comm, Z.odd_mul <span class="kr">in</span> Hd1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g', z1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>Z.odd <span class="mi">1</span> = (Z.odd d &amp;&amp; Z.odd z1)%bool</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (Z.odd d);<span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkea" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkea">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | g&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkeb" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkeb"><span class="nb">eapply</span> Gauss;[<span class="nb">apply</span> Hd2|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime d <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkec" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkec"><span class="nb">apply</span> rel_prime_mod_rev;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (d mod <span class="mi">2</span>) <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chked" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chked"><span class="nb">rewrite</span> Zmod_odd, Hodd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime <span class="mi">1</span> <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> rel_prime_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkee" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkee">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Z, (x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | g&#39;) -&gt; (x | d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkef" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkef"><span class="nb">intros</span> x Hxf Hxg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hxf</var><span class="hyp-type"><b>: </b><span>(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hxg</var><span class="hyp-type"><b>: </b><span>(x | g&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x | d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkf0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkf0"><span class="nb">apply</span> Hdx; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39;)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39;) -&gt; (x | d)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hxf</var><span class="hyp-type"><b>: </b><span>(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hxg</var><span class="hyp-type"><b>: </b><span>(x | g&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x | <span class="mi">2</span> * g&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkf1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkf1">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | g&#39; - f&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkf2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkf2"><span class="nb">assert</span> (Hodd : Z.odd d = true).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chkf3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><label class="goal-separator" for="divstep-v-chkf3"><hr></label><div class="goal-conclusion">(d | g&#39; - f&#39;)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkf4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkf4"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkf5" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkf5"><span class="nb">destruct</span> Hd1 <span class="kr">as</span> [z1 Hd1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g', z1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * f&#39; + <span class="mi">1</span> = z1 * d</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkf6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkf6"><span class="nb">apply</span> (<span class="nb">f_equal</span> Z.odd) <span class="kr">in</span> Hd1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g', z1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>Z.odd (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) = Z.odd (z1 * d)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkf7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkf7"><span class="nb">rewrite</span> Z.add_comm, Z.odd_add_mul_2, Z.mul_comm, Z.odd_mul <span class="kr">in</span> Hd1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g', z1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>Z.odd <span class="mi">1</span> = (Z.odd d &amp;&amp; Z.odd z1)%bool</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (Z.odd d);<span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkf8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkf8">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | g&#39; - f&#39;)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkf9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkf9"><span class="nb">apply</span> Gauss <span class="kr">with</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | <span class="mi">2</span> * (g&#39; - f&#39;))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chkfa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><label class="goal-separator" for="divstep-v-chkfa"><hr></label><div class="goal-conclusion">rel_prime d <span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkfb" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkfb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | <span class="mi">2</span> * (g&#39; - f&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkfc" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkfc"><span class="nb">replace</span> (<span class="mi">2</span> * (g&#39; - f&#39;)) <span class="kr">with</span> ((<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Z.divide_sub_r; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkfd" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkfd">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime d <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkfe" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkfe"><span class="nb">apply</span> rel_prime_mod_rev;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (d mod <span class="mi">2</span>) <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chkff" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chkff"><span class="nb">rewrite</span> Zmod_odd, Hodd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime <span class="mi">1</span> <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> rel_prime_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk100" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk100">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | g&#39; - f&#39;) -&gt; (x | d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk101" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk101"><span class="nb">intros</span> x Hxf Hxg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hxf</var><span class="hyp-type"><b>: </b><span>(x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hxg</var><span class="hyp-type"><b>: </b><span>(x | g&#39; - f&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x | d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk102" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk102"><span class="nb">apply</span> Hdx; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hxf</var><span class="hyp-type"><b>: </b><span>(x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hxg</var><span class="hyp-type"><b>: </b><span>(x | g&#39; - f&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk103" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk103"><span class="nb">replace</span> (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) <span class="kr">with</span> ((<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) - (<span class="mi">2</span>*(g&#39; - f&#39;))) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hxf</var><span class="hyp-type"><b>: </b><span>(x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hxg</var><span class="hyp-type"><b>: </b><span>(x | g&#39; - f&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span> - <span class="mi">2</span> * (g&#39; - f&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk104" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk104"><span class="nb">apply</span> Z.divide_sub_r; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hxf</var><span class="hyp-type"><b>: </b><span>(x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hxg</var><span class="hyp-type"><b>: </b><span>(x | g&#39; - f&#39;)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x | <span class="mi">2</span> * (g&#39; - f&#39;))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk105" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk105">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | g&#39; + f&#39; + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk106" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk106"><span class="nb">assert</span> (Hodd : Z.odd d = true).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk107" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk107"><hr></label><div class="goal-conclusion">(d | g&#39; + f&#39; + <span class="mi">1</span>)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk108" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk108"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk109" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk109"><span class="nb">destruct</span> Hd1 <span class="kr">as</span> [z1 Hd1].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>z1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> * f&#39; + <span class="mi">1</span> = z1 * d</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk10a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk10a"><span class="nb">apply</span> (<span class="nb">f_equal</span> Z.odd) <span class="kr">in</span> Hd1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>z1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>Z.odd (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) = Z.odd (z1 * d)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk10b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk10b"><span class="nb">rewrite</span> Z.add_comm, Z.odd_add_mul_2, Z.mul_comm, Z.odd_mul <span class="kr">in</span> Hd1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>z1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>Z.odd <span class="mi">1</span> = (Z.odd d &amp;&amp; Z.odd z1)%bool</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.odd d = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (Z.odd d);<span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk10c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk10c">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | g&#39; + f&#39; + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk10d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk10d"><span class="nb">apply</span> Gauss <span class="kr">with</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | <span class="mi">2</span> * (g&#39; + f&#39; + <span class="mi">1</span>))</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk10e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk10e"><hr></label><div class="goal-conclusion">rel_prime d <span class="mi">2</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk10f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk10f">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | <span class="mi">2</span> * (g&#39; + f&#39; + <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk110" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk110"><span class="nb">replace</span> (<span class="mi">2</span> * (g&#39; + f&#39; + <span class="mi">1</span>)) <span class="kr">with</span> ((<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span> + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Z.divide_add_r; <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk111" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk111">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime d <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk112" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk112"><span class="nb">apply</span> rel_prime_mod_rev;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (d mod <span class="mi">2</span>) <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk113" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk113"><span class="nb">rewrite</span> Zmod_odd, Hodd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Z.odd d = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime <span class="mi">1</span> <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> rel_prime_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk114" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk114">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | g&#39; + f&#39; + <span class="mi">1</span>) -&gt; (x | d)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk115" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk115"><span class="nb">intros</span> x Hxf Hxg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hxf</var><span class="hyp-type"><b>: </b><span>(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hxg</var><span class="hyp-type"><b>: </b><span>(x | g&#39; + f&#39; + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x | d)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk116" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk116"><span class="nb">apply</span> Hdx; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hxf</var><span class="hyp-type"><b>: </b><span>(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hxg</var><span class="hyp-type"><b>: </b><span>(x | g&#39; + f&#39; + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk117" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk117"><span class="nb">replace</span> (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) <span class="kr">with</span> ((<span class="mi">2</span>*(g&#39; + f&#39; + <span class="mi">1</span>)) - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hxf</var><span class="hyp-type"><b>: </b><span>(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hxg</var><span class="hyp-type"><b>: </b><span>(x | g&#39; + f&#39; + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x | <span class="mi">2</span> * (g&#39; + f&#39; + <span class="mi">1</span>) - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk118" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk118"><span class="nb">apply</span> Z.divide_sub_r; <span class="kp">try</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span>Zis_gcd (f st) (g st) d</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hd1</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hd2</var><span class="hyp-type"><b>: </b><span>(d | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdx</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>) -&gt; (x | <span class="mi">2</span> * g&#39; + <span class="mi">1</span>) -&gt; (x | d)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hxf</var><span class="hyp-type"><b>: </b><span>(x | <span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hxg</var><span class="hyp-type"><b>: </b><span>(x | g&#39; + f&#39; + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x | <span class="mi">2</span> * (g&#39; + f&#39; + <span class="mi">1</span>))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto with</span> *.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk119" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk119"><span class="kn">Lemma</span> <span class="nf">Translate_divsteps</span> <span class="nv">n</span> <span class="nv">fi</span> <span class="nv">gi</span> (<span class="nv">Hf</span> : Zodd fi) :
 delta (fst (stepN n (init fi gi Hf))) = divsteps.delta (N.iter (N.of_nat n) divsteps.step (divsteps.init fi gi)) /\
 f (fst (stepN n (init fi gi Hf))) = divsteps.f (N.iter (N.of_nat n) divsteps.step (divsteps.init fi gi)) /\
 g (fst (stepN n (init fi gi Hf))) = divsteps.g (N.iter (N.of_nat n) divsteps.step (divsteps.init fi gi)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (fst (stepN n (init fi gi Hf))) =
divsteps.delta
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi)) /\
f (fst (stepN n (init fi gi Hf))) =
divsteps.f
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi)) /\
g (fst (stepN n (init fi gi Hf))) =
divsteps.g
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk11a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk11a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (fst (stepN n (init fi gi Hf))) =
divsteps.delta
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi)) /\
f (fst (stepN n (init fi gi Hf))) =
divsteps.f
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi)) /\
g (fst (stepN n (init fi gi Hf))) =
divsteps.g
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk11b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk11b"><span class="nb">induction</span> n;[<span class="nb">cbn</span>;<span class="nb">auto</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n (init fi gi Hf))) =
divsteps.delta (N.iter (N.of_nat n) divsteps.step (divsteps.init fi gi)) /\
f (fst (stepN n (init fi gi Hf))) =
divsteps.f (N.iter (N.of_nat n) divsteps.step (divsteps.init fi gi)) /\
g (fst (stepN n (init fi gi Hf))) =
divsteps.g (N.iter (N.of_nat n) divsteps.step (divsteps.init fi gi))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (fst (stepN (S n) (init fi gi Hf))) =
divsteps.delta
  (N.iter (N.of_nat (S n)) divsteps.step
     (divsteps.init fi gi)) /\
f (fst (stepN (S n) (init fi gi Hf))) =
divsteps.f
  (N.iter (N.of_nat (S n)) divsteps.step
     (divsteps.init fi gi)) /\
g (fst (stepN (S n) (init fi gi Hf))) =
divsteps.g
  (N.iter (N.of_nat (S n)) divsteps.step
     (divsteps.init fi gi))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk11c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk11c"><span class="nb">destruct</span> IHn <span class="kr">as</span> [IHdelta [IHf IHg]].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>IHdelta</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n (init fi gi Hf))) =
divsteps.delta
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>f (fst (stepN n (init fi gi Hf))) =
divsteps.f
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span>g (fst (stepN n (init fi gi Hf))) =
divsteps.g
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (fst (stepN (S n) (init fi gi Hf))) =
divsteps.delta
  (N.iter (N.of_nat (S n)) divsteps.step
     (divsteps.init fi gi)) /\
f (fst (stepN (S n) (init fi gi Hf))) =
divsteps.f
  (N.iter (N.of_nat (S n)) divsteps.step
     (divsteps.init fi gi)) /\
g (fst (stepN (S n) (init fi gi Hf))) =
divsteps.g
  (N.iter (N.of_nat (S n)) divsteps.step
     (divsteps.init fi gi))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk11d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk11d"><span class="nb">rewrite</span> Nnat.Nat2N.inj_succ, N.iter_succ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>IHdelta</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n (init fi gi Hf))) =
divsteps.delta
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>f (fst (stepN n (init fi gi Hf))) =
divsteps.f
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span>g (fst (stepN n (init fi gi Hf))) =
divsteps.g
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (fst (stepN (S n) (init fi gi Hf))) =
divsteps.delta
  (divsteps.step
     (N.iter (N.of_nat n) divsteps.step
        (divsteps.init fi gi))) /\
f (fst (stepN (S n) (init fi gi Hf))) =
divsteps.f
  (divsteps.step
     (N.iter (N.of_nat n) divsteps.step
        (divsteps.init fi gi))) /\
g (fst (stepN (S n) (init fi gi Hf))) =
divsteps.g
  (divsteps.step
     (N.iter (N.of_nat n) divsteps.step
        (divsteps.init fi gi)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk11e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk11e"><span class="nb">destruct</span> (N.iter (N.of_nat n) divsteps.step (divsteps.init fi gi)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>delta0, f0, g0, d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHdelta</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n (init fi gi Hf))) =
divsteps.delta
  {|
    divsteps.delta := delta0;
    divsteps.f := f0;
    divsteps.g := g0;
    divsteps.d := d;
    divsteps.e := e;
    divsteps.modulus := modulus
  |}</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>f (fst (stepN n (init fi gi Hf))) =
divsteps.f
  {|
    divsteps.delta := delta0;
    divsteps.f := f0;
    divsteps.g := g0;
    divsteps.d := d;
    divsteps.e := e;
    divsteps.modulus := modulus
  |}</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span>g (fst (stepN n (init fi gi Hf))) =
divsteps.g
  {|
    divsteps.delta := delta0;
    divsteps.f := f0;
    divsteps.g := g0;
    divsteps.d := d;
    divsteps.e := e;
    divsteps.modulus := modulus
  |}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta (fst (stepN (S n) (init fi gi Hf))) =
divsteps.delta
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |}) /\
f (fst (stepN (S n) (init fi gi Hf))) =
divsteps.f
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |}) /\
g (fst (stepN (S n) (init fi gi Hf))) =
divsteps.g
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk11f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk11f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>delta0, f0, g0, d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHdelta</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n (init fi gi Hf))) =
divsteps.delta
  {|
    divsteps.delta := delta0;
    divsteps.f := f0;
    divsteps.g := g0;
    divsteps.d := d;
    divsteps.e := e;
    divsteps.modulus := modulus
  |}</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>f (fst (stepN n (init fi gi Hf))) =
divsteps.f
  {|
    divsteps.delta := delta0;
    divsteps.f := f0;
    divsteps.g := g0;
    divsteps.d := d;
    divsteps.e := e;
    divsteps.modulus := modulus
  |}</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span>g (fst (stepN n (init fi gi Hf))) =
divsteps.g
  {|
    divsteps.delta := delta0;
    divsteps.f := f0;
    divsteps.g := g0;
    divsteps.d := d;
    divsteps.e := e;
    divsteps.modulus := modulus
  |}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n (init fi gi Hf) <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
divsteps.delta
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |}) /\
f
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n (init fi gi Hf) <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
divsteps.f
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |}) /\
g
  (fst
     (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n (init fi gi Hf) <span class="kr">in</span>
      <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs))) =
divsteps.g
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk120" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk120"><span class="nb">destruct</span> (stepN n (init fi gi Hf)) <span class="kr">as</span> [st0 l].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>delta0, f0, g0, d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHdelta</var><span class="hyp-type"><b>: </b><span>delta (fst (st0, l)) =
divsteps.delta
  {|
    divsteps.delta := delta0;
    divsteps.f := f0;
    divsteps.g := g0;
    divsteps.d := d;
    divsteps.e := e;
    divsteps.modulus := modulus
  |}</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>f (fst (st0, l)) =
divsteps.f
  {|
    divsteps.delta := delta0;
    divsteps.f := f0;
    divsteps.g := g0;
    divsteps.d := d;
    divsteps.e := e;
    divsteps.modulus := modulus
  |}</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span>g (fst (st0, l)) =
divsteps.g
  {|
    divsteps.delta := delta0;
    divsteps.f := f0;
    divsteps.g := g0;
    divsteps.d := d;
    divsteps.e := e;
    divsteps.modulus := modulus
  |}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))) =
divsteps.delta
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |}) /\
f (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))) =
divsteps.f
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |}) /\
g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))) =
divsteps.g
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk121" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk121"><span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>delta0, f0, g0, d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHdelta</var><span class="hyp-type"><b>: </b><span>delta st0 = delta0</span></span></span><br><span><var>IHf</var><span class="hyp-type"><b>: </b><span>f st0 = f0</span></span></span><br><span><var>IHg</var><span class="hyp-type"><b>: </b><span>g st0 = g0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))) =
divsteps.delta
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |}) /\
f (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))) =
divsteps.f
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |}) /\
g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))) =
divsteps.g
  (divsteps.step
     {|
       divsteps.delta := delta0;
       divsteps.f := f0;
       divsteps.g := g0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk122" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk122"><span class="nb">subst</span> delta0 f0 g0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))) =
divsteps.delta
  (divsteps.step
     {|
       divsteps.delta := delta st0;
       divsteps.f := f st0;
       divsteps.g := g st0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |}) /\
f (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))) =
divsteps.f
  (divsteps.step
     {|
       divsteps.delta := delta st0;
       divsteps.f := f st0;
       divsteps.g := g st0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |}) /\
g (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: l))) =
divsteps.g
  (divsteps.step
     {|
       divsteps.delta := delta st0;
       divsteps.f := f st0;
       divsteps.g := g st0;
       divsteps.d := d;
       divsteps.e := e;
       divsteps.modulus := modulus
     |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk123" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk123"><span class="nb">destruct</span> (spec st0);
<span class="nb">unfold</span> divsteps.step; <span class="nb">cbn</span> -[Z.div].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + d0 =
divsteps.delta
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39;)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := <span class="mi">2</span> * g&#39; / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39;;
       divsteps.g := (<span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}) /\
<span class="mi">2</span> * f&#39; + <span class="mi">1</span> =
divsteps.f
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39;)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := <span class="mi">2</span> * g&#39; / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39;;
       divsteps.g := (<span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}) /\
g&#39; =
divsteps.g
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39;)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := <span class="mi">2</span> * g&#39; / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39;;
       divsteps.g := (<span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |})</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk124" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk124"><hr></label><div class="goal-conclusion">Z.pos_sub <span class="mi">1</span> d0 =
divsteps.delta
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta :=
        Z.pos
          <span class="kr">match</span> d0 <span class="kr">with</span>
          | q~<span class="mi">1</span> =&gt; (Pos.succ q)~<span class="mi">0</span>
          | q~<span class="mi">0</span> =&gt; q~<span class="mi">1</span>
          | <span class="mi">1</span> =&gt; <span class="mi">2</span>
          <span class="kr">end</span>;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    {|
      divsteps.delta := Z.pos_sub <span class="mi">1</span> d0;
      divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := e;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e - d)
         <span class="kr">then</span> e - d + modulus
         <span class="kr">else</span> e - d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}) /\
<span class="mi">2</span> * g&#39; + <span class="mi">1</span> =
divsteps.f
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta :=
        Z.pos
          <span class="kr">match</span> d0 <span class="kr">with</span>
          | q~<span class="mi">1</span> =&gt; (Pos.succ q)~<span class="mi">0</span>
          | q~<span class="mi">0</span> =&gt; q~<span class="mi">1</span>
          | <span class="mi">1</span> =&gt; <span class="mi">2</span>
          <span class="kr">end</span>;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    {|
      divsteps.delta := Z.pos_sub <span class="mi">1</span> d0;
      divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := e;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e - d)
         <span class="kr">then</span> e - d + modulus
         <span class="kr">else</span> e - d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}) /\
g&#39; - f&#39; =
divsteps.g
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta :=
        Z.pos
          <span class="kr">match</span> d0 <span class="kr">with</span>
          | q~<span class="mi">1</span> =&gt; (Pos.succ q)~<span class="mi">0</span>
          | q~<span class="mi">0</span> =&gt; q~<span class="mi">1</span>
          | <span class="mi">1</span> =&gt; <span class="mi">2</span>
          <span class="kr">end</span>;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    {|
      divsteps.delta := Z.pos_sub <span class="mi">1</span> d0;
      divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := e;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e - d)
         <span class="kr">then</span> e - d + modulus
         <span class="kr">else</span> e - d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |})</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chk125" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chk125"><hr></label><div class="goal-conclusion"><span class="mi">1</span> + d0 =
divsteps.delta
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}) /\
<span class="mi">2</span> * f&#39; + <span class="mi">1</span> =
divsteps.f
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}) /\
g&#39; + f&#39; + <span class="mi">1</span> =
divsteps.g
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |})</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk126" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk126">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + d0 =
divsteps.delta
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39;)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := <span class="mi">2</span> * g&#39; / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39;;
       divsteps.g := (<span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}) /\
<span class="mi">2</span> * f&#39; + <span class="mi">1</span> =
divsteps.f
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39;)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := <span class="mi">2</span> * g&#39; / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39;;
       divsteps.g := (<span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}) /\
g&#39; =
divsteps.g
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39;)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := <span class="mi">2</span> * g&#39; / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39;;
       divsteps.g := (<span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk127" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk127"><span class="nb">rewrite</span> Z.even_mul; <span class="nb">cbn</span> -[Z.div].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + d0 = <span class="mi">1</span> + d0 /\
<span class="mi">2</span> * f&#39; + <span class="mi">1</span> = <span class="mi">2</span> * f&#39; + <span class="mi">1</span> /\ g&#39; = <span class="mi">2</span> * g&#39; / <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> (Z.mul_comm <span class="mi">2</span> g&#39;), Z.div_mul; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk128" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk128">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.pos_sub <span class="mi">1</span> d0 =
divsteps.delta
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta :=
        Z.pos
          <span class="kr">match</span> d0 <span class="kr">with</span>
          | q~<span class="mi">1</span> =&gt; (Pos.succ q)~<span class="mi">0</span>
          | q~<span class="mi">0</span> =&gt; q~<span class="mi">1</span>
          | <span class="mi">1</span> =&gt; <span class="mi">2</span>
          <span class="kr">end</span>;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    {|
      divsteps.delta := Z.pos_sub <span class="mi">1</span> d0;
      divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := e;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e - d)
         <span class="kr">then</span> e - d + modulus
         <span class="kr">else</span> e - d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}) /\
<span class="mi">2</span> * g&#39; + <span class="mi">1</span> =
divsteps.f
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta :=
        Z.pos
          <span class="kr">match</span> d0 <span class="kr">with</span>
          | q~<span class="mi">1</span> =&gt; (Pos.succ q)~<span class="mi">0</span>
          | q~<span class="mi">0</span> =&gt; q~<span class="mi">1</span>
          | <span class="mi">1</span> =&gt; <span class="mi">2</span>
          <span class="kr">end</span>;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    {|
      divsteps.delta := Z.pos_sub <span class="mi">1</span> d0;
      divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := e;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e - d)
         <span class="kr">then</span> e - d + modulus
         <span class="kr">else</span> e - d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}) /\
g&#39; - f&#39; =
divsteps.g
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta :=
        Z.pos
          <span class="kr">match</span> d0 <span class="kr">with</span>
          | q~<span class="mi">1</span> =&gt; (Pos.succ q)~<span class="mi">0</span>
          | q~<span class="mi">0</span> =&gt; q~<span class="mi">1</span>
          | <span class="mi">1</span> =&gt; <span class="mi">2</span>
          <span class="kr">end</span>;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    {|
      divsteps.delta := Z.pos_sub <span class="mi">1</span> d0;
      divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := e;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e - d)
         <span class="kr">then</span> e - d + modulus
         <span class="kr">else</span> e - d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk129" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk129"><span class="nb">rewrite</span> Z.add_comm, Z.even_add_mul_2; <span class="nb">cbn</span> -[Z.div].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.pos_sub <span class="mi">1</span> d0 = Z.pos_sub <span class="mi">1</span> d0 /\
<span class="mi">1</span> + <span class="mi">2</span> * g&#39; = <span class="mi">1</span> + <span class="mi">2</span> * g&#39; /\
g&#39; - f&#39; = (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk12a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk12a"><span class="kp">repeat</span> (<span class="nb">split</span>;<span class="kp">try</span> <span class="bp">reflexivity</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g&#39; - f&#39; = (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk12b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk12b"><span class="nb">replace</span> (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) <span class="kr">with</span> ((g&#39; - f&#39;) * <span class="mi">2</span>) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g&#39; - f&#39; = (g&#39; - f&#39;) * <span class="mi">2</span> / <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> Z.div_mul; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk12c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk12c">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + d0 =
divsteps.delta
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}) /\
<span class="mi">2</span> * f&#39; + <span class="mi">1</span> =
divsteps.f
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}) /\
g&#39; + f&#39; + <span class="mi">1</span> =
divsteps.g
  (<span class="kr">if</span> Z.even (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd e <span class="kr">then</span> e + modulus <span class="kr">else</span> e) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    <span class="kr">if</span> <span class="mi">0</span> &lt;? d0
    <span class="kr">then</span>
     {|
       divsteps.delta := <span class="mi">1</span> - d0;
       divsteps.f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := e;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e - d)
          <span class="kr">then</span> e - d + modulus
          <span class="kr">else</span> e - d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |}
    <span class="kr">else</span>
     {|
       divsteps.delta := <span class="mi">1</span> + d0;
       divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       divsteps.g := (<span class="mi">2</span> * g&#39; + <span class="mi">1</span> + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
       divsteps.d := d;
       divsteps.e :=
         (<span class="kr">if</span> Z.odd (e + d)
          <span class="kr">then</span> e + d + modulus
          <span class="kr">else</span> e + d) / <span class="mi">2</span>;
       divsteps.modulus := modulus
     |})</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk12d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk12d"><span class="nb">rewrite</span> (Z.add_comm _ <span class="mi">1</span>), Z.even_add_mul_2; <span class="nb">cbn</span> -[Z.div].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + d0 =
divsteps.delta
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> - d0;
      divsteps.f := <span class="mi">1</span> + <span class="mi">2</span> * g&#39;;
      divsteps.g := (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := e;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e - d)
         <span class="kr">then</span> e - d + modulus
         <span class="kr">else</span> e - d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e + d)
         <span class="kr">then</span> e + d + modulus
         <span class="kr">else</span> e + d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}) /\
<span class="mi">2</span> * f&#39; + <span class="mi">1</span> =
divsteps.f
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> - d0;
      divsteps.f := <span class="mi">1</span> + <span class="mi">2</span> * g&#39;;
      divsteps.g := (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := e;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e - d)
         <span class="kr">then</span> e - d + modulus
         <span class="kr">else</span> e - d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e + d)
         <span class="kr">then</span> e + d + modulus
         <span class="kr">else</span> e + d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}) /\
g&#39; + f&#39; + <span class="mi">1</span> =
divsteps.g
  (<span class="kr">if</span> <span class="mi">0</span> &lt;? d0
   <span class="kr">then</span>
    {|
      divsteps.delta := <span class="mi">1</span> - d0;
      divsteps.f := <span class="mi">1</span> + <span class="mi">2</span> * g&#39;;
      divsteps.g := (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := e;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e - d)
         <span class="kr">then</span> e - d + modulus
         <span class="kr">else</span> e - d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |}
   <span class="kr">else</span>
    {|
      divsteps.delta := <span class="mi">1</span> + d0;
      divsteps.f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
      divsteps.g := (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
      divsteps.d := d;
      divsteps.e :=
        (<span class="kr">if</span> Z.odd (e + d)
         <span class="kr">then</span> e + d + modulus
         <span class="kr">else</span> e + d) / <span class="mi">2</span>;
      divsteps.modulus := modulus
    |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk12e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk12e"><span class="nb">elim</span> Z.ltb_spec;[<span class="bp">lia</span>|<span class="nb">intros</span> _];<span class="nb">cbn</span> -[Z.div].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> + d0 = <span class="mi">1</span> + d0 /\
<span class="mi">2</span> * f&#39; + <span class="mi">1</span> = <span class="mi">2</span> * f&#39; + <span class="mi">1</span> /\
g&#39; + f&#39; + <span class="mi">1</span> = (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk12f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk12f"><span class="kp">repeat</span> (<span class="nb">split</span>;<span class="kp">try</span> <span class="bp">reflexivity</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g&#39; + f&#39; + <span class="mi">1</span> = (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) / <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk130" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk130"><span class="nb">replace</span> (<span class="mi">1</span> + <span class="mi">2</span> * g&#39; + (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) <span class="kr">with</span> ((g&#39; + f&#39; + <span class="mi">1</span>) * <span class="mi">2</span>) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>d, e, modulus</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d0, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>l0</var><span class="hyp-type"><b>: </b><span>d0 &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g&#39; + f&#39; + <span class="mi">1</span> = (g&#39; + f&#39; + <span class="mi">1</span>) * <span class="mi">2</span> / <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> Z.div_mul; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk131" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk131"><span class="kn">Lemma</span> <span class="nf">Translate_divsteps_g</span> <span class="nv">n</span> <span class="nv">fi</span> <span class="nv">gi</span> (<span class="nv">Hf</span> : Zodd fi) :
 g (fst (stepN n (init fi gi Hf))) = divsteps.g (N.iter (N.of_nat n) divsteps.step (divsteps.init fi gi)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (stepN n (init fi gi Hf))) =
divsteps.g
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk132" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk132"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (stepN n (init fi gi Hf))) =
divsteps.g
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk133" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk133"><span class="nb">destruct</span> (Translate_divsteps n fi gi Hf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>fi, gi</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>Zodd fi</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n (init fi gi Hf))) =
divsteps.delta
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>f (fst (stepN n (init fi gi Hf))) =
divsteps.f
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi)) /\
g (fst (stepN n (init fi gi Hf))) =
divsteps.g
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">g (fst (stepN n (init fi gi Hf))) =
divsteps.g
  (N.iter (N.of_nat n) divsteps.step
     (divsteps.init fi gi))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">tauto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Module</span> <span class="nf">Trans</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">V2</span> :=
{ x : Z; y : Z }.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">scale</span> (<span class="nv">c</span> : Z) (<span class="nv">vec</span> : V2) :=
{| x := c * (x vec)
 ; y := c * (y vec)
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk134" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk134"><span class="kn">Lemma</span> <span class="nf">scale_mul</span> <span class="nv">c1</span> <span class="nv">c2</span> <span class="nv">vec</span> : scale (c1 * c2) vec = scale c1 (scale c2 vec).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>c1, c2</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>vec</var><span class="hyp-type"><b>: </b><span>V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (c1 * c2) vec = scale c1 (scale c2 vec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk135" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk135"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>c1, c2</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>vec</var><span class="hyp-type"><b>: </b><span>V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (c1 * c2) vec = scale c1 (scale c2 vec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk136" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk136"><span class="nb">destruct</span> vec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>c1, c2, x0, y0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (c1 * c2) {| x := x0; y := y0 |} =
scale c1 (scale c2 {| x := x0; y := y0 |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> scale; <span class="nb">simpl</span>; <span class="nb">f_equal</span>; <span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Record</span> <span class="nf">M2x2</span> :=
{ u : Z; v : Z; q : Z; r : Z}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">I</span> : M2x2 :=
{| u := <span class="mi">1</span>
 ; v := <span class="mi">0</span>
 ; q := <span class="mi">0</span>
 ; r := <span class="mi">1</span>
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ap</span> (<span class="nv">m</span> : M2x2) (<span class="nv">vec</span> : V2) : V2 :=
{| x := (u m) * (x vec) + (v m) * (y vec)
 ; y := (q m) * (x vec) + (r m) * (y vec)
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk137" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk137"><span class="kn">Lemma</span> <span class="nf">ap_scale</span> <span class="nv">m</span> <span class="nv">c</span> <span class="nv">vec</span> : ap m (scale c vec) = scale c (ap m vec).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>vec</var><span class="hyp-type"><b>: </b><span>V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap m (scale c vec) = scale c (ap m vec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk138" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk138"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>c</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>vec</var><span class="hyp-type"><b>: </b><span>V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap m (scale c vec) = scale c (ap m vec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk139" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk139"><span class="nb">destruct</span> m, vec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>u0, v0, q0, r0, c, x0, y0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap {| u := u0; v := v0; q := q0; r := r0 |}
  (scale c {| x := x0; y := y0 |}) =
scale c
  (ap {| u := u0; v := v0; q := q0; r := r0 |}
     {| x := x0; y := y0 |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> ap, scale; <span class="nb">simpl</span>; <span class="nb">f_equal</span>; <span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">mul</span> (<span class="nv">m1</span> <span class="nv">m2</span>: M2x2) : M2x2 :=
{| u := (u m1) * (u m2) + (v m1) * (q m2)
 ; v := (u m1) * (v m2) + (v m1) * (r m2)
 ; q := (q m1) * (u m2) + (r m1) * (q m2)
 ; r := (q m1) * (v m2) + (r m1) * (r m2)
|}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk13a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk13a"><span class="kn">Lemma</span> <span class="nf">mul_assoc</span> <span class="nv">m1</span> <span class="nv">m2</span> <span class="nv">m3</span> : mul m1 (mul m2 m3) = mul (mul m1 m2) m3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m1, m2, m3</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul m1 (mul m2 m3) = mul (mul m1 m2) m3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk13b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk13b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m1, m2, m3</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul m1 (mul m2 m3) = mul (mul m1 m2) m3</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk13c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk13c"><span class="nb">destruct</span> m1, m2, m3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>u0, v0, q0, r0, u1, v1, q1, r1, u2, v2, q2, r2</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul {| u := u0; v := v0; q := q0; r := r0 |}
  (mul {| u := u1; v := v1; q := q1; r := r1 |}
     {| u := u2; v := v2; q := q2; r := r2 |}) =
mul
  (mul {| u := u0; v := v0; q := q0; r := r0 |}
     {| u := u1; v := v1; q := q1; r := r1 |})
  {| u := u2; v := v2; q := q2; r := r2 |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> mul; <span class="nb">simpl</span>; <span class="nb">f_equal</span>; <span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk13d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk13d"><span class="kn">Lemma</span> <span class="nf">ap_mul</span> <span class="nv">m1</span> <span class="nv">m2</span> <span class="nv">vec</span> : ap (mul m1 m2) vec = ap m1 (ap m2 vec).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>vec</var><span class="hyp-type"><b>: </b><span>V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (mul m1 m2) vec = ap m1 (ap m2 vec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk13e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk13e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>vec</var><span class="hyp-type"><b>: </b><span>V2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap (mul m1 m2) vec = ap m1 (ap m2 vec)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk13f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk13f"><span class="nb">destruct</span> m1, m2, vec.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>u0, v0, q0, r0, u1, v1, q1, r1, x0, y0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">ap
  (mul {| u := u0; v := v0; q := q0; r := r0 |}
     {| u := u1; v := v1; q := q1; r := r1 |})
  {| x := x0; y := y0 |} =
ap {| u := u0; v := v0; q := q0; r := r0 |}
  (ap {| u := u1; v := v1; q := q1; r := r1 |}
     {| x := x0; y := y0 |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">unfold</span> ap, mul; <span class="nb">simpl</span>; <span class="nb">f_equal</span>; <span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">det</span> (<span class="nv">m</span>: M2x2) : Z := (u m) * (r m) - (v m) * (q m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk140" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk140"><span class="kn">Lemma</span> <span class="nf">det_mul</span> <span class="nv">m1</span> <span class="nv">m2</span> : det (mul m1 m2) = det m1 * det m2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (mul m1 m2) = det m1 * det m2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk141" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk141"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m1, m2</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (mul m1 m2) = det m1 * det m2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk142" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk142"><span class="nb">destruct</span> m1, m2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>u0, v0, q0, r0, u1, v1, q1, r1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det
  (mul {| u := u0; v := v0; q := q0; r := r0 |}
     {| u := u1; v := v1; q := q1; r := r1 |}) =
det {| u := u0; v := v0; q := q0; r := r0 |} *
det {| u := u1; v := v1; q := q1; r := r1 |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk143" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk143"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>u0, v0, q0, r0, u1, v1, q1, r1</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(u0 * u1 + v0 * q1) * (q0 * v1 + r0 * r1) -
(u0 * v1 + v0 * r1) * (q0 * u1 + r0 * q1) =
(u0 * r0 - v0 * q0) * (u1 * r1 - v1 * q1)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">prod</span> : list M2x2 -&gt; M2x2 := fold_right mul I.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk144" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk144"><span class="kn">Lemma</span> <span class="nf">prod_app</span> <span class="nv">l1</span> <span class="nv">l2</span> : prod (l1 ++ l2) = mul (prod l1) (prod l2).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod (l1 ++ l2) = mul (prod l1) (prod l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk145" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk145"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod (l1 ++ l2) = mul (prod l1) (prod l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk146" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk146"><span class="nb">induction</span> l1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l2</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod (nil ++ l2) = mul (prod nil) (prod l2)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk147" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>prod (l1 ++ l2) = mul (prod l1) (prod l2)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk147"><hr></label><div class="goal-conclusion">prod ((a :: l1) ++ l2) =
mul (prod (a :: l1)) (prod l2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk148" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk148"><span class="mi">1</span>:<span class="nb">cbn</span>; <span class="nb">destruct</span> (prod l2); <span class="nb">unfold</span> mul; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>prod (l1 ++ l2) = mul (prod l1) (prod l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod ((a :: l1) ++ l2) =
mul (prod (a :: l1)) (prod l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk149" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk149"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>prod (l1 ++ l2) = mul (prod l1) (prod l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul a (prod (l1 ++ l2)) =
mul (mul a (prod l1)) (prod l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk14a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk14a"><span class="nb">rewrite</span> IHl1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>l1, l2</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br><span><var>IHl1</var><span class="hyp-type"><b>: </b><span>prod (l1 ++ l2) = mul (prod l1) (prod l2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul a (mul (prod l1) (prod l2)) =
mul (mul a (prod l1)) (prod l2)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (prod l1); <span class="nb">destruct</span> (prod l2); <span class="nb">unfold</span> mul; <span class="nb">cbn</span>; <span class="nb">f_equal</span>; <span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk14b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk14b"><span class="kn">Lemma</span> <span class="nf">det_prod</span> <span class="nv">ms</span> : det (prod ms) = fold_right Z.mul <span class="mi">1</span> (map det ms).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ms</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (prod ms) = fold_right Z.mul <span class="mi">1</span> (map det ms)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk14c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk14c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ms</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (prod ms) = fold_right Z.mul <span class="mi">1</span> (map det ms)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk14d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk14d"><span class="nb">induction</span> ms; <span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>ms</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br><span><var>IHms</var><span class="hyp-type"><b>: </b><span>det (prod ms) = fold_right Z.mul <span class="mi">1</span> (map det ms)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (prod (a :: ms)) =
fold_right Z.mul <span class="mi">1</span> (map det (a :: ms))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk14e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk14e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>ms</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br><span><var>IHms</var><span class="hyp-type"><b>: </b><span>det (prod ms) = fold_right Z.mul <span class="mi">1</span> (map det ms)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (mul a (prod ms)) =
det a * fold_right Z.mul <span class="mi">1</span> (map det ms)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk14f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk14f"><span class="nb">rewrite</span> det_mul.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>ms</var><span class="hyp-type"><b>: </b><span>list M2x2</span></span></span><br><span><var>IHms</var><span class="hyp-type"><b>: </b><span>det (prod ms) = fold_right Z.mul <span class="mi">1</span> (map det ms)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det a * det (prod ms) =
det a * fold_right Z.mul <span class="mi">1</span> (map det ms)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">bounded</span> (<span class="nv">b</span> : Z) (<span class="nv">m</span> : M2x2) :=
  (Z.abs (u m) + Z.abs (v m) &lt;= b /\ -b &lt; u m + v m) /\
  (Z.abs (q m) + Z.abs (r m) &lt;= b /\ -b &lt; q m + r m).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk150" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk150"><span class="kn">Lemma</span> <span class="nf">bounded_I</span> : bounded <span class="mi">1</span> I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded <span class="mi">1</span> I</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk151" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk151"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded <span class="mi">1</span> I</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk152" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk152"><span class="nb">unfold</span> bounded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(Z.abs (u I) + Z.abs (v I) &lt;= <span class="mi">1</span> /\ - (<span class="mi">1</span>) &lt; u I + v I) /\
Z.abs (q I) + Z.abs (r I) &lt;= <span class="mi">1</span> /\ - (<span class="mi">1</span>) &lt; q I + r I</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk153" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk153"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> &lt;= <span class="mi">1</span> /\ -<span class="mi">1</span> &lt; <span class="mi">1</span>) /\ <span class="mi">1</span> &lt;= <span class="mi">1</span> /\ -<span class="mi">1</span> &lt; <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">trans</span> (<span class="nv">s</span> : Step) : M2x2 :=
<span class="kr">match</span> s <span class="kr">with</span>
| Step.H =&gt; {| u := <span class="mi">2</span>; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}
| Step.D =&gt; {| u := <span class="mi">0</span>; v := <span class="mi">2</span>; q := -<span class="mi">1</span>; r := <span class="mi">1</span> |}
| Step.S =&gt; {| u := <span class="mi">2</span>; v := <span class="mi">0</span>; q := <span class="mi">1</span>; r := <span class="mi">1</span> |}
<span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">fg</span> <span class="nv">st</span> := {| x := f st; y := g st |}.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk154" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk154"><span class="kn">Lemma</span> <span class="nf">trans_step</span> <span class="nv">st</span> :
  scale <span class="mi">2</span> (fg (fst (step st))) = ap (trans (snd (step st))) (fg st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale <span class="mi">2</span> (fg (fst (step st))) =
ap (trans (snd (step st))) (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk155" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk155"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale <span class="mi">2</span> (fg (fst (step st))) =
ap (trans (snd (step st))) (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (spec st);
<span class="nb">unfold</span> scale,ap, fg; <span class="nb">cbn</span>;
<span class="nb">f_equal</span>; <span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk156" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk156"><span class="kn">Lemma</span> <span class="nf">det_trans</span> <span class="nv">s</span> : det (trans s) = <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (trans s) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk157" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk157"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>s</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (trans s) = <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> s; <span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk158" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk158"><span class="kn">Lemma</span> <span class="nf">bounded_mul_trans</span> <span class="nv">b</span> <span class="nv">m</span> <span class="nv">s</span> : bounded b m -&gt; bounded (<span class="mi">2</span>*b) (mul (trans s) m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded b m -&gt; bounded (<span class="mi">2</span> * b) (mul (trans s) m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk159" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk159"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>M2x2</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded b m -&gt; bounded (<span class="mi">2</span> * b) (mul (trans s) m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk15a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk15a"><span class="nb">destruct</span> m <span class="kr">as</span> [u v q r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b, u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded b {| u := u; v := v; q := q; r := r |} -&gt;
bounded (<span class="mi">2</span> * b)
  (mul (trans s) {| u := u; v := v; q := q; r := r |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk15b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk15b"><span class="nb">intros</span> [Huv Hqr]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>b, u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>s</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs u + Z.abs v &lt;= b /\ - b &lt; u + v</span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs q + Z.abs r &lt;= b /\ - b &lt; q + r</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded (<span class="mi">2</span> * b)
  (mul (trans s) {| u := u; v := v; q := q; r := r |})</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> s; <span class="nb">unfold</span> bounded; <span class="nb">simpl</span>; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">transN</span> (<span class="nv">n</span> : nat) (<span class="nv">st</span> : State) : M2x2 :=
  prod (map trans (snd (stepN n st))).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk15c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk15c"><span class="kn">Lemma</span> <span class="nf">transN_S</span> <span class="nv">n</span> <span class="nv">st</span> : {x | transN (S n) st = mul (trans x) (transN n st)}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : Step
| transN (S n) st = mul (trans x) (transN n st)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk15d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk15d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : Step
| transN (S n) st = mul (trans x) (transN n st)}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk15e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk15e"><span class="nb">unfold</span> transN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : Step
| prod (map trans (snd (stepN (S n) st))) =
  mul (trans x) (prod (map trans (snd (stepN n st))))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk15f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk15f"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : Step
| prod
    (map trans
       (snd
          (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
           <span class="kr">let</span> (<span class="nv">st1</span>, x0) := step st0 <span class="kr">in</span>
           (st1, x0 :: xs)))) =
  mul (trans x) (prod (map trans (snd (stepN n st))))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk160" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk160"><span class="nb">destruct</span> (stepN n st) <span class="kr">as</span> [st0 xs] <span class="nb">eqn</span>:Hxs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>stepN n st = (st0, xs)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x : Step
| prod
    (map trans
       (snd
          (<span class="kr">let</span> (<span class="nv">st1</span>, x0) := step st0 <span class="kr">in</span>
           (st1, x0 :: xs)))) =
  mul (trans x) (prod (map trans (snd (st0, xs))))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk161" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk161"><span class="nb">destruct</span> (step st0) <span class="kr">as</span> [st1 x].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>stepN n st = (st0, xs)</span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{x0 : Step
| prod (map trans (snd (st1, x :: xs))) =
  mul (trans x0) (prod (map trans (snd (st0, xs))))}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk162" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk162"><span class="kr">exists</span> <span class="nv">x</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>stepN n st = (st0, xs)</span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod (map trans (snd (st1, x :: xs))) =
mul (trans x) (prod (map trans (snd (st0, xs))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk163" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk163"><span class="kn">Lemma</span> <span class="nf">transN_step</span> <span class="nv">n</span> <span class="nv">st</span> :
  scale (<span class="mi">2</span>^(Z.of_nat n)) (fg (fst (stepN n st))) = ap (transN n st) (fg st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN n st))) =
ap (transN n st) (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk164" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk164"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN n st))) =
ap (transN n st) (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk165" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk165"><span class="nb">induction</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> ^ Z.of_nat <span class="mi">0</span>) (fg (fst (stepN <span class="mi">0</span> st))) =
ap (transN <span class="mi">0</span> st) (fg st)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk166" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN n st))) = ap (transN n st) (fg st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk166"><hr></label><div class="goal-conclusion">scale (<span class="mi">2</span> ^ Z.of_nat (S n)) (fg (fst (stepN (S n) st))) =
ap (transN (S n) st) (fg st)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk167" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk167"><span class="nb">rewrite</span> Z.pow_0_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale <span class="mi">1</span> (fg (fst (stepN <span class="mi">0</span> st))) =
ap (transN <span class="mi">0</span> st) (fg st)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk168" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN n st))) = ap (transN n st) (fg st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk168"><hr></label><div class="goal-conclusion">scale (<span class="mi">2</span> ^ Z.of_nat (S n)) (fg (fst (stepN (S n) st))) =
ap (transN (S n) st) (fg st)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk169" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk169"><span class="nb">destruct</span> st; <span class="nb">unfold</span> scale, fg, ap; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>delta0, f0, g0</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>oddF0</var><span class="hyp-type"><b>: </b><span>Zodd f0</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{| x := <span class="mi">1</span> * f0; y := <span class="mi">1</span> * g0 |} =
{| x := <span class="mi">1</span> * f0 + <span class="mi">0</span> * g0; y := <span class="mi">0</span> * f0 + <span class="mi">1</span> * g0 |}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk16a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN n st))) =
ap (transN n st) (fg st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk16a"><hr></label><div class="goal-conclusion">scale (<span class="mi">2</span> ^ Z.of_nat (S n)) (fg (fst (stepN (S n) st))) =
ap (transN (S n) st) (fg st)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk16b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk16b"><span class="nb">f_equal</span>; <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN n st))) = ap (transN n st) (fg st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> ^ Z.of_nat (S n)) (fg (fst (stepN (S n) st))) =
ap (transN (S n) st) (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk16c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk16c"><span class="nb">rewrite</span> Nat2Z.inj_succ, Z.pow_succ_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN n st))) = ap (transN n st) (fg st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN (S n) st))) =
ap (transN (S n) st) (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk16d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk16d"><span class="nb">unfold</span> transN <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN n st))) =
ap (prod (map trans (snd (stepN n st)))) (fg st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN (S n) st))) =
ap (prod (map trans (snd (stepN (S n) st)))) (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk16e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk16e"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg (fst (stepN n st))) =
ap (prod (map trans (snd (stepN n st)))) (fg st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)
  (fg
     (fst
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) =
ap
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
            <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))))
  (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk16f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk16f"><span class="nb">destruct</span> (stepN n st) <span class="kr">as</span> [st0 xs]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg st0) = ap (prod (map trans xs)) (fg st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)
  (fg
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) =
ap
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))))
  (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk170" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk170"><span class="nb">assert</span> (Htrans := trans_step st0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg st0) = ap (prod (map trans xs)) (fg st)</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>scale <span class="mi">2</span> (fg (fst (step st0))) =
ap (trans (snd (step st0))) (fg st0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)
  (fg
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) =
ap
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))))
  (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk171" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk171"><span class="nb">destruct</span> (step st0) <span class="kr">as</span> [st1 x]; <span class="nb">simpl</span> <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg st0) = ap (prod (map trans xs)) (fg st)</span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>scale <span class="mi">2</span> (fg st1) = ap (trans x) (fg st0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) (fg st1) =
ap (mul (trans x) (prod (map trans xs))) (fg st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk172" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk172"><span class="nb">rewrite</span> ap_mul, &lt;- IHn, ap_scale, Z.mul_comm, scale_mul <span class="bp">by</span> <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg st0) = ap (prod (map trans xs)) (fg st)</span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>scale <span class="mi">2</span> (fg st1) = ap (trans x) (fg st0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale (<span class="mi">2</span> ^ Z.of_nat n) (scale <span class="mi">2</span> (fg st1)) =
scale (<span class="mi">2</span> ^ Z.of_nat n) (ap (trans x) (fg st0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk173" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk173"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, st0</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n) (fg st0) = ap (prod (map trans xs)) (fg st)</span></span></span><br><span><var>st1</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br><span><var>Htrans</var><span class="hyp-type"><b>: </b><span>scale <span class="mi">2</span> (fg st1) = ap (trans x) (fg st0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">scale <span class="mi">2</span> (fg st1) = ap (trans x) (fg st0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Htrans.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk174" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk174"><span class="kn">Lemma</span> <span class="nf">det_transN</span> <span class="nv">n</span> <span class="nv">st</span> : det (transN n st) = <span class="mi">2</span>^(Z.of_nat n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (transN n st) = <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk175" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk175"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (transN n st) = <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk176" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk176"><span class="nb">revert</span> st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">st</span> : State, det (transN n st) = <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk177" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk177"><span class="nb">induction</span> n; <span class="kp">try</span> <span class="bp">reflexivity</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st</span> : State, det (transN n st) = <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">st</span> : State,
det (transN (S n) st) = <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk178" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk178"><span class="nb">intros</span> st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st</span> : State, det (transN n st) = <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (transN (S n) st) = <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk179" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk179"><span class="nb">destruct</span> (transN_S n st) <span class="kr">as</span> [x -&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st</span> : State, det (transN n st) = <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">det (mul (trans x) (transN n st)) = <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk17a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk17a"><span class="nb">rewrite</span> det_mul, det_trans, Nat2Z.inj_succ, Z.pow_succ_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">st</span> : State, det (transN n st) = <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> * det (transN n st) = <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">congruence</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk17b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk17b"><span class="kn">Lemma</span> <span class="nf">bounded_transN</span> <span class="nv">n</span> <span class="nv">st</span> : bounded (<span class="mi">2</span>^(Z.of_nat n)) (transN n st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded (<span class="mi">2</span> ^ Z.of_nat n) (transN n st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk17c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk17c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded (<span class="mi">2</span> ^ Z.of_nat n) (transN n st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk17d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk17d"><span class="nb">induction</span> n; <span class="kp">try</span> <span class="nb">apply</span> bounded_I.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>bounded (<span class="mi">2</span> ^ Z.of_nat n) (transN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded (<span class="mi">2</span> ^ Z.of_nat (S n)) (transN (S n) st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk17e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk17e"><span class="nb">destruct</span> (transN_S n st) <span class="kr">as</span> [x -&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>bounded (<span class="mi">2</span> ^ Z.of_nat n) (transN n st)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded (<span class="mi">2</span> ^ Z.of_nat (S n))
  (mul (trans x) (transN n st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk17f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk17f"><span class="nb">rewrite</span> Nat2Z.inj_succ, Z.pow_succ_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>bounded (<span class="mi">2</span> ^ Z.of_nat n) (transN n st)</span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Step</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bounded (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n)
  (mul (trans x) (transN n st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> bounded_mul_trans.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk180" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk180"><span class="kn">Lemma</span> <span class="nf">transN_stepN</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) (<span class="nv">st</span> : State) :
  mul (transN n (fst (stepN m st))) (transN m st) = transN (n + m) st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul (transN n (fst (stepN m st))) (transN m st) =
transN (n + m) st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk181" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk181"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul (transN n (fst (stepN m st))) (transN m st) =
transN (n + m) st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk182" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk182"><span class="nb">unfold</span> transN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod (map trans (snd (stepN n (fst (stepN m st))))))
  (prod (map trans (snd (stepN m st)))) =
prod (map trans (snd (stepN (n + m) st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk183" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk183"><span class="nb">rewrite</span> stepN_app_snd, map_app, prod_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n, m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod (map trans (snd (stepN n (fst (stepN m st))))))
  (prod (map trans (snd (stepN m st)))) =
mul
  (prod (map trans (snd (stepN n (fst (stepN m st))))))
  (prod (map trans (snd (stepN m st))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk184" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk184"><span class="kn">Lemma</span> <span class="nf">transHs</span> <span class="nv">n</span> <span class="nv">st</span> : (<span class="mi">2</span>^(Z.of_nat n) | g st) -&gt;
  transN n st = {| u := <span class="mi">2</span>^(Z.of_nat n); v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
transN n st =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk185" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk185"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
transN n st =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk186" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk186"><span class="nb">induction</span> n;[<span class="nb">intros</span>; <span class="bp">reflexivity</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
transN n st = {| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n) | g st) -&gt;
transN (S n) st =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk187" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk187"><span class="nb">rewrite</span> Nat2Z.inj_succ, Z.pow_succ_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
transN n st = {| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
transN (S n) st =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk188" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk188"><span class="nb">intros</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
transN n st = {| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN (S n) st =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk189" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk189"><span class="nb">unfold</span> transN <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (stepN n st))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod (map trans (snd (stepN (S n) st))) =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk18a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk18a"><span class="nb">simpl</span> (snd _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (stepN n st))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk18b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk18b"><span class="nb">assert</span> (Hg&#39; : (<span class="mi">2</span> ^ Z.of_nat n | g st)) <span class="bp">by</span> (<span class="nb">etransitivity</span>;[|<span class="nb">apply</span> Hg]; <span class="nb">auto with</span> *).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (stepN n st))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk18c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk18c"><span class="nb">apply</span> Zdivide_mod <span class="kr">in</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (stepN n st))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st mod (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) = <span class="mi">0</span></span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk18d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk18d"><span class="nb">apply</span> (<span class="nb">f_equal</span> (<span class="kr">fun</span> <span class="nv">x</span> =&gt; x / <span class="mi">2</span> ^ (Z.of_nat n))) <span class="kr">in</span> Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (stepN n st))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g st mod (<span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n) / <span class="mi">2</span> ^ Z.of_nat n =
<span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk18e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk18e"><span class="nb">rewrite</span> Z.mul_comm, Z.rem_mul_r, Z.mul_comm, Z_div_plus_full, Z.mod_div, Z.add_0_l <span class="kr">in</span> Hg <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (stepN n st))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(g st / <span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> =
<span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk18f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk18f"><span class="nb">rewrite</span> &lt;- gHs <span class="kr">in</span> Hg <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (stepN n st))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (stepN n st)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd
        (<span class="kr">let</span> (<span class="nv">st0</span>, xs) := stepN n st <span class="kr">in</span>
         <span class="kr">let</span> (<span class="nv">st1</span>, x) := step st0 <span class="kr">in</span> (st1, x :: xs)))) =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk190" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk190"><span class="nb">destruct</span> (stepN n st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (s, l))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l)))) =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk191" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk191"><span class="nb">transitivity</span> (mul (trans Step.H) {| u := <span class="mi">2</span>^(Z.of_nat n); v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (s, l))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l)))) =
mul (trans Step.H)
  {| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk192" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (s, l))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk192"><hr></label><div class="goal-conclusion">mul (trans Step.H)
  {| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |} =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk193" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk193"><span class="mi">2</span>:<span class="nb">unfold</span> mul;<span class="nb">cbn</span>;<span class="nb">f_equal</span>; <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (s, l))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l)))) =
mul (trans Step.H)
  {| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk194" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk194"><span class="nb">rewrite</span> &lt;- IHn <span class="bp">by</span> <span class="bp">assumption</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st, s</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod (map trans (snd (s, l))) =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>g (fst (s, l)) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step s <span class="kr">in</span> (st1, x :: l)))) =
mul (trans Step.H) (prod (map trans (snd (s, l))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk195" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk195"><span class="nb">destruct</span> (spec s);
<span class="nb">simpl</span> <span class="kr">in</span> Hg;
<span class="kp">try</span> <span class="kp">solve</span> [<span class="nb">rewrite</span> Zmod_odd, Z.add_comm, Z.odd_add_mul_2 <span class="kr">in</span> Hg;
           <span class="bp">discriminate</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>l</var><span class="hyp-type"><b>: </b><span>list Step</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st) -&gt;
prod
(map trans
(snd
({|
delta := d;
f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
g := <span class="mi">2</span> * g&#39;;
oddF := Zodd_2p_plus_1 f&#39;
|}, l))) = {| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := <span class="mi">0</span>; r := <span class="mi">1</span> |}</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> * g&#39;) mod <span class="mi">2</span> = <span class="mi">0</span> / <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">prod
  (map trans
     (snd
        ({|
           delta := INC + d;
           f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
           g := g&#39;;
           oddF := Zodd_2p_plus_1 f&#39;
         |}, Step.H :: l))) =
mul (trans Step.H)
  (prod
     (map trans
        (snd
           ({|
              delta := d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := <span class="mi">2</span> * g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, l))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk196" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk196"><span class="kn">Lemma</span> <span class="nf">transSs</span> <span class="nv">n</span> <span class="nv">st</span> : delta st &lt;= <span class="mi">0</span> -&gt; Z.of_nat n &lt;= <span class="mi">1</span> - delta st -&gt;
  transN n st = {| u := <span class="mi">2</span>^(Z.of_nat n); v := <span class="mi">0</span>;
    q := (modInv (-f st) (<span class="mi">2</span>^(Z.of_nat n)) * g st) mod (<span class="mi">2</span>^(Z.of_nat n)); r := <span class="mi">1</span> |}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta st &lt;= <span class="mi">0</span> -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> - delta st -&gt;
transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk197" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk197"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta st &lt;= <span class="mi">0</span> -&gt;
Z.of_nat n &lt;= <span class="mi">1</span> - delta st -&gt;
transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk198" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk198"><span class="nb">intros</span> Hdelta Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk199" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk199"><span class="nb">assert</span> (Hrel_prime : rel_prime (f st) <span class="mi">2</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (f st) <span class="mi">2</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk19a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chk19a"><hr></label><div class="goal-conclusion">transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk19b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk19b"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (f st) <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk19c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk19c"><span class="nb">apply</span> rel_prime_mod_rev; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (f st mod <span class="mi">2</span>) <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk19d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk19d"><span class="nb">assert</span> (Hfodd := oddF st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hfodd</var><span class="hyp-type"><b>: </b><span>Zodd (f st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (f st mod <span class="mi">2</span>) <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk19e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk19e"><span class="nb">apply</span> &lt;- Zodd_bool_iff <span class="kr">in</span> Hfodd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hfodd</var><span class="hyp-type"><b>: </b><span>Z.odd (f st) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (f st mod <span class="mi">2</span>) <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk19f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk19f"><span class="nb">rewrite</span> Zmod_odd, Hfodd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hfodd</var><span class="hyp-type"><b>: </b><span>Z.odd (f st) = true</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime <span class="mi">1</span> <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> rel_prime_1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1a0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1a0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1a1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1a1"><span class="nb">assert</span> (Hgcd : <span class="kr">forall</span> <span class="nv">x</span>, <span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Z, <span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk1a2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chk1a2"><hr></label><div class="goal-conclusion">transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1a3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1a3"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : Z, <span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1a4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1a4"><span class="nb">intros</span> x Hx.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1a5" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1a5"><span class="nb">apply</span> Zgcd_1_rel_prime.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (f st) (<span class="mi">2</span> ^ x)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1a6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1a6"><span class="nb">apply</span> Zpow_facts.rel_prime_Zpower_r; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>x</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hx</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (f st) <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1a7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1a7">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1a8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1a8"><span class="nb">replace</span> ((modInv (-f st) (<span class="mi">2</span> ^ Z.of_nat n)
                     * g st) mod <span class="mi">2</span> ^ Z.of_nat n)
 <span class="kr">with</span> ((-modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n)
                     * g st) mod <span class="mi">2</span> ^ Z.of_nat n).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk1a9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chk1a9"><hr></label><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n =
(modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1aa" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1aa"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n =
(modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ab" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ab"><span class="nb">apply</span> Zmult_eqm;[|<span class="bp">reflexivity</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm (<span class="mi">2</span> ^ Z.of_nat n)
  (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n))
  (modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ac" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ac"><span class="nb">unfold</span> eqm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n =
modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ad" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ad"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n =
- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ae" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ae"><span class="nb">rewrite</span> &lt;- (Z.mul_1_l (modInv _ _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> * modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n))
mod <span class="mi">2</span> ^ Z.of_nat n =
- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1af" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1af"><span class="nb">rewrite</span> &lt;- (Hgcd (Z.of_nat n)), &lt;- Zmult_mod_idemp_l, &lt;- modInv_mul_l, Zmult_mod_idemp_l, &lt;- Z.mul_assoc <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) *
 (f st * modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n)))
mod <span class="mi">2</span> ^ Z.of_nat n =
- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b0"><span class="nb">rewrite</span> &lt;- (Z.opp_involutive (f st)) <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) *
 (- - f st * modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n)))
mod <span class="mi">2</span> ^ Z.of_nat n =
- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b1"><span class="nb">rewrite</span> Z.mul_opp_l, Z.mul_opp_r, &lt;- Z.mul_opp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) *
 (- f st * modInv (- f st) (<span class="mi">2</span> ^ Z.of_nat n)))
mod <span class="mi">2</span> ^ Z.of_nat n =
- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b2"><span class="nb">rewrite</span> &lt;- Zmult_mod_idemp_r, modInv_mul_r, Z.gcd_opp_l, Hgcd, Zmult_mod_idemp_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * <span class="mi">1</span>)
mod <span class="mi">2</span> ^ Z.of_nat n =
- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b3"><span class="nb">rewrite</span> Z.mul_1_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n =
- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b4">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b5" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b5"><span class="nb">set</span> (w := _ mod _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN n st =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b6"><span class="nb">apply</span> proj1 <span class="kr">with</span> ( (<span class="mi">2</span>^(Z.of_nat n) | f st * w + g st)
                /\ (delta (fst (stepN n st)) = Z.of_nat n + delta st)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN n st =
{| u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat n | f st * w + g st) /\
delta (fst (stepN n st)) = Z.of_nat n + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b7"><span class="nb">revert</span> w Hn; <span class="nb">induction</span> n; <span class="nb">intros</span> w Hn;
[<span class="kp">repeat</span> <span class="nb">split</span>;[<span class="nb">unfold</span> w;<span class="nb">rewrite</span> Z.mod_1_r;<span class="bp">reflexivity</span>|<span class="nb">apply</span> Z.divide_1_l]|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">let</span> <span class="nv">w</span> :=
  (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
  mod <span class="mi">2</span> ^ Z.of_nat n <span class="kr">in</span>
Z.of_nat n &lt;= <span class="mi">1</span> - delta st -&gt;
transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span>
|} /\
(<span class="mi">2</span> ^ Z.of_nat n | f st * w + g st) /\
delta (fst (stepN n st)) = Z.of_nat n + delta st</span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN (S n) st =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta (fst (stepN (S n) st)) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b8"><span class="nb">destruct</span> IHn <span class="kr">as</span> [IHn1 [IHn2 IHn3]];[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN (S n) st =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta (fst (stepN (S n) st)) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1b9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1b9"><span class="nb">rewrite</span> &lt;- (transN_stepN <span class="mi">1</span> n), IHn1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul (transN <span class="mi">1</span> (fst (stepN n st)))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta (fst (stepN (S n) st)) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ba" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ba"><span class="nb">change</span> (stepN (S n) st) <span class="kr">with</span> (stepN (<span class="mi">1</span> + n) st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul (transN <span class="mi">1</span> (fst (stepN n st)))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta (fst (stepN (<span class="mi">1</span> + n) st)) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1bb" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1bb"><span class="nb">rewrite</span> stepN_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul (transN <span class="mi">1</span> (fst (stepN n st)))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     (<span class="kr">let</span> <span class="nv">st1</span> := stepN n st <span class="kr">in</span>
      (fst (stepN <span class="mi">1</span> (fst st1)),
       snd (stepN <span class="mi">1</span> (fst st1)) ++ snd st1))) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1bc" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1bc"><span class="nb">unfold</span> transN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod (map trans (snd (stepN <span class="mi">1</span> (fst (stepN n st))))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     (fst (stepN <span class="mi">1</span> (fst (stepN n st))),
      snd (stepN <span class="mi">1</span> (fst (stepN n st))) ++
      snd (stepN n st))) = Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1bd" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1bd"><span class="nb">simpl</span> (fst (_,_)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod (map trans (snd (stepN <span class="mi">1</span> (fst (stepN n st))))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step (fst (stepN n st)) <span class="kr">in</span>
      (st1, x :: nil))) = Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1be" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1be"><span class="nb">simpl</span> (stepN <span class="mi">1</span> _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step (fst (stepN n st)) <span class="kr">in</span>
            (st1, x :: nil)))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step (fst (stepN n st)) <span class="kr">in</span>
      (st1, x :: nil))) = Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1bf" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1bf"><span class="nb">set</span> (st&#39; := fst _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span>
            (st1, x :: nil)))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: nil))) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1c0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1c0"><span class="nb">assert</span> (Hst&#39; := eq_refl st&#39;).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>st&#39; = st&#39;</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span>
            (st1, x :: nil)))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: nil))) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1c1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1c1"><span class="nb">revert</span> Hst&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">st&#39; = st&#39; -&gt;
mul
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span>
            (st1, x :: nil)))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: nil))) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1c2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1c2"><span class="nb">unfold</span> st&#39; <span class="nb">at</span> <span class="mi">2</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">st&#39; = fst (stepN n st) -&gt;
mul
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span>
            (st1, x :: nil)))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: nil))) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1c3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1c3"><span class="nb">assert</span> (Hbound : <span class="kr">forall</span> <span class="nv">a</span>, <span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n) <span class="bp">by</span>
 <span class="nb">auto using</span> Z.mod_pos_bound <span class="kr">with</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">st&#39; = fst (stepN n st) -&gt;
mul
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span>
            (st1, x :: nil)))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: nil))) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1c4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1c4"><span class="nb">assert</span> (Hdivide: (<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk1c5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk1c5"><hr></label><div class="goal-conclusion">st&#39; = fst (stepN n st) -&gt;
mul
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span>
            (st1, x :: nil)))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: nil))) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1c6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1c6"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1c7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1c7"><span class="nb">apply</span> Z.mod_divide; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f st * w + g st) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1c8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1c8"><span class="nb">unfold</span> w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(f st *
 ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
  mod <span class="mi">2</span> ^ Z.of_nat (S n)) + g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1c9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1c9"><span class="nb">rewrite</span> &lt;- Zplus_mod_idemp_l, Zmult_mod_idemp_r, Z.mul_assoc,
          Z.mul_opp_r, Z.mul_opp_l, &lt;-Z.mul_opp_r,
          &lt;- Zmult_mod_idemp_l, modInv_mul_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((Z.gcd (f st) (<span class="mi">2</span> ^ Z.of_nat (S n))
  mod <span class="mi">2</span> ^ Z.of_nat (S n) * - g st)
 mod <span class="mi">2</span> ^ Z.of_nat (S n) + g st) mod <span class="mi">2</span> ^ Z.of_nat (S n) =
<span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ca" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ca"><span class="nb">replace</span> (Z.gcd _ _) <span class="kr">with</span> <span class="mi">1</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="mi">1</span> mod <span class="mi">2</span> ^ Z.of_nat (S n) * - g st)
 mod <span class="mi">2</span> ^ Z.of_nat (S n) + g st) mod <span class="mi">2</span> ^ Z.of_nat (S n) =
<span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk1cb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk1cb"><hr></label><div class="goal-conclusion"><span class="mi">1</span> = Z.gcd (f st) (<span class="mi">2</span> ^ Z.of_nat (S n))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1cc" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1cc"><span class="mi">2</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = Z.gcd (f st) (<span class="mi">2</span> ^ Z.of_nat (S n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1cd" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1cd"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.gcd (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ce" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ce"><span class="nb">apply</span> Zgcd_1_rel_prime.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (f st) (<span class="mi">2</span> ^ Z.of_nat (S n))</div></blockquote></div></div></small><span class="alectryon-wsp"> 
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1cf" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1cf"><span class="nb">apply</span> Zpow_facts.rel_prime_Zpower_r; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (f st) <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">   </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1d0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1d0">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((<span class="mi">1</span> mod <span class="mi">2</span> ^ Z.of_nat (S n) * - g st)
 mod <span class="mi">2</span> ^ Z.of_nat (S n) + g st) mod <span class="mi">2</span> ^ Z.of_nat (S n) =
<span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1d1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1d1"><span class="nb">rewrite</span> Zmult_mod_idemp_l, Zplus_mod_idemp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">1</span> * - g st + g st) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1d2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1d2"><span class="nb">ring_simplify</span> (<span class="mi">1</span> * -g st + g st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1d3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1d3">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">st&#39; = fst (stepN n st) -&gt;
mul
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span>
            (st1, x :: nil)))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st&#39; <span class="kr">in</span> (st1, x :: nil))) =
Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1d4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1d4"><span class="nb">elim</span> (spec);<span class="nb">intros</span> d f&#39; g&#39; Hst&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.H :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.H :: nil)) = Z.of_nat (S n) + delta st</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk1d5" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := Z.pos d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk1d5"><hr></label><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC - Z.pos d;
              f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
              g := g&#39; - f&#39;;
              oddF := Zodd_2p_plus_1 g&#39;
            |}, Step.D :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     ({|
        delta := INC - Z.pos d;
        f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
        g := g&#39; - f&#39;;
        oddF := Zodd_2p_plus_1 g&#39;
      |}, Step.D :: nil)) = 
Z.of_nat (S n) + delta st</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chk1d6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chk1d6"><hr></label><div class="goal-conclusion">{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st) -&gt;
mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39; + f&#39; + <span class="mi">1</span>;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.S :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39; + f&#39; + <span class="mi">1</span>;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.S :: nil)) = 
Z.of_nat (S n) + delta st</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1d7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1d7">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.H :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.H :: nil)) = Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1d8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1d8"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.H :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk1d9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk1d9"><hr></label><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chk1da" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk1da"><hr></label><div class="goal-conclusion">delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.H :: nil)) = 
Z.of_nat (S n) + delta st</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1db" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1db">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.H :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1dc" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1dc"><span class="nb">replace</span> (Z.of_nat (S n)) <span class="kr">with</span> (<span class="mi">1</span> + Z.of_nat n) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.H :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{|
  u := <span class="mi">2</span> ^ (<span class="mi">1</span> + Z.of_nat n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span>
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1dd" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1dd"><span class="nb">rewrite</span> Z.pow_add_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.H :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{|
  u := <span class="mi">2</span> ^ <span class="mi">1</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span>
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1de" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1de"><span class="nb">unfold</span> mul; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  u :=
    <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n +
    <span class="mi">0</span> *
    ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
     mod <span class="mi">2</span> ^ Z.of_nat n);
  v := <span class="mi">0</span>;
  q :=
    <span class="mi">0</span> * <span class="mi">2</span> ^ Z.of_nat n +
    <span class="mi">1</span> *
    ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
     mod <span class="mi">2</span> ^ Z.of_nat n);
  r := <span class="mi">1</span>
|} =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1df" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1df"><span class="nb">f_equal</span>; <span class="kp">try</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> * <span class="mi">2</span> ^ Z.of_nat n +
<span class="mi">1</span> *
((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
 mod <span class="mi">2</span> ^ Z.of_nat n) = w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1e0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1e0"><span class="nb">ring_simplify</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n = w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1e1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1e1"><span class="nb">unfold</span> w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n =
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1e2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1e2"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n) =
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1e3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1e3"><span class="nb">apply</span> Zdivide_mod_minus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk1e4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk1e4"><hr></label><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n)
| - modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
  (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
  mod <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1e5" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1e5">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1e6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1e6"><span class="nb">specialize</span> (Hbound ((-modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;=
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1e7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1e7"><span class="nb">replace</span> (Z.of_nat (S n)) <span class="kr">with</span> (<span class="mi">1</span> + Z.of_nat n) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;=
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ (<span class="mi">1</span> + Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> Z.pow_add_r; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1e8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1e8">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n)
| - modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
  (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
  mod <span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1e9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1e9"><span class="nb">set</span> (w0 := (-modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st) mod <span class="mi">2</span> ^ Z.of_nat n) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n)
| - modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st - w0)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ea" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ea"><span class="nb">apply</span> Z.mod_divide; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st - w0)
mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1eb" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1eb"><span class="nb">rewrite</span> &lt;- Zminus_mod_idemp_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
 w0 mod <span class="mi">2</span> ^ Z.of_nat (S n)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ec" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ec"><span class="nb">replace</span> w0 <span class="kr">with</span> (<span class="mi">1</span> * w0) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
 (<span class="mi">1</span> * w0) mod <span class="mi">2</span> ^ Z.of_nat (S n))
mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ed" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ed"><span class="nb">rewrite</span> &lt;- Zmult_mod_idemp_l, &lt;- (Hgcd (Z.of_nat (S n))) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
 (Z.gcd (f st) (<span class="mi">2</span> ^ Z.of_nat (S n))
  mod <span class="mi">2</span> ^ Z.of_nat (S n) * w0) mod <span class="mi">2</span> ^ Z.of_nat (S n))
mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ee" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ee"><span class="nb">rewrite</span> &lt;- modInv_mul_l, Zmult_mod_idemp_l, Zminus_mod_idemp_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
 modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * f st * w0)
mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ef" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ef"><span class="nb">replace</span> (-modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st
       - modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n))
       * f st
       * w0) <span class="kr">with</span>
       (-modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
        (w0 * f st + <span class="mi">1</span> * g st))
       <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (w0 * f st + <span class="mi">1</span> * g st)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f0"><span class="nb">assert</span> (HtransN := transN_step n st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>HtransN</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n)
  (fg (fst (stepN n st))) =
ap (transN n st) (fg st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (w0 * f st + <span class="mi">1</span> * g st)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f1"><span class="nb">rewrite</span> &lt;- Hst&#39;, IHn1 <span class="kr">in</span> HtransN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>HtransN</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n)
  (fg
     {|
       delta := d;
       f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       g := <span class="mi">2</span> * g&#39;;
       oddF := Zodd_2p_plus_1 f&#39;
     |}) =
ap
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q := w0;
    r := <span class="mi">1</span>
  |} (fg st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (w0 * f st + <span class="mi">1</span> * g st)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f2"><span class="nb">unfold</span> fg, scale, ap <span class="kr">in</span> HtransN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>HtransN</var><span class="hyp-type"><b>: </b><span>{|
  x :=
    <span class="mi">2</span> ^ Z.of_nat n *
    x
      {|
        x :=
          f
            {|
              delta := d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := <span class="mi">2</span> * g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |};
        y :=
          g
            {|
              delta := d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := <span class="mi">2</span> * g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |}
      |};
  y :=
    <span class="mi">2</span> ^ Z.of_nat n *
    y
      {|
        x :=
          f
            {|
              delta := d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := <span class="mi">2</span> * g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |};
        y :=
          g
            {|
              delta := d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := <span class="mi">2</span> * g&#39;;
              oddF := Zodd_2p_plus_1 f&#39;
            |}
      |}
|} =
{|
  x :=
    u
      {|
        u := <span class="mi">2</span> ^ Z.of_nat n;
        v := <span class="mi">0</span>;
        q := w0;
        r := <span class="mi">1</span>
      |} * x {| x := f st; y := g st |} +
    v
      {|
        u := <span class="mi">2</span> ^ Z.of_nat n;
        v := <span class="mi">0</span>;
        q := w0;
        r := <span class="mi">1</span>
      |} * y {| x := f st; y := g st |};
  y :=
    q
      {|
        u := <span class="mi">2</span> ^ Z.of_nat n;
        v := <span class="mi">0</span>;
        q := w0;
        r := <span class="mi">1</span>
      |} * x {| x := f st; y := g st |} +
    r
      {|
        u := <span class="mi">2</span> ^ Z.of_nat n;
        v := <span class="mi">0</span>;
        q := w0;
        r := <span class="mi">1</span>
      |} * y {| x := f st; y := g st |}
|}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (w0 * f st + <span class="mi">1</span> * g st)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f3"><span class="nb">simpl</span> <span class="kr">in</span> HtransN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>HtransN</var><span class="hyp-type"><b>: </b><span>{|
  x := <span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>);
  y := <span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39;)
|} =
{|
  x := <span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st;
  y := w0 * f st + <span class="mi">1</span> * g st
|}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (w0 * f st + <span class="mi">1</span> * g st)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f4"><span class="nb">injection</span> HtransN; <span class="nb">clear</span> HtransN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39;) = w0 * f st + <span class="mi">1</span> * g st -&gt;
<span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st -&gt;
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (w0 * f st + <span class="mi">1</span> * g st)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f5" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f5"><span class="nb">intros</span> Hg&#39; Hf&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39;) = w0 * f st + <span class="mi">1</span> * g st</span></span></span><br><span><var>Hf'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (w0 * f st + <span class="mi">1</span> * g st)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f6"><span class="nb">rewrite</span> &lt;- Hg&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39;) = w0 * f st + <span class="mi">1</span> * g st</span></span></span><br><span><var>Hf'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (<span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39;))) mod <span class="mi">2</span> ^ Z.of_nat (S n) =
<span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f7" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f7"><span class="nb">replace</span> (<span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39;)) <span class="kr">with</span> (g&#39; * (<span class="mi">2</span> ^ Z.of_nat n * <span class="mi">2</span>^<span class="mi">1</span>)) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39;) = w0 * f st + <span class="mi">1</span> * g st</span></span></span><br><span><var>Hf'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (g&#39; * (<span class="mi">2</span> ^ Z.of_nat n * <span class="mi">2</span> ^ <span class="mi">1</span>)))
mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f8"><span class="nb">rewrite</span> &lt;- Z.pow_add_r, Z.mul_assoc <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39;) = w0 * f st + <span class="mi">1</span> * g st</span></span></span><br><span><var>Hf'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g&#39; *
 <span class="mi">2</span> ^ (Z.of_nat n + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1f9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1f9"><span class="nb">replace</span> (Z.of_nat n + <span class="mi">1</span>) <span class="kr">with</span> (Z.of_nat (S n)) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39;) = w0 * f st + <span class="mi">1</span> * g st</span></span></span><br><span><var>Hf'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g&#39; *
 <span class="mi">2</span> ^ Z.of_nat (S n)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Z_mod_mult.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1fa" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1fa">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1fb" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1fb">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.H :: nil)) = Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1fc" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1fc"><span class="nb">replace</span> (Z.of_nat (S n) + delta st)
    <span class="kr">with</span> (<span class="mi">1</span> + (Z.of_nat n + delta st)) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.H :: nil)) =
<span class="mi">1</span> + (Z.of_nat n + delta st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1fd" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1fd"><span class="nb">rewrite</span> &lt;- IHn3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39;;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.H :: nil)) =
<span class="mi">1</span> + delta (fst (stepN n st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1fe" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1fe"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">INC + d = <span class="mi">1</span> + delta (fst (stepN n st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk1ff" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk1ff"><span class="nb">rewrite</span> &lt;- Hst&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39;;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">INC + d =
<span class="mi">1</span> +
delta
  {|
    delta := d;
    f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
    g := <span class="mi">2</span> * g&#39;;
    oddF := Zodd_2p_plus_1 f&#39;
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk200" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk200">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := Z.pos d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC - Z.pos d;
              f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
              g := g&#39; - f&#39;;
              oddF := Zodd_2p_plus_1 g&#39;
            |}, Step.D :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     ({|
        delta := INC - Z.pos d;
        f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
        g := g&#39; - f&#39;;
        oddF := Zodd_2p_plus_1 g&#39;
      |}, Step.D :: nil)) = Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk201" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk201"><span class="nb">rewrite</span> &lt;- Hst&#39; <span class="kr">in</span> IHn3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta
  {|
    delta := Z.pos d;
    f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
    g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
    oddF := Zodd_2p_plus_1 f&#39;
  |} = Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := Z.pos d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC - Z.pos d;
              f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
              g := g&#39; - f&#39;;
              oddF := Zodd_2p_plus_1 g&#39;
            |}, Step.D :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     ({|
        delta := INC - Z.pos d;
        f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
        g := g&#39; - f&#39;;
        oddF := Zodd_2p_plus_1 g&#39;
      |}, Step.D :: nil)) = Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk202" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk202"><span class="nb">unfold</span> delta <span class="nb">at</span> <span class="mi">1</span> <span class="kr">in</span> IHn3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>Z.pos d = Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>{|
  delta := Z.pos d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC - Z.pos d;
              f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
              g := g&#39; - f&#39;;
              oddF := Zodd_2p_plus_1 g&#39;
            |}, Step.D :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     ({|
        delta := INC - Z.pos d;
        f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
        g := g&#39; - f&#39;;
        oddF := Zodd_2p_plus_1 g&#39;
      |}, Step.D :: nil)) = Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk203" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk203">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st) -&gt;
mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39; + f&#39; + <span class="mi">1</span>;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.S :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |} /\
(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st) /\
delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39; + f&#39; + <span class="mi">1</span>;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.S :: nil)) = Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk204" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk204"><span class="kp">repeat</span> <span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39; + f&#39; + <span class="mi">1</span>;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.S :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |}</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk205" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk205"><hr></label><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</div></blockquote><input class="alectryon-extra-goal-toggle" id="divstep-v-chk206" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk206"><hr></label><div class="goal-conclusion">delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39; + f&#39; + <span class="mi">1</span>;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.S :: nil)) = 
Z.of_nat (S n) + delta st</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk207" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk207">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39; + f&#39; + <span class="mi">1</span>;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.S :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{| u := <span class="mi">2</span> ^ Z.of_nat (S n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk208" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk208"><span class="nb">replace</span> (Z.of_nat (S n)) <span class="kr">with</span> (<span class="mi">1</span> + Z.of_nat n) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39; + f&#39; + <span class="mi">1</span>;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.S :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{|
  u := <span class="mi">2</span> ^ (<span class="mi">1</span> + Z.of_nat n); v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span>
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk209" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk209"><span class="nb">rewrite</span> Z.pow_add_r <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (prod
     (map trans
        (snd
           ({|
              delta := INC + d;
              f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
              g := g&#39; + f&#39; + <span class="mi">1</span>;
              oddF := Zodd_2p_plus_1 f&#39;
            |}, Step.S :: nil))))
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q :=
      (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
      mod <span class="mi">2</span> ^ Z.of_nat n;
    r := <span class="mi">1</span>
  |} =
{|
  u := <span class="mi">2</span> ^ <span class="mi">1</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span>
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk20a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk20a"><span class="nb">unfold</span> mul; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  u :=
    <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n +
    <span class="mi">0</span> *
    ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
     mod <span class="mi">2</span> ^ Z.of_nat n);
  v := <span class="mi">0</span>;
  q :=
    <span class="mi">1</span> * <span class="mi">2</span> ^ Z.of_nat n +
    <span class="mi">1</span> *
    ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
     mod <span class="mi">2</span> ^ Z.of_nat n);
  r := <span class="mi">1</span>
|} =
{| u := <span class="mi">2</span> * <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w; r := <span class="mi">1</span> |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk20b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk20b"><span class="nb">f_equal</span>; <span class="kp">try</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * <span class="mi">2</span> ^ Z.of_nat n +
<span class="mi">1</span> *
((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
 mod <span class="mi">2</span> ^ Z.of_nat n) = w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk20c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk20c"><span class="nb">ring_simplify</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ Z.of_nat n +
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n = w</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk20d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk20d"><span class="nb">unfold</span> w.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ Z.of_nat n +
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n =
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk20e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk20e"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n) =
<span class="mi">2</span> ^ Z.of_nat n +
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk20f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk20f"><span class="nb">apply</span> Zdivide_mod_minus.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
<span class="mi">2</span> ^ Z.of_nat n +
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk210" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk210"><hr></label><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n)
| - modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
  (<span class="mi">2</span> ^ Z.of_nat n +
   (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk211" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk211">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
<span class="mi">2</span> ^ Z.of_nat n +
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk212" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk212"><span class="nb">specialize</span> (Hbound ((-modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;=
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
<span class="mi">2</span> ^ Z.of_nat n +
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat (S n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk213" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk213"><span class="nb">replace</span> (Z.of_nat (S n)) <span class="kr">with</span> (<span class="mi">1</span> + Z.of_nat n) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;=
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">0</span> &lt;=
<span class="mi">2</span> ^ Z.of_nat n +
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ (<span class="mi">1</span> + Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> Z.pow_add_r; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk214" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk214">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n)
| - modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
  (<span class="mi">2</span> ^ Z.of_nat n +
   (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n))</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk215" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk215"><span class="nb">set</span> (w0 := (-modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st) mod <span class="mi">2</span> ^ Z.of_nat n) <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n)
| - modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
  (<span class="mi">2</span> ^ Z.of_nat n + w0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk216" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk216"><span class="nb">apply</span> Z.mod_divide; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
 (<span class="mi">2</span> ^ Z.of_nat n + w0)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk217" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk217"><span class="nb">rewrite</span> &lt;- Zminus_mod_idemp_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
 (<span class="mi">2</span> ^ Z.of_nat n + w0) mod <span class="mi">2</span> ^ Z.of_nat (S n))
mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk218" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk218"><span class="nb">replace</span> (<span class="mi">2</span> ^ Z.of_nat n + w0) <span class="kr">with</span> (<span class="mi">1</span> * (<span class="mi">2</span> ^ Z.of_nat n + w0)) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
 (<span class="mi">1</span> * (<span class="mi">2</span> ^ Z.of_nat n + w0)) mod <span class="mi">2</span> ^ Z.of_nat (S n))
mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk219" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk219"><span class="nb">rewrite</span> &lt;- Zmult_mod_idemp_l, &lt;- (Hgcd (Z.of_nat (S n))) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
 (Z.gcd (f st) (<span class="mi">2</span> ^ Z.of_nat (S n))
  mod <span class="mi">2</span> ^ Z.of_nat (S n) * (<span class="mi">2</span> ^ Z.of_nat n + w0))
 mod <span class="mi">2</span> ^ Z.of_nat (S n)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk21a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk21a"><span class="nb">rewrite</span> &lt;- modInv_mul_l, Zmult_mod_idemp_l, Zminus_mod_idemp_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st -
 modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * f st *
 (<span class="mi">2</span> ^ Z.of_nat n + w0)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk21b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk21b"><span class="nb">replace</span> (-modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st
   - modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * f st
       * (<span class="mi">2</span> ^ Z.of_nat n + w0)) <span class="kr">with</span>
       (-modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
        (<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st + (w0 * f st + <span class="mi">1</span> * g st)))
       <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st +
  (w0 * f st + <span class="mi">1</span> * g st))) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk21c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk21c"><span class="nb">assert</span> (HtransN := transN_step n st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>HtransN</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n)
  (fg (fst (stepN n st))) =
ap (transN n st) (fg st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st +
  (w0 * f st + <span class="mi">1</span> * g st))) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk21d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk21d"><span class="nb">rewrite</span> &lt;- Hst&#39;0, IHn1 <span class="kr">in</span> HtransN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>HtransN</var><span class="hyp-type"><b>: </b><span>scale (<span class="mi">2</span> ^ Z.of_nat n)
  (fg
     {|
       delta := d;
       f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
       g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       oddF := Zodd_2p_plus_1 f&#39;
     |}) =
ap
  {|
    u := <span class="mi">2</span> ^ Z.of_nat n;
    v := <span class="mi">0</span>;
    q := w0;
    r := <span class="mi">1</span>
  |} (fg st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st +
  (w0 * f st + <span class="mi">1</span> * g st))) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk21e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk21e"><span class="nb">unfold</span> fg, scale, ap <span class="kr">in</span> HtransN;
      <span class="nb">simpl</span> <span class="kr">in</span> HtransN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>HtransN</var><span class="hyp-type"><b>: </b><span>{|
  x := <span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>);
  y := <span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)
|} =
{|
  x := <span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st;
  y := w0 * f st + <span class="mi">1</span> * g st
|}</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st +
  (w0 * f st + <span class="mi">1</span> * g st))) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk21f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk21f"><span class="nb">injection</span> HtransN; <span class="nb">clear</span> HtransN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) = w0 * f st + <span class="mi">1</span> * g st -&gt;
<span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st -&gt;
(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st +
  (w0 * f st + <span class="mi">1</span> * g st))) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk220" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk220"><span class="nb">intros</span> Hg&#39; Hf&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) =
w0 * f st + <span class="mi">1</span> * g st</span></span></span><br><span><var>Hf'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st +
  (w0 * f st + <span class="mi">1</span> * g st))) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk221" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk221"><span class="nb">rewrite</span> &lt;- Hg&#39;, &lt;- Hf&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) =
w0 * f st + <span class="mi">1</span> * g st</span></span></span><br><span><var>Hf'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 (<span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) +
  <span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)))
mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk222" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk222"><span class="nb">replace</span> (<span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) + <span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>))
         <span class="kr">with</span> ((f&#39; + g&#39; + <span class="mi">1</span>) * (<span class="mi">2</span> ^ Z.of_nat n * <span class="mi">2</span>^<span class="mi">1</span>)) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) =
w0 * f st + <span class="mi">1</span> * g st</span></span></span><br><span><var>Hf'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) *
 ((f&#39; + g&#39; + <span class="mi">1</span>) * (<span class="mi">2</span> ^ Z.of_nat n * <span class="mi">2</span> ^ <span class="mi">1</span>)))
mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk223" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk223"><span class="nb">rewrite</span> &lt;- Z.pow_add_r, Z.mul_assoc <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) =
w0 * f st + <span class="mi">1</span> * g st</span></span></span><br><span><var>Hf'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * (f&#39; + g&#39; + <span class="mi">1</span>) *
 <span class="mi">2</span> ^ (Z.of_nat n + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk224" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk224"><span class="nb">replace</span> (Z.of_nat n + <span class="mi">1</span>) <span class="kr">with</span> (Z.of_nat (S n)) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>w0</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
mod <span class="mi">2</span> ^ Z.of_nat n</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n; v := <span class="mi">0</span>; q := w0; r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n | f st * w0 + g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br><span><var>Hg'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>) =
w0 * f st + <span class="mi">1</span> * g st</span></span></span><br><span><var>Hf'</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>) =
<span class="mi">2</span> ^ Z.of_nat n * f st + <span class="mi">0</span> * g st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * (f&#39; + g&#39; + <span class="mi">1</span>) *
 <span class="mi">2</span> ^ Z.of_nat (S n)) mod <span class="mi">2</span> ^ Z.of_nat (S n) = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Z_mod_mult.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk225" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk225">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk226" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk226">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39; + f&#39; + <span class="mi">1</span>;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.S :: nil)) = Z.of_nat (S n) + delta st</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk227" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk227"><span class="nb">replace</span> (Z.of_nat (S n) + delta st)
    <span class="kr">with</span> (<span class="mi">1</span> + (Z.of_nat n + delta st)) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39; + f&#39; + <span class="mi">1</span>;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.S :: nil)) =
<span class="mi">1</span> + (Z.of_nat n + delta st)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk228" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk228"><span class="nb">rewrite</span> &lt;- IHn3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">delta
  (fst
     ({|
        delta := INC + d;
        f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
        g := g&#39; + f&#39; + <span class="mi">1</span>;
        oddF := Zodd_2p_plus_1 f&#39;
      |}, Step.S :: nil)) =
<span class="mi">1</span> + delta (fst (stepN n st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk229" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk229"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">INC + d = <span class="mi">1</span> + delta (fst (stepN n st))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk22a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk22a"><span class="nb">rewrite</span> &lt;- Hst&#39;0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span>delta st &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hrel_prime</var><span class="hyp-type"><b>: </b><span>rel_prime (f st) <span class="mi">2</span></span></span></span><br><span><var>Hgcd</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : Z,
<span class="mi">0</span> &lt;= x -&gt; Z.gcd (f st) (<span class="mi">2</span> ^ x) = <span class="mi">1</span></span></span></span><br><span><var>w</var><span><span class="hyp-body"><b>:= </b><span>(- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * g st)
mod <span class="mi">2</span> ^ Z.of_nat (S n)</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> - delta st</span></span></span><br><span><var>IHn1</var><span class="hyp-type"><b>: </b><span>transN n st =
{|
  u := <span class="mi">2</span> ^ Z.of_nat n;
  v := <span class="mi">0</span>;
  q :=
    (- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
    mod <span class="mi">2</span> ^ Z.of_nat n;
  r := <span class="mi">1</span>
|}</span></span></span><br><span><var>IHn2</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat n
| f st *
  ((- modInv (f st) (<span class="mi">2</span> ^ Z.of_nat n) * g st)
   mod <span class="mi">2</span> ^ Z.of_nat n) + 
  g st)</span></span></span><br><span><var>IHn3</var><span class="hyp-type"><b>: </b><span>delta (fst (stepN n st)) =
Z.of_nat n + delta st</span></span></span><br><span><var>st'</var><span><span class="hyp-body"><b>:= </b><span>fst (stepN n st)</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hbound</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
<span class="mi">0</span> &lt;= a mod <span class="mi">2</span> ^ Z.of_nat n &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> ^ Z.of_nat (S n) | f st * w + g st)</span></span></span><br><span><var>d, f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hst'</var><span class="hyp-type"><b>: </b><span>d &lt;= <span class="mi">0</span></span></span></span><br><span><var>Hst'0</var><span class="hyp-type"><b>: </b><span>{|
  delta := d;
  f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
  g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 f&#39;
|} = fst (stepN n st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">INC + d =
<span class="mi">1</span> +
delta
  {|
    delta := d;
    f := <span class="mi">2</span> * f&#39; + <span class="mi">1</span>;
    g := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
    oddF := Zodd_2p_plus_1 f&#39;
  |}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk22b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk22b"><span class="kn">Lemma</span> <span class="nf">transDs</span> <span class="nv">n</span> <span class="nv">st</span> : Zodd (g st) -&gt; <span class="mi">0</span> &lt; delta st -&gt; <span class="mi">0</span> &lt; Z.of_nat n &lt;= <span class="mi">1</span> + delta st -&gt;
  transN n st = {| u := <span class="mi">0</span>; v := <span class="mi">2</span>^(Z.of_nat n); 
    q := -<span class="mi">1</span>; r := (modInv (-g st) (<span class="mi">2</span>^(Z.of_nat n)) * (-f st)) mod (<span class="mi">2</span>^(Z.of_nat n)) |}.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd (g st) -&gt;
<span class="mi">0</span> &lt; delta st -&gt;
<span class="mi">0</span> &lt; Z.of_nat n &lt;= <span class="mi">1</span> + delta st -&gt;
transN n st =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat n;
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- g st) (<span class="mi">2</span> ^ Z.of_nat n) * - f st)
    mod <span class="mi">2</span> ^ Z.of_nat n
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk22c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk22c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd (g st) -&gt;
<span class="mi">0</span> &lt; delta st -&gt;
<span class="mi">0</span> &lt; Z.of_nat n &lt;= <span class="mi">1</span> + delta st -&gt;
transN n st =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat n;
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- g st) (<span class="mi">2</span> ^ Z.of_nat n) * - f st)
    mod <span class="mi">2</span> ^ Z.of_nat n
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk22d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk22d"><span class="nb">intros</span> Hodd Hdelta [Hn0 Hn].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (g st)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; delta st</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat n</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat n &lt;= <span class="mi">1</span> + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN n st =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat n;
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- g st) (<span class="mi">2</span> ^ Z.of_nat n) * - f st)
    mod <span class="mi">2</span> ^ Z.of_nat n
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk22e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk22e"><span class="nb">destruct</span> n;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (g st)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; delta st</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">transN (S n) st =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (S n);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- g st) (<span class="mi">2</span> ^ Z.of_nat (S n)) * - f st)
    mod <span class="mi">2</span> ^ Z.of_nat (S n)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk22f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk22f"><span class="nb">rewrite</span> &lt;- Nat.add_1_r, &lt;- transN_stepN.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (g st)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; delta st</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul (transN n (fst (stepN <span class="mi">1</span> st))) (transN <span class="mi">1</span> st) =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- g st) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) * - f st)
    mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk230" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk230"><span class="nb">unfold</span> transN <span class="nb">at</span> <span class="mi">2</span>; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (g st)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; delta st</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + delta st</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (transN n
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st <span class="kr">in</span> (st1, x :: nil))))
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st <span class="kr">in</span> (st1, x :: nil))))) =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- g st) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) * - f st)
    mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk231" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk231"><span class="nb">revert</span> Hodd Hdelta Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd (g st) -&gt;
<span class="mi">0</span> &lt; delta st -&gt;
Z.of_nat (S n) &lt;= <span class="mi">1</span> + delta st -&gt;
mul
  (transN n
     (fst (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st <span class="kr">in</span> (st1, x :: nil))))
  (prod
     (map trans
        (snd
           (<span class="kr">let</span> (<span class="nv">st1</span>, x) := step st <span class="kr">in</span> (st1, x :: nil))))) =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- g st) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) * - f st)
    mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk232" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk232"><span class="nb">elim</span> (spec);<span class="nb">cbn</span>;<span class="nb">intros</span> d f&#39; g&#39; Hodd Hdelta Hn;
[<span class="nb">elim</span> (Zeven_not_Zodd _ (Zeven_2p _) Hodd)| |<span class="bp">lia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.pos d</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.pos (Pos.of_succ_nat n) &lt;=
Z.pos
  <span class="kr">match</span> d <span class="kr">with</span>
  | q~<span class="mi">1</span> =&gt; (Pos.succ q)~<span class="mi">0</span>
  | q~<span class="mi">0</span> =&gt; q~<span class="mi">1</span>
  | <span class="mi">1</span> =&gt; <span class="mi">2</span>
  <span class="kr">end</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (transN n
     {|
       delta := Z.pos_sub <span class="mi">1</span> d;
       f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       g := g&#39; - f&#39;;
       oddF := Zodd_2p_plus_1 g&#39;
     |}) (mul {| u := <span class="mi">0</span>; v := <span class="mi">2</span>; q := -<span class="mi">1</span>; r := <span class="mi">1</span> |} I) =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk233" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk233"><span class="nb">change</span> (Z.of_nat (S n) &lt;= <span class="mi">1</span> + Z.pos d) <span class="kr">in</span> Hn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.pos d</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + Z.pos d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (transN n
     {|
       delta := Z.pos_sub <span class="mi">1</span> d;
       f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       g := g&#39; - f&#39;;
       oddF := Zodd_2p_plus_1 g&#39;
     |}) (mul {| u := <span class="mi">0</span>; v := <span class="mi">2</span>; q := -<span class="mi">1</span>; r := <span class="mi">1</span> |} I) =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk234" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk234"><span class="nb">change</span> (Z.pos_sub <span class="mi">1</span> d) <span class="kr">with</span> (<span class="mi">1</span> - Z.pos d).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>d</var><span class="hyp-type"><b>: </b><span>positive</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.pos d</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + Z.pos d</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (transN n
     {|
       delta := <span class="mi">1</span> - Z.pos d;
       f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       g := g&#39; - f&#39;;
       oddF := Zodd_2p_plus_1 g&#39;
     |}) (mul {| u := <span class="mi">0</span>; v := <span class="mi">2</span>; q := -<span class="mi">1</span>; r := <span class="mi">1</span> |} I) =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk235" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk235"><span class="nb">set</span> (dZ := Z.pos d) <span class="kr">in</span> *; <span class="nb">clearbody</span> dZ; <span class="nb">clear</span> d.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (transN n
     {|
       delta := <span class="mi">1</span> - dZ;
       f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       g := g&#39; - f&#39;;
       oddF := Zodd_2p_plus_1 g&#39;
     |}) (mul {| u := <span class="mi">0</span>; v := <span class="mi">2</span>; q := -<span class="mi">1</span>; r := <span class="mi">1</span> |} I) =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk236" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk236"><span class="nb">change</span> (mul {| u := <span class="mi">0</span>; v := <span class="mi">2</span>; q := -<span class="mi">1</span>; r := <span class="mi">1</span> |} I)
 <span class="kr">with</span> (mul (trans Step.S) {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (transN n
     {|
       delta := <span class="mi">1</span> - dZ;
       f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
       g := g&#39; - f&#39;;
       oddF := Zodd_2p_plus_1 g&#39;
     |})
  (mul (trans Step.S)
     {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |}) =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk237" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk237"><span class="nb">rewrite</span> !mul_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (mul
     (transN n
        {|
          delta := <span class="mi">1</span> - dZ;
          f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
          g := g&#39; - f&#39;;
          oddF := Zodd_2p_plus_1 g&#39;
        |}) (trans Step.S))
  {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |} =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk238" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk238"><span class="nb">clear</span> st.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (mul
     (transN n
        {|
          delta := <span class="mi">1</span> - dZ;
          f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
          g := g&#39; - f&#39;;
          oddF := Zodd_2p_plus_1 g&#39;
        |}) (trans Step.S))
  {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |} =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk239" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk239"><span class="nb">pose</span> (st0 := {| delta := - dZ;
                f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
                g := - <span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
                oddF := Zodd_2p_plus_1 g&#39; |}).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (mul
     (transN n
        {|
          delta := <span class="mi">1</span> - dZ;
          f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
          g := g&#39; - f&#39;;
          oddF := Zodd_2p_plus_1 g&#39;
        |}) (trans Step.S))
  {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |} =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk23a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk23a"><span class="nb">set</span> (st1 := Build_State _ _ _ _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul (mul (transN n st1) (trans Step.S))
  {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |} =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk23b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk23b"><span class="nb">assert</span> (Hst01 : step st0 = (st1, Step.S)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">step st0 = (st1, Step.S)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk23c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hst01</var><span class="hyp-type"><b>: </b><span>step st0 = (st1, Step.S)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk23c"><hr></label><div class="goal-conclusion">mul (mul (transN n st1) (trans Step.S))
  {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |} =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod 
    <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk23d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk23d"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">step st0 = (st1, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk23e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk23e"><span class="nb">unfold</span> step.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> Zeven_odd_dec (g st0) <span class="kr">with</span>
| <span class="nb">left</span> _ =&gt;
    ({|
       delta := INC + delta st0;
       f := f st0;
       g := g st0 / <span class="mi">2</span>;
       oddF := oddF st0
     |}, Step.H)
| <span class="nb">right</span> oddG =&gt;
    <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st0
    <span class="kr">then</span>
     ({|
        delta := INC - delta st0;
        f := g st0;
        g := (g st0 - f st0) / <span class="mi">2</span>;
        oddF := oddG
      |}, Step.D)
    <span class="kr">else</span>
     ({|
        delta := INC + delta st0;
        f := f st0;
        g := (g st0 + f st0) / <span class="mi">2</span>;
        oddF := oddF st0
      |}, Step.S)
<span class="kr">end</span> = (st1, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk23f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk23f"><span class="nb">assert</span> (Hoddg : Zodd (g st0)) <span class="bp">by</span>
   (<span class="nb">replace</span> (g st0) <span class="kr">with</span> (<span class="mi">2</span>*(-f&#39; - <span class="mi">1</span>) + <span class="mi">1</span>) <span class="bp">by</span> (<span class="nb">cbn</span>;<span class="bp">ring</span>); <span class="nb">apply</span> Zodd_2p_plus_1).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hoddg</var><span class="hyp-type"><b>: </b><span>Zodd (g st0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> Zeven_odd_dec (g st0) <span class="kr">with</span>
| <span class="nb">left</span> _ =&gt;
    ({|
       delta := INC + delta st0;
       f := f st0;
       g := g st0 / <span class="mi">2</span>;
       oddF := oddF st0
     |}, Step.H)
| <span class="nb">right</span> oddG =&gt;
    <span class="kr">if</span> <span class="mi">0</span> &lt;? delta st0
    <span class="kr">then</span>
     ({|
        delta := INC - delta st0;
        f := g st0;
        g := (g st0 - f st0) / <span class="mi">2</span>;
        oddF := oddG
      |}, Step.D)
    <span class="kr">else</span>
     ({|
        delta := INC + delta st0;
        f := f st0;
        g := (g st0 + f st0) / <span class="mi">2</span>;
        oddF := oddF st0
      |}, Step.S)
<span class="kr">end</span> = (st1, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk240" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk240"><span class="nb">destruct</span> Zeven_odd_dec <span class="kr">as</span> [Heveng&#39;|Hoddg&#39;];
  [<span class="nb">elim</span> (Zodd_not_Zeven _ Hoddg Heveng&#39;)|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hoddg, Hoddg'</var><span class="hyp-type"><b>: </b><span>Zodd (g st0)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">if</span> <span class="mi">0</span> &lt;? delta st0
 <span class="kr">then</span>
  ({|
     delta := INC - delta st0;
     f := g st0;
     g := (g st0 - f st0) / <span class="mi">2</span>;
     oddF := Hoddg&#39;
   |}, Step.D)
 <span class="kr">else</span>
  ({|
     delta := INC + delta st0;
     f := f st0;
     g := (g st0 + f st0) / <span class="mi">2</span>;
     oddF := oddF st0
   |}, Step.S)) = (st1, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk241" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk241"><span class="nb">elim</span> (Z.ltb_spec); <span class="nb">intros</span> Hd0; <span class="nb">cbn</span> <span class="kr">in</span> Hd0; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hoddg, Hoddg'</var><span class="hyp-type"><b>: </b><span>Zodd (g st0)</span></span></span><br><span><var>Hd0</var><span class="hyp-type"><b>: </b><span>- dZ &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({|
   delta := INC + delta st0;
   f := f st0;
   g := (g st0 + f st0) / <span class="mi">2</span>;
   oddF := oddF st0
 |}, Step.S) = (st1, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk242" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk242"><span class="nb">simpl</span> (g st0 + f st0).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hoddg, Hoddg'</var><span class="hyp-type"><b>: </b><span>Zodd (g st0)</span></span></span><br><span><var>Hd0</var><span class="hyp-type"><b>: </b><span>- dZ &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({|
   delta := INC + delta st0;
   f := f st0;
   g := (-<span class="mi">2</span> * f&#39; - <span class="mi">1</span> + (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) / <span class="mi">2</span>;
   oddF := oddF st0
 |}, Step.S) = (st1, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk243" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk243"><span class="nb">replace</span> (-<span class="mi">2</span> * f&#39; - <span class="mi">1</span> + (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) <span class="kr">with</span> ((g&#39; - f&#39;)*<span class="mi">2</span>) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hoddg, Hoddg'</var><span class="hyp-type"><b>: </b><span>Zodd (g st0)</span></span></span><br><span><var>Hd0</var><span class="hyp-type"><b>: </b><span>- dZ &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({|
   delta := INC + delta st0;
   f := f st0;
   g := (g&#39; - f&#39;) * <span class="mi">2</span> / <span class="mi">2</span>;
   oddF := oddF st0
 |}, Step.S) = (st1, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk244" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk244"><span class="nb">rewrite</span> Z_div_mult <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hoddg, Hoddg'</var><span class="hyp-type"><b>: </b><span>Zodd (g st0)</span></span></span><br><span><var>Hd0</var><span class="hyp-type"><b>: </b><span>- dZ &lt;= <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">({|
   delta := INC + delta st0;
   f := f st0;
   g := g&#39; - f&#39;;
   oddF := oddF st0
 |}, Step.S) = (st1, Step.S)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk245" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk245">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hst01</var><span class="hyp-type"><b>: </b><span>step st0 = (st1, Step.S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul (mul (transN n st1) (trans Step.S))
  {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |} =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk246" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk246"><span class="nb">replace</span> (trans Step.S) <span class="kr">with</span> (transN <span class="mi">1</span> st0)
 <span class="bp">by</span> (<span class="nb">unfold</span> transN;<span class="nb">cbn</span>;<span class="nb">rewrite</span> Hst01;<span class="bp">reflexivity</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hst01</var><span class="hyp-type"><b>: </b><span>step st0 = (st1, Step.S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul (mul (transN n st1) (transN <span class="mi">1</span> st0))
  {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |} =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk247" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk247"><span class="nb">replace</span> st1 <span class="kr">with</span> (fst (stepN <span class="mi">1</span> st0)) <span class="bp">by</span> (<span class="nb">unfold</span> transN;<span class="nb">cbn</span>;<span class="nb">rewrite</span> Hst01;<span class="bp">reflexivity</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hst01</var><span class="hyp-type"><b>: </b><span>step st0 = (st1, Step.S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  (mul (transN n (fst (stepN <span class="mi">1</span> st0))) (transN <span class="mi">1</span> st0))
  {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |} =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk248" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk248"><span class="nb">rewrite</span> transN_stepN, transSs; <span class="nb">cbn</span>; <span class="kp">try</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hst01</var><span class="hyp-type"><b>: </b><span>step st0 = (st1, Step.S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">mul
  {|
    u := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
    v := <span class="mi">0</span>;
    q :=
      (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
       (-<span class="mi">2</span> * f&#39; - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
    r := <span class="mi">1</span>
  |} {| u := <span class="mi">0</span>; v := <span class="mi">1</span>; q := -<span class="mi">1</span>; r := <span class="mi">0</span> |} =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk249" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk249"><span class="nb">unfold</span> mul; <span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hst01</var><span class="hyp-type"><b>: </b><span>step st0 = (st1, Step.S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">{|
  u := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>) * <span class="mi">0</span> + <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>) * <span class="mi">1</span> + <span class="mi">0</span>;
  q :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     (-<span class="mi">2</span> * f&#39; - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>) * <span class="mi">0</span> + -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     (-<span class="mi">2</span> * f&#39; - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>) * <span class="mi">1</span> + <span class="mi">0</span>
|} =
{|
  u := <span class="mi">0</span>;
  v := <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>);
  q := -<span class="mi">1</span>;
  r :=
    (modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
     - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)
|}</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk24a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk24a"><span class="nb">f_equal</span>; <span class="kp">try</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hst01</var><span class="hyp-type"><b>: </b><span>step st0 = (st1, Step.S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
 (-<span class="mi">2</span> * f&#39; - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>) * <span class="mi">1</span> + <span class="mi">0</span> =
(modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
 - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk24b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk24b"><span class="nb">ring_simplify</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hst01</var><span class="hyp-type"><b>: </b><span>step st0 = (st1, Step.S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
 (-<span class="mi">2</span> * f&#39; - <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>) =
(modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
 - (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)) mod <span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk24c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk24c"><span class="kp">do</span> <span class="mi">1</span> <span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hn0</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; Z.of_nat (S n)</span></span></span><br><span><var>f', g'</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hodd</var><span class="hyp-type"><b>: </b><span>Zodd (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)</span></span></span><br><span><var>dZ</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hdelta</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; dZ</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span>Z.of_nat (S n) &lt;= <span class="mi">1</span> + dZ</span></span></span><br><span><var>st0</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := -<span class="mi">2</span> * f&#39; - <span class="mi">1</span>;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>st1</var><span><span class="hyp-body"><b>:= </b><span>{|
  delta := <span class="mi">1</span> - dZ;
  f := <span class="mi">2</span> * g&#39; + <span class="mi">1</span>;
  g := g&#39; - f&#39;;
  oddF := Zodd_2p_plus_1 g&#39;
|}</span></span><span class="hyp-type"><b>: </b><span>State</span></span></span></span><br><span><var>Hst01</var><span class="hyp-type"><b>: </b><span>step st0 = (st1, Step.S)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
(-<span class="mi">2</span> * f&#39; - <span class="mi">1</span>) =
modInv (- (<span class="mi">2</span> * g&#39; + <span class="mi">1</span>)) (<span class="mi">2</span> ^ Z.of_nat (n + <span class="mi">1</span>)) *
- (<span class="mi">2</span> * f&#39; + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">Trans</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">pre_div62Modulo</span> (<span class="nv">M</span> <span class="nv">a</span> : Z) : Z :=
  a - (((modInv M (<span class="mi">2</span>^<span class="mi">62</span>))*a) mod <span class="mi">2</span>^<span class="mi">62</span>) * M.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk24d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk24d"><span class="kn">Lemma</span> <span class="nf">pre_div62Modulo_mod</span> (<span class="nv">M</span> <span class="nv">a</span> : Z) : pre_div62Modulo M a mod M = a mod M.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pre_div62Modulo M a mod M = a mod M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk24e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk24e"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pre_div62Modulo M a mod M = a mod M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk24f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk24f"><span class="nb">unfold</span> pre_div62Modulo, Z.sub.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a + - ((modInv M (<span class="mi">2</span> ^ <span class="mi">62</span>) * a) mod <span class="mi">2</span> ^ <span class="mi">62</span> * M)) mod M =
a mod M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk250" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk250"><span class="nb">rewrite</span> &lt;- Z.mul_opp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a + - ((modInv M (<span class="mi">2</span> ^ <span class="mi">62</span>) * a) mod <span class="mi">2</span> ^ <span class="mi">62</span>) * M) mod M =
a mod M</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Z_mod_plus_full.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk251" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk251"><span class="kn">Lemma</span> <span class="nf">pre_div62Modulo_divide</span> <span class="nv">M</span> <span class="nv">a</span> : Zodd M -&gt; (<span class="mi">2</span>^<span class="mi">62</span> | pre_div62Modulo M a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd M -&gt; (<span class="mi">2</span> ^ <span class="mi">62</span> | pre_div62Modulo M a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk252" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk252"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd M -&gt; (<span class="mi">2</span> ^ <span class="mi">62</span> | pre_div62Modulo M a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk253" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk253"><span class="nb">intros</span> HM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="mi">2</span> ^ <span class="mi">62</span> | pre_div62Modulo M a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk254" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk254"><span class="nb">apply</span> Z.mod_divide;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">pre_div62Modulo M a mod <span class="mi">2</span> ^ <span class="mi">62</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk255" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk255"><span class="nb">unfold</span> pre_div62Modulo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a - (modInv M (<span class="mi">2</span> ^ <span class="mi">62</span>) * a) mod <span class="mi">2</span> ^ <span class="mi">62</span> * M)
mod <span class="mi">2</span> ^ <span class="mi">62</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk256" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk256"><span class="nb">rewrite</span> &lt;- Zminus_mod_idemp_r, Zmult_mod_idemp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a - (modInv M (<span class="mi">2</span> ^ <span class="mi">62</span>) * a * M) mod <span class="mi">2</span> ^ <span class="mi">62</span>)
mod <span class="mi">2</span> ^ <span class="mi">62</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk257" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk257"><span class="nb">replace</span> (modInv M (<span class="mi">2</span> ^ <span class="mi">62</span>) * a * M) <span class="kr">with</span> (modInv M (<span class="mi">2</span> ^ <span class="mi">62</span>) * M * a) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a - (modInv M (<span class="mi">2</span> ^ <span class="mi">62</span>) * M * a) mod <span class="mi">2</span> ^ <span class="mi">62</span>)
mod <span class="mi">2</span> ^ <span class="mi">62</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk258" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk258"><span class="nb">rewrite</span> &lt;- Zmult_mod_idemp_l, modInv_mul_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(a - (Z.gcd M (<span class="mi">2</span> ^ <span class="mi">62</span>) mod <span class="mi">2</span> ^ <span class="mi">62</span> * a) mod <span class="mi">2</span> ^ <span class="mi">62</span>)
mod <span class="mi">2</span> ^ <span class="mi">62</span> = <span class="mi">0</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk259" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk259"><span class="nb">replace</span> (Z.gcd M (<span class="mi">2</span> ^ <span class="mi">62</span>)) <span class="kr">with</span> <span class="mi">1</span>;
[<span class="nb">rewrite</span> Z.mul_1_l, Zminus_mod_idemp_r, Z.sub_diag; <span class="bp">reflexivity</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> = Z.gcd M (<span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk25a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk25a"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.gcd M (<span class="mi">2</span> ^ <span class="mi">62</span>) = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk25b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk25b"><span class="nb">apply</span> Zgcd_1_rel_prime.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime M (<span class="mi">2</span> ^ <span class="mi">62</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk25c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk25c"><span class="nb">apply</span> Zpow_facts.rel_prime_Zpower_r;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime M <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk25d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk25d"><span class="nb">apply</span> Zgcd_1_rel_prime.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.gcd M <span class="mi">2</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk25e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk25e"><span class="nb">apply</span> Z.bezout_1_gcd.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span>Zodd M</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.Bezout M <span class="mi">2</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk25f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk25f"><span class="nb">apply</span> Zodd_ex_iff <span class="kr">in</span> HM.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HM</var><span class="hyp-type"><b>: </b><span><span class="kr">exists</span> <span class="nv">m</span> : Z, M = <span class="mi">2</span> * m + <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.Bezout M <span class="mi">2</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk260" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk260"><span class="nb">destruct</span> HM <span class="kr">as</span> [m HMm].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HMm</var><span class="hyp-type"><b>: </b><span>M = <span class="mi">2</span> * m + <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.Bezout M <span class="mi">2</span> <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk261" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk261"><span class="kr">exists</span> <span class="mi">1</span>; <span class="kr">exists</span> (-m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>M, a, m</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>HMm</var><span class="hyp-type"><b>: </b><span>M = <span class="mi">2</span> * m + <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">1</span> * M + - m * <span class="mi">2</span> = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">update_de</span> (<span class="nv">M</span> <span class="nv">d</span> <span class="nv">e</span> : Z) (<span class="nv">mtx</span> : Trans.M2x2) : (Z * Z) :=
  <span class="kr">let</span> <span class="nv">vec</span> := Trans.ap mtx
              {| Trans.x := d + <span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> M <span class="kr">else</span> <span class="mi">0</span>
               ; Trans.y := e + <span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> M <span class="kr">else</span> <span class="mi">0</span>
               |} <span class="kr">in</span>
  ( pre_div62Modulo M (Trans.x vec) / <span class="mi">2</span>^<span class="mi">62</span>
  , pre_div62Modulo M (Trans.y vec) / <span class="mi">2</span>^<span class="mi">62</span>
  ).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk262" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk262"><span class="kn">Lemma</span> <span class="nf">update_de_bound</span> <span class="nv">m</span> <span class="nv">d</span> <span class="nv">e</span> <span class="nv">mtx</span> : Zodd m -&gt;
   Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> -&gt;
   Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> -&gt;
   -<span class="mi">2</span> * m &lt; d &lt; m -&gt; -<span class="mi">2</span> * m &lt; e &lt; m -&gt;
   -<span class="mi">2</span> * m &lt; fst (update_de m d e mtx) &lt; m /\ -<span class="mi">2</span> * m &lt; snd (update_de m d e mtx) &lt; m.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd m -&gt;
Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> -&gt;
Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> -&gt;
-<span class="mi">2</span> * m &lt; d &lt; m -&gt;
-<span class="mi">2</span> * m &lt; e &lt; m -&gt;
-<span class="mi">2</span> * m &lt; fst (update_de m d e mtx) &lt; m /\
-<span class="mi">2</span> * m &lt; snd (update_de m d e mtx) &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk263" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk263"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd m -&gt;
Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> -&gt;
Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> -&gt;
-<span class="mi">2</span> * m &lt; d &lt; m -&gt;
-<span class="mi">2</span> * m &lt; e &lt; m -&gt;
-<span class="mi">2</span> * m &lt; fst (update_de m d e mtx) &lt; m /\
-<span class="mi">2</span> * m &lt; snd (update_de m d e mtx) &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk264" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk264"><span class="nb">intros</span> Hoddm Huv Hqr Hmd Hme.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt; fst (update_de m d e mtx) &lt; m /\
-<span class="mi">2</span> * m &lt; snd (update_de m d e mtx) &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk265" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk265"><span class="nb">unfold</span> update_de.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
fst
  (pre_div62Modulo m
     (Trans.x
        (Trans.ap mtx
           {|
             Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
             Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
           |})) / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m
     (Trans.y
        (Trans.ap mtx
           {|
             Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
             Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
           |})) / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m /\
-<span class="mi">2</span> * m &lt;
snd
  (pre_div62Modulo m
     (Trans.x
        (Trans.ap mtx
           {|
             Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
             Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
           |})) / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m
     (Trans.y
        (Trans.ap mtx
           {|
             Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
             Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
           |})) / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk266" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk266"><span class="nb">set</span> (x := Trans.x _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
fst
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m
     (Trans.y
        (Trans.ap mtx
           {|
             Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
             Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
           |})) / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m /\
-<span class="mi">2</span> * m &lt;
snd
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m
     (Trans.y
        (Trans.ap mtx
           {|
             Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
             Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
           |})) / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk267" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk267"><span class="nb">set</span> (y := Trans.y _).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
fst
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m /\
-<span class="mi">2</span> * m &lt;
snd
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk268" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk268"><span class="nb">assert</span> (Hm1 : <span class="mi">1</span> &lt;= m) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
fst
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m /\
-<span class="mi">2</span> * m &lt;
snd
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk269" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk269"><span class="nb">assert</span> (Hxbound : Z.abs x &lt;= <span class="mi">2</span>^<span class="mi">62</span> * (m - <span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk26a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk26a"><hr></label><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
fst
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m /\
-<span class="mi">2</span> * m &lt;
snd
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk26b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk26b"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk26c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk26c"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs
  (Trans.u mtx * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   Trans.v mtx * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) &lt;=
<span class="mi">4611686018427387904</span> * (m - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk26d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk26d"><span class="nb">eapply</span> Z.le_trans;[<span class="nb">apply</span> Z.abs_triangle|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (Trans.u mtx * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) +
Z.abs (Trans.v mtx * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) &lt;=
<span class="mi">4611686018427387904</span> * (m - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk26e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk26e"><span class="nb">rewrite</span> !Z.abs_mul.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (Trans.u mtx) *
Z.abs (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
Z.abs (Trans.v mtx) *
Z.abs (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) &lt;=
<span class="mi">4611686018427387904</span> * (m - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk26f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk26f"><span class="nb">apply</span> Z.le_trans <span class="kr">with</span> ((Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx))*(m - <span class="mi">1</span>));[|<span class="bp">nia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (Trans.u mtx) *
Z.abs (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
Z.abs (Trans.v mtx) *
Z.abs (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) &lt;=
(Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx)) * (m - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (Z.ltb_spec0 d <span class="mi">0</span>); <span class="nb">destruct</span> (Z.ltb_spec0 e <span class="mi">0</span>);
  <span class="nb">rewrite</span> Z.mul_add_distr_r; <span class="nb">apply</span> Z.add_le_mono; <span class="nb">apply</span> Zmult_le_compat_l; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk270" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk270">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
fst
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m /\
-<span class="mi">2</span> * m &lt;
snd
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk271" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk271"><span class="nb">assert</span> (Hybound : Z.abs y &lt;= <span class="mi">2</span>^<span class="mi">62</span> * (m - <span class="mi">1</span>)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk272" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk272"><hr></label><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
fst
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m /\
-<span class="mi">2</span> * m &lt;
snd
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk273" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk273"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk274" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk274"><span class="nb">cbn</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs
  (Trans.q mtx * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   Trans.r mtx * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) &lt;=
<span class="mi">4611686018427387904</span> * (m - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk275" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk275"><span class="nb">eapply</span> Z.le_trans;[<span class="nb">apply</span> Z.abs_triangle|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (Trans.q mtx * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) +
Z.abs (Trans.r mtx * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) &lt;=
<span class="mi">4611686018427387904</span> * (m - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk276" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk276"><span class="nb">rewrite</span> !Z.abs_mul.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (Trans.q mtx) *
Z.abs (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
Z.abs (Trans.r mtx) *
Z.abs (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) &lt;=
<span class="mi">4611686018427387904</span> * (m - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk277" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk277"><span class="nb">apply</span> Z.le_trans <span class="kr">with</span> ((Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx))*(m - <span class="mi">1</span>));[|<span class="bp">nia</span>].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.abs (Trans.q mtx) *
Z.abs (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
Z.abs (Trans.r mtx) *
Z.abs (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) &lt;=
(Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx)) * (m - <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> (Z.ltb_spec0 d <span class="mi">0</span>); <span class="nb">destruct</span> (Z.ltb_spec0 e <span class="mi">0</span>);
  <span class="nb">rewrite</span> Z.mul_add_distr_r; <span class="nb">apply</span> Z.add_le_mono; <span class="nb">apply</span> Zmult_le_compat_l; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk278" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk278">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
fst
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m /\
-<span class="mi">2</span> * m &lt;
snd
  (pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span>,
   pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span>) &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk279" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk279"><span class="nb">cbn</span> -[Z.div Z.pow x y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt; pre_div62Modulo m x / <span class="mi">2</span> ^ <span class="mi">62</span> &lt; m /\
-<span class="mi">2</span> * m &lt; pre_div62Modulo m y / <span class="mi">2</span> ^ <span class="mi">62</span> &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk27a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk27a"><span class="nb">unfold</span> pre_div62Modulo.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
(x - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m) / <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
m /\
-<span class="mi">2</span> * m &lt;
(y - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m) / <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk27b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk27b"><span class="nb">assert</span> (Hxmod : <span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt; <span class="mi">2</span>^<span class="mi">62</span>) <span class="bp">by</span> (<span class="nb">apply</span> Z.mod_pos_bound;<span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hxmod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
(x - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m) / <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
m /\
-<span class="mi">2</span> * m &lt;
(y - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m) / <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk27c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk27c"><span class="nb">assert</span> (Hymod : <span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt; <span class="mi">2</span>^<span class="mi">62</span>) <span class="bp">by</span> (<span class="nb">apply</span> Z.mod_pos_bound;<span class="bp">lia</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hxmod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hymod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
(x - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m) / <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
m /\
-<span class="mi">2</span> * m &lt;
(y - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m) / <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk27d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk27d"><span class="nb">rewrite</span> &lt;- !Z.shiftr_div_pow2 <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hxmod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hymod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
Z.shiftr (x - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m)
  <span class="mi">62</span> &lt; m /\
-<span class="mi">2</span> * m &lt;
Z.shiftr (y - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m)
  <span class="mi">62</span> &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk27e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk27e"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hxmod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hymod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
Z.shiftr (x - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m)
  <span class="mi">62</span> &lt; m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk27f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hxmod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hymod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br></div><label class="goal-separator" for="divstep-v-chk27f"><hr></label><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
Z.shiftr (y - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m)
  <span class="mi">62</span> &lt; m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk280" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk280">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hxmod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hymod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
Z.shiftr (x - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m)
  <span class="mi">62</span> &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cut</span> (-<span class="mi">2</span>*m + <span class="mi">1</span> &lt;= Z.shiftr (x - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m) <span class="mi">62</span> &lt; m);[<span class="bp">lia</span>|<span class="nb">apply</span> shiftr_bounds;<span class="bp">nia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk281" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk281">*</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>mtx</var><span class="hyp-type"><b>: </b><span>Trans.M2x2</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Huv</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.u mtx) + Z.abs (Trans.v mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hqr</var><span class="hyp-type"><b>: </b><span>Z.abs (Trans.q mtx) + Z.abs (Trans.r mtx) &lt;=
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hmd</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; d &lt; m</span></span></span><br><span><var>Hme</var><span class="hyp-type"><b>: </b><span>-<span class="mi">2</span> * m &lt; e &lt; m</span></span></span><br><span><var>x</var><span><span class="hyp-body"><b>:= </b><span>Trans.x
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>y</var><span><span class="hyp-body"><b>:= </b><span>Trans.y
  (Trans.ap mtx
     {|
       Trans.x := d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
       Trans.y := e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
     |})</span></span><span class="hyp-type"><b>: </b><span>Z</span></span></span></span><br><span><var>Hm1</var><span class="hyp-type"><b>: </b><span><span class="mi">1</span> &lt;= m</span></span></span><br><span><var>Hxbound</var><span class="hyp-type"><b>: </b><span>Z.abs x &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hybound</var><span class="hyp-type"><b>: </b><span>Z.abs y &lt;= <span class="mi">2</span> ^ <span class="mi">62</span> * (m - <span class="mi">1</span>)</span></span></span><br><span><var>Hxmod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * x) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br><span><var>Hymod</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;= (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> &lt;
<span class="mi">2</span> ^ <span class="mi">62</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">-<span class="mi">2</span> * m &lt;
Z.shiftr (y - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m)
  <span class="mi">62</span> &lt; m</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">cut</span> (-<span class="mi">2</span>*m + <span class="mi">1</span> &lt;= Z.shiftr (y - (modInv m (<span class="mi">2</span> ^ <span class="mi">62</span>) * y) mod <span class="mi">2</span> ^ <span class="mi">62</span> * m) <span class="mi">62</span> &lt; m);[<span class="bp">lia</span>|<span class="nb">apply</span> shiftr_bounds;<span class="bp">nia</span>].</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk282" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk282"><span class="kn">Lemma</span> <span class="nf">update_de_eqm</span> <span class="nv">m</span> <span class="nv">x</span> <span class="nv">d</span> <span class="nv">e</span> <span class="nv">st</span> : Zodd m -&gt;
  eqm m (x * d) (f st) -&gt;
  eqm m (x * e) (g st) -&gt;
  eqm m (x * fst (update_de m d e (Trans.transN <span class="mi">62</span> st))) (f (fst (stepN <span class="mi">62</span> st))) /\
  eqm m (x * snd (update_de m d e (Trans.transN <span class="mi">62</span> st))) (g (fst (stepN <span class="mi">62</span> st))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd m -&gt;
eqm m (x * d) (f st) -&gt;
eqm m (x * e) (g st) -&gt;
eqm m (x * fst (update_de m d e (Trans.transN <span class="mi">62</span> st)))
  (f (fst (stepN <span class="mi">62</span> st))) /\
eqm m (x * snd (update_de m d e (Trans.transN <span class="mi">62</span> st)))
  (g (fst (stepN <span class="mi">62</span> st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk283" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk283"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Zodd m -&gt;
eqm m (x * d) (f st) -&gt;
eqm m (x * e) (g st) -&gt;
eqm m (x * fst (update_de m d e (Trans.transN <span class="mi">62</span> st)))
  (f (fst (stepN <span class="mi">62</span> st))) /\
eqm m (x * snd (update_de m d e (Trans.transN <span class="mi">62</span> st)))
  (g (fst (stepN <span class="mi">62</span> st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk284" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk284"><span class="nb">intros</span> Hoddm Hf Hg.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm m (x * fst (update_de m d e (Trans.transN <span class="mi">62</span> st)))
  (f (fst (stepN <span class="mi">62</span> st))) /\
eqm m (x * snd (update_de m d e (Trans.transN <span class="mi">62</span> st)))
  (g (fst (stepN <span class="mi">62</span> st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk285" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk285"><span class="nb">unfold</span> update_de.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm m
  (x *
   fst
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>)) 
  (f (fst (stepN <span class="mi">62</span> st))) /\
eqm m
  (x *
   snd
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>)) 
  (g (fst (stepN <span class="mi">62</span> st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk286" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk286"><span class="nb">generalize</span> (<span class="kr">fun</span> <span class="nv">a</span> =&gt; pre_div62Modulo_divide m a Hoddm).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : Z, (<span class="mi">2</span> ^ <span class="mi">62</span> | pre_div62Modulo m a)) -&gt;
eqm m
  (x *
   fst
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>)) 
  (f (fst (stepN <span class="mi">62</span> st))) /\
eqm m
  (x *
   snd
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>)) 
  (g (fst (stepN <span class="mi">62</span> st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk287" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk287"><span class="nb">generalize</span> (pre_div62Modulo_mod m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">forall</span> <span class="nv">a</span> : Z, pre_div62Modulo m a mod m = a mod m) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : Z, (<span class="mi">2</span> ^ <span class="mi">62</span> | pre_div62Modulo m a)) -&gt;
eqm m
  (x *
   fst
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>)) 
  (f (fst (stepN <span class="mi">62</span> st))) /\
eqm m
  (x *
   snd
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>)) 
  (g (fst (stepN <span class="mi">62</span> st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk288" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk288"><span class="nb">generalize</span> (Trans.transN_step <span class="mi">62</span> st).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Trans.scale (<span class="mi">2</span> ^ Z.of_nat <span class="mi">62</span>)
  (Trans.fg (fst (stepN <span class="mi">62</span> st))) =
Trans.ap (Trans.transN <span class="mi">62</span> st) (Trans.fg st) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : Z, pre_div62Modulo m a mod m = a mod m) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : Z, (<span class="mi">2</span> ^ <span class="mi">62</span> | pre_div62Modulo m a)) -&gt;
eqm m
  (x *
   fst
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>)) 
  (f (fst (stepN <span class="mi">62</span> st))) /\
eqm m
  (x *
   snd
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ <span class="mi">62</span>)) 
  (g (fst (stepN <span class="mi">62</span> st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk289" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk289"><span class="nb">change</span> (<span class="mi">2</span>^<span class="mi">62</span>) <span class="kr">with</span> (<span class="mi">2</span>^Z.of_nat <span class="mi">62</span>).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Trans.scale (<span class="mi">2</span> ^ Z.of_nat <span class="mi">62</span>)
  (Trans.fg (fst (stepN <span class="mi">62</span> st))) =
Trans.ap (Trans.transN <span class="mi">62</span> st) (Trans.fg st) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : Z, pre_div62Modulo m a mod m = a mod m) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : Z, (<span class="mi">2</span> ^ Z.of_nat <span class="mi">62</span> | pre_div62Modulo m a)) -&gt;
eqm m
  (x *
   fst
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat <span class="mi">62</span>,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat <span class="mi">62</span>))
  (f (fst (stepN <span class="mi">62</span> st))) /\
eqm m
  (x *
   snd
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat <span class="mi">62</span>,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN <span class="mi">62</span> st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat <span class="mi">62</span>))
  (g (fst (stepN <span class="mi">62</span> st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk28a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk28a"><span class="nb">generalize</span> <span class="mi">62</span>%nat; <span class="nb">intros</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Trans.scale (<span class="mi">2</span> ^ Z.of_nat n)
  (Trans.fg (fst (stepN n st))) =
Trans.ap (Trans.transN n st) (Trans.fg st) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : Z, pre_div62Modulo m a mod m = a mod m) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : Z, (<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)) -&gt;
eqm m
  (x *
   fst
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n))
  (f (fst (stepN n st))) /\
eqm m
  (x *
   snd
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n))
  (g (fst (stepN n st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk28b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk28b"><span class="nb">intros</span> X; <span class="nb">injection</span> X; <span class="nb">clear</span> X.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
Trans.q (Trans.transN n st) * f st +
Trans.r (Trans.transN n st) * g st -&gt;
<span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
Trans.u (Trans.transN n st) * f st +
Trans.v (Trans.transN n st) * g st -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : Z, pre_div62Modulo m a mod m = a mod m) -&gt;
(<span class="kr">forall</span> <span class="nv">a</span> : Z, (<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)) -&gt;
eqm m
  (x *
   fst
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n))
  (f (fst (stepN n st))) /\
eqm m
  (x *
   snd
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n))
  (g (fst (stepN n st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk28c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk28c"><span class="nb">intros</span> Hgqr Hfuv Hpre1 Hpre2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
Trans.q (Trans.transN n st) * f st +
Trans.r (Trans.transN n st) * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
Trans.u (Trans.transN n st) * f st +
Trans.v (Trans.transN n st) * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm m
  (x *
   fst
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n))
  (f (fst (stepN n st))) /\
eqm m
  (x *
   snd
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap (Trans.transN n st)
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n))
  (g (fst (stepN n st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk28d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk28d"><span class="nb">destruct</span> (Trans.transN n st) <span class="kr">as</span> [u v q r].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
Trans.q
  {|
    Trans.u := u;
    Trans.v := v;
    Trans.q := q;
    Trans.r := r
  |} * f st +
Trans.r
  {|
    Trans.u := u;
    Trans.v := v;
    Trans.q := q;
    Trans.r := r
  |} * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
Trans.u
  {|
    Trans.u := u;
    Trans.v := v;
    Trans.q := q;
    Trans.r := r
  |} * f st +
Trans.v
  {|
    Trans.u := u;
    Trans.v := v;
    Trans.q := q;
    Trans.r := r
  |} * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm m
  (x *
   fst
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap
              {|
                Trans.u := u;
                Trans.v := v;
                Trans.q := q;
                Trans.r := r
              |}
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap
              {|
                Trans.u := u;
                Trans.v := v;
                Trans.q := q;
                Trans.r := r
              |}
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n))
  (f (fst (stepN n st))) /\
eqm m
  (x *
   snd
     (pre_div62Modulo m
        (Trans.x
           (Trans.ap
              {|
                Trans.u := u;
                Trans.v := v;
                Trans.q := q;
                Trans.r := r
              |}
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n,
      pre_div62Modulo m
        (Trans.y
           (Trans.ap
              {|
                Trans.u := u;
                Trans.v := v;
                Trans.q := q;
                Trans.r := r
              |}
              {|
                Trans.x :=
                  d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>);
                Trans.y :=
                  e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)
              |})) / <span class="mi">2</span> ^ Z.of_nat n))
  (g (fst (stepN n st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk28e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk28e"><span class="nb">cbn</span> -[Z.div pre_div62Modulo] <span class="kr">in</span> *.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm m
  (x *
   (pre_div62Modulo m
      (u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
       v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
    <span class="mi">2</span> ^ Z.of_nat n)) (f (fst (stepN n st))) /\
eqm m
  (x *
   (pre_div62Modulo m
      (q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
       r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
    <span class="mi">2</span> ^ Z.of_nat n)) (g (fst (stepN n st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk28f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk28f"><span class="nb">assert</span> (Hn : <span class="mi">0</span> &lt; <span class="mi">2</span>^Z.of_nat n) <span class="bp">by</span> <span class="bp">lia</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm m
  (x *
   (pre_div62Modulo m
      (u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
       v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
    <span class="mi">2</span> ^ Z.of_nat n)) (f (fst (stepN n st))) /\
eqm m
  (x *
   (pre_div62Modulo m
      (q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
       r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
    <span class="mi">2</span> ^ Z.of_nat n)) (g (fst (stepN n st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk290" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk290"><span class="nb">assert</span> (Hinv : modInv (<span class="mi">2</span>^Z.of_nat n) m * (<span class="mi">2</span>^Z.of_nat n) mod m = <span class="mi">1</span> mod m).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n) mod m =
<span class="mi">1</span> mod m</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk291" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk291"><hr></label><div class="goal-conclusion">eqm m
  (x *
   (pre_div62Modulo m
      (u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
       v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
    <span class="mi">2</span> ^ Z.of_nat n)) (f (fst (stepN n st))) /\
eqm m
  (x *
   (pre_div62Modulo m
      (q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
       r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
    <span class="mi">2</span> ^ Z.of_nat n)) (g (fst (stepN n st)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk292" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk292"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n) mod m =
<span class="mi">1</span> mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk293" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk293"><span class="nb">rewrite</span> modInv_mul_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.gcd (<span class="mi">2</span> ^ Z.of_nat n) m mod m = <span class="mi">1</span> mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk294" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk294"><span class="nb">f_equal</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Z.gcd (<span class="mi">2</span> ^ Z.of_nat n) m = <span class="mi">1</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk295" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk295"><span class="nb">rewrite</span> Zgcd_1_rel_prime.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime (<span class="mi">2</span> ^ Z.of_nat n) m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk296" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk296"><span class="nb">apply</span> rel_prime_sym.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime m (<span class="mi">2</span> ^ Z.of_nat n)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk297" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk297"><span class="nb">apply</span> Zpow_facts.rel_prime_Zpower_r;[<span class="bp">lia</span>|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime m <span class="mi">2</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk298" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk298"><span class="nb">apply</span> rel_prime_sym.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">rel_prime <span class="mi">2</span> m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk299" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk299"><span class="nb">apply</span> prime_rel_prime;[<span class="nb">apply</span> prime_2|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (<span class="mi">2</span> | m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk29a" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk29a"><span class="nb">rewrite</span> Zodd_equiv <span class="kr">in</span> Hoddm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Z.Odd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (<span class="mi">2</span> | m)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk29b" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk29b"><span class="nb">destruct</span> Hoddm <span class="kr">as</span> [b -&gt;].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> * b + <span class="mi">1</span>) (x * e) (g st)</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> * b + <span class="mi">1</span>) (x * d) (f st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n
| pre_div62Modulo (<span class="mi">2</span> * b + <span class="mi">1</span>) a)</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo (<span class="mi">2</span> * b + <span class="mi">1</span>) a mod (<span class="mi">2</span> * b + <span class="mi">1</span>) =
a mod (<span class="mi">2</span> * b + <span class="mi">1</span>)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">~ (<span class="mi">2</span> | <span class="mi">2</span> * b + <span class="mi">1</span>)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk29c" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk29c"><span class="nb">intros</span> Hdivide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> * b + <span class="mi">1</span>) (x * e) (g st)</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> * b + <span class="mi">1</span>) (x * d) (f st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n
| pre_div62Modulo (<span class="mi">2</span> * b + <span class="mi">1</span>) a)</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo (<span class="mi">2</span> * b + <span class="mi">1</span>) a mod (<span class="mi">2</span> * b + <span class="mi">1</span>) =
a mod (<span class="mi">2</span> * b + <span class="mi">1</span>)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> | <span class="mi">2</span> * b + <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk29d" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk29d"><span class="nb">apply</span> (Z.divide_add_cancel_r _ _ _ (Z.divide_factor_l _ _)) <span class="kr">in</span> Hdivide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> * b + <span class="mi">1</span>) (x * e) (g st)</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> * b + <span class="mi">1</span>) (x * d) (f st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n
| pre_div62Modulo (<span class="mi">2</span> * b + <span class="mi">1</span>) a)</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo (<span class="mi">2</span> * b + <span class="mi">1</span>) a mod (<span class="mi">2</span> * b + <span class="mi">1</span>) =
a mod (<span class="mi">2</span> * b + <span class="mi">1</span>)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>(<span class="mi">2</span> | <span class="mi">1</span>)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk29e" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk29e"><span class="nb">apply</span> Z.divide_1_r_abs <span class="kr">in</span> Hdivide.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> * b + <span class="mi">1</span>) (x * e) (g st)</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm (<span class="mi">2</span> * b + <span class="mi">1</span>) (x * d) (f st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n
| pre_div62Modulo (<span class="mi">2</span> * b + <span class="mi">1</span>) a)</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo (<span class="mi">2</span> * b + <span class="mi">1</span>) a mod (<span class="mi">2</span> * b + <span class="mi">1</span>) =
a mod (<span class="mi">2</span> * b + <span class="mi">1</span>)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hdivide</var><span class="hyp-type"><b>: </b><span>Z.abs <span class="mi">2</span> = <span class="mi">1</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">False</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">discriminate</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk29f" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk29f">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm m
  (x *
   (pre_div62Modulo m
      (u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
       v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
    <span class="mi">2</span> ^ Z.of_nat n)) (f (fst (stepN n st))) /\
eqm m
  (x *
   (pre_div62Modulo m
      (q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
       r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
    <span class="mi">2</span> ^ Z.of_nat n)) (g (fst (stepN n st)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2a0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2a0"><span class="nb">unfold</span> eqm.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x *
 (pre_div62Modulo m
    (u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
     v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
  <span class="mi">2</span> ^ Z.of_nat n)) mod m = 
f (fst (stepN n st)) mod m /\
(x *
 (pre_div62Modulo m
    (q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
     r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
  <span class="mi">2</span> ^ Z.of_nat n)) mod m = 
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2a1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2a1"><span class="nb">rewrite</span> &lt;- !(Zmult_mod_idemp_l x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x mod m *
 (pre_div62Modulo m
    (u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
     v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
  <span class="mi">2</span> ^ Z.of_nat n)) mod m = 
f (fst (stepN n st)) mod m /\
(x mod m *
 (pre_div62Modulo m
    (q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
     r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
  <span class="mi">2</span> ^ Z.of_nat n)) mod m = 
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2a2" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2a2"><span class="nb">replace</span> x <span class="kr">with</span> (x*<span class="mi">1</span>) <span class="bp">by</span> <span class="bp">ring</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((x * <span class="mi">1</span>) mod m *
 (pre_div62Modulo m
    (u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
     v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
  <span class="mi">2</span> ^ Z.of_nat n)) mod m = 
f (fst (stepN n st)) mod m /\
((x * <span class="mi">1</span>) mod m *
 (pre_div62Modulo m
    (q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
     r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
  <span class="mi">2</span> ^ Z.of_nat n)) mod m = 
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2a3" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2a3"><span class="nb">rewrite</span> &lt;- !(Zmult_mod_idemp_r <span class="mi">1</span>), &lt;-Hinv, !Zmult_mod_idemp_r, !Zmult_mod_idemp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x * (modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n) *
 (pre_div62Modulo m
    (u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
     v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
  <span class="mi">2</span> ^ Z.of_nat n)) mod m = 
f (fst (stepN n st)) mod m /\
(x * (modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n) *
 (pre_div62Modulo m
    (q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
     r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) /
  <span class="mi">2</span> ^ Z.of_nat n)) mod m = 
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2a4" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2a4"><span class="nb">rewrite</span> &lt;-!Z.mul_assoc, &lt;-!Zdivide_Zdiv_eq <span class="bp">by</span> <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x *
 (modInv (<span class="mi">2</span> ^ Z.of_nat n) m *
  pre_div62Modulo m
    (u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
     v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))))) mod m =
f (fst (stepN n st)) mod m /\
(x *
 (modInv (<span class="mi">2</span> ^ Z.of_nat n) m *
  pre_div62Modulo m
    (q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
     r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))))) mod m =
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2a5" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2a5"><span class="nb">rewrite</span> !Z.mul_assoc, &lt;-!(Zmult_mod_idemp_r (pre_div62Modulo m _)), !Hpre1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x * modInv (<span class="mi">2</span> ^ Z.of_nat n) m *
 ((u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) mod m)) mod m =
f (fst (stepN n st)) mod m /\
(x * modInv (<span class="mi">2</span> ^ Z.of_nat n) m *
 ((q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) mod m)) mod m =
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2a6" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2a6"><span class="nb">assert</span> (Hab : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, eqm m (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) + b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) (a*d + b*e)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="divstep-v-chk2a7" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</span></span></span><br></div><label class="goal-separator" for="divstep-v-chk2a7"><hr></label><div class="goal-conclusion">(x * modInv (<span class="mi">2</span> ^ Z.of_nat n) m *
 ((u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) mod m)) mod m =
f (fst (stepN n st)) mod m /\
(x * modInv (<span class="mi">2</span> ^ Z.of_nat n) m *
 ((q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) mod m)) mod m =
g (fst (stepN n st)) mod m</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2a8" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2a8"><span class="mi">1</span>:{</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2a9" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2a9"><span class="nb">intros</span> a b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br><span><var>a, b</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"> </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Zplus_eqm;<span class="nb">apply</span> Zmult_eqm;<span class="kp">try</span> <span class="nb">apply</span> eqm_refl;<span class="nb">destruct</span> (Z.ltb _ _);<span class="nb">unfold</span> eqm;
  <span class="nb">rewrite</span> &lt;-Zplus_mod_idemp_r, <span class="nl">?Z_mod_same_full</span>, <span class="nl">?Zmod_0_l</span>;<span class="nb">f_equal</span>;<span class="kp">try</span> <span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2aa" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2aa">}</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x * modInv (<span class="mi">2</span> ^ Z.of_nat n) m *
 ((u * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   v * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) mod m)) mod m =
f (fst (stepN n st)) mod m /\
(x * modInv (<span class="mi">2</span> ^ Z.of_nat n) m *
 ((q * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   r * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>))) mod m)) mod m =
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2ab" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2ab"><span class="nb">rewrite</span> !Hab, !Zmult_mod_idemp_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(x * modInv (<span class="mi">2</span> ^ Z.of_nat n) m * (u * d + v * e))
mod m = f (fst (stepN n st)) mod m /\
(x * modInv (<span class="mi">2</span> ^ Z.of_nat n) m * (q * d + r * e))
mod m = g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2ac" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2ac"><span class="nb">rewrite</span> !(Z.mul_comm (x * _)), !Z.mul_assoc, !(Z.mul_add_distr_r _ _ x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((u * d * x + v * e * x) * modInv (<span class="mi">2</span> ^ Z.of_nat n) m)
mod m = f (fst (stepN n st)) mod m /\
((q * d * x + r * e * x) * modInv (<span class="mi">2</span> ^ Z.of_nat n) m)
mod m = g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2ad" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2ad"><span class="nb">rewrite</span> &lt;-!Z.mul_assoc, !(Z.mul_comm _ x).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((u * (x * d) + v * (x * e)) *
 modInv (<span class="mi">2</span> ^ Z.of_nat n) m) mod m =
f (fst (stepN n st)) mod m /\
((q * (x * d) + r * (x * e)) *
 modInv (<span class="mi">2</span> ^ Z.of_nat n) m) mod m =
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2ae" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2ae"><span class="nb">rewrite</span> &lt;-!(Zmult_mod_idemp_l (_ + _)), !(Zplus_mod (_ * (x * d))), &lt;- !(Zmult_mod_idemp_r (x * _)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(((u * ((x * d) mod m)) mod m +
  (v * ((x * e) mod m)) mod m) mod m *
 modInv (<span class="mi">2</span> ^ Z.of_nat n) m) mod m =
f (fst (stepN n st)) mod m /\
(((q * ((x * d) mod m)) mod m +
  (r * ((x * e) mod m)) mod m) mod m *
 modInv (<span class="mi">2</span> ^ Z.of_nat n) m) mod m =
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2af" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2af"><span class="nb">rewrite</span> Hf, Hg, !Zmult_mod_idemp_r, &lt;-!Zplus_mod, !Zmult_mod_idemp_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">((u * f st + v * g st) * modInv (<span class="mi">2</span> ^ Z.of_nat n) m)
mod m = f (fst (stepN n st)) mod m /\
((q * f st + r * g st) * modInv (<span class="mi">2</span> ^ Z.of_nat n) m)
mod m = g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2b0" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2b0"><span class="nb">rewrite</span> !(Z.mul_comm (_ + _)), &lt;-Hfuv, &lt;-Hgqr, !Z.mul_assoc.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n *
 f (fst (stepN n st))) mod m =
f (fst (stepN n st)) mod m /\
(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n *
 g (fst (stepN n st))) mod m =
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="divstep-v-chk2b1" style="display: none" type="checkbox"><label class="alectryon-input" for="divstep-v-chk2b1"><span class="nb">rewrite</span> &lt;-!(Zmult_mod_idemp_l (_ * _)), Hinv, !Zmult_mod_idemp_l, !Z.mul_1_l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>m, x, d, e</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>st</var><span class="hyp-type"><b>: </b><span>State</span></span></span><br><span><var>Hoddm</var><span class="hyp-type"><b>: </b><span>Zodd m</span></span></span><br><span><var>Hf</var><span class="hyp-type"><b>: </b><span>eqm m (x * d) (f st)</span></span></span><br><span><var>Hg</var><span class="hyp-type"><b>: </b><span>eqm m (x * e) (g st)</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>u, v, q, r</var><span class="hyp-type"><b>: </b><span>Z</span></span></span><br><span><var>Hgqr</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * g (fst (stepN n st)) =
q * f st + r * g st</span></span></span><br><span><var>Hfuv</var><span class="hyp-type"><b>: </b><span><span class="mi">2</span> ^ Z.of_nat n * f (fst (stepN n st)) =
u * f st + v * g st</span></span></span><br><span><var>Hpre1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
pre_div62Modulo m a mod m = a mod m</span></span></span><br><span><var>Hpre2</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : Z,
(<span class="mi">2</span> ^ Z.of_nat n | pre_div62Modulo m a)</span></span></span><br><span><var>Hn</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt; <span class="mi">2</span> ^ Z.of_nat n</span></span></span><br><span><var>Hinv</var><span class="hyp-type"><b>: </b><span>(modInv (<span class="mi">2</span> ^ Z.of_nat n) m * <span class="mi">2</span> ^ Z.of_nat n)
mod m = <span class="mi">1</span> mod m</span></span></span><br><span><var>Hab</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : Z,
eqm m
  (a * (d + (<span class="kr">if</span> d &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)) +
   b * (e + (<span class="kr">if</span> e &lt;? <span class="mi">0</span> <span class="kr">then</span> m <span class="kr">else</span> <span class="mi">0</span>)))
  (a * d + b * e)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f (fst (stepN n st)) mod m =
f (fst (stepN n st)) mod m /\
g (fst (stepN n st)) mod m =
g (fst (stepN n st)) mod m</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></article></body></html>